/********************************************************************************************
 *  sb_scan.c
 *
 *  created : 2020
 *  author  : Enkhbold Ochirsuren, Dietrich Beck, GSI-Darmstadt
 *  version : 24-February-2021, 14-May-2020
 *
 *  LM32 firmware for SCU bus scanner
 *
 * -------------------------------------------------------------------------------------------
 * License Agreement for this software:
 *
 * Copyright (C) 2018  Dietrich Beck
 * GSI Helmholtzzentrum fuer Schwerionenforschung GmbH
 * Planckstrasse 1
 * D-64291 Darmstadt
 * Germany
 *
 * Contact: d.beck@gsi.de
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 3 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library. If not, see <http://www.gnu.org/licenses/>.
 *
 * For all questions and ideas contact: d.beck@gsi.de
 * Last update: 22-November-2018
 ********************************************************************************************/
#define SB_SCANNER_FW_VERSION 0x000100                                  // make this consistent with makefile

// standard includes
#include <stdio.h>
#include <string.h>
#include <inttypes.h>
#include <stdint.h>

// includes specific for bel_projects
#include "dbg.h"                                                        // debug outputs
#include <stack.h>
#include "pp-printf.h"                                                  // print statement
#include "mini_sdb.h"                                                   // SDB stuff
#include "aux.h"                                                        // cpu and IRQ
#include "uart.h"                                                       // WR console
#include "ebm.h"                                                        // EB master

// includes for this project
#include <common-defs.h>                                                // common defs for firmware
#include <common-fwlib.h>                                               // common routines for firmware
#include <fbas_common.h>                                                // common defs for FBAS
#include <fbas.h>                                                       // user command code
#include <sb_scan_shared_mmap.h>                                        // autogenerated upon building firmware
#include <sb_scan.h>                                                    // application header file

// stuff required for environment
extern uint32_t* _startshared[];
unsigned int     cpuId, cpuQty;
#define  SHARED  __attribute__((section(".shared")))
uint64_t SHARED  dummy = 0;

volatile uint32_t *pECAQ;               // WB address of ECA queue
volatile uint32_t *pPPSGen;             // WB address of PPS Gen
volatile uint32_t *pWREp;               // WB address of WR Endpoint
extern volatile uint32_t *pIOCtrl;      // WB address of IO Control
volatile uint16_t *pSbMaster;           // WB address of SCU bus master

// global variables
// shared memory layout
uint32_t *pShared;                      // pointer to begin of shared memory region
uint32_t *pCpuRamExternal;              // external address (seen from host bridge) of this CPU's RAM
uint32_t *pSharedMacHi;                 // pointer to a "user defined" u32 register; here: high bits of MAC
uint32_t *pSharedMacLo;                 // pointer to a "user defined" u32 register; here: low bits of MAC
uint32_t *pSharedIp;                    // pointer to a "user defined" u32 register; here: IP
uint32_t *pSharedSetSbSlaves;           // pointer to a "user defined" u32 register; here: SCU bus slaves (bit1=slot1)
uint32_t *pSharedGetSbSlaves;           // pointer to a "user defined" u32 register; here: SCU bus slaves (bit1=slot1)
uint32_t *pSharedGetSbStd;              // pointer to a "user defined" u32 register; here: standard registers of a SCU bus slave

// other global stuff
uint32_t statusArray;                   // all status infos are ORed bit-wise into sum status, sum status is then published

// application-specific variables
uint64_t tsLast = 0;                    // last timestamp of system time
uint32_t cntMpsSignal = 0;              // counter for MPS signals
uint32_t cntCmd = 0;                    // counter for user commands
uint32_t sbSlaves = 0;                  // SCU bus slaves (bit1=slot1)
uint16_t configDiob[N_DIOB_CFG] = {0};  // configuration registers of DIOB
uint16_t statusDiob[N_DIOB_STS] = {0};  // status registers of DIOB
uint16_t configUser[N_USR_CFG] = {0};   // configuration registers of user interface (extension) card
uint16_t statusUser[N_USR_STS] = {0};   // status registers of user interface (extension) card
uint16_t outputUser[N_USR_OUT] = {0};   // output registers of user interface (extension) card
uint16_t inputUser[N_USR_IN] = {0};     // input registers of user interface (extension) card

enum regSetNum {
  DIOB_CFG = 0,   // configuration register set of DIOB
  DIOB_STS,
  USR_CFG,        // configuration register set of an user interface card
  USR_STS,
  USR_OUT,        // output register set of an user interface card
  USR_IN,
  N_REGSET
};

regset_t regSet[N_REGSET] = {
// user register base, offset, number of registers
  {STD_REG_BASE, DIOB_Config_Reg1, N_DIOB_CFG},
  {STD_REG_BASE, DIOB_Status_Reg1, N_DIOB_STS},
  {USR_REG_BASE, Usr_Config_Reg1,  N_USR_CFG},
  {USR_REG_BASE, Usr_Status_Reg1,  N_USR_STS},
  {USR_REG_BASE, Usr_Out_Reg1,     N_USR_OUT},
  {USR_REG_BASE, Usr_In_Reg1,      N_USR_IN},
};

// application-specific function prototypes
static void initLast();
static status_t probeSbSlave(volatile uint16_t* pMaster, uint16_t sysId, uint16_t grpId, uint32_t* slaves);
static void probeSbSlaveExt(volatile uint16_t* pMaster, uint32_t slot, uint32_t* pSharedDest);
static status_t readSbSlaveReg(volatile uint16_t* pSlave, regset_t* regset, uint16_t *pData);
static status_t writeSbSlaveReg(volatile uint16_t* pSlave, regset_t* regset, uint16_t *pData);

// probe SCU bus slave
// pMaster - address of the SCU bus master
// sysId   - CID system ID of a SCU bus slave
// grpID   - CID group ID of a SCU bus slave
// slaves  - available SCU bus slaves with the given CID (bit1=slot1, bits=31..0)
// retval  - status code
status_t probeSbSlave(volatile uint16_t* pMaster, uint16_t sysId, uint16_t grpId, uint32_t* slaves)
{
  int slot;
  uint16_t cidSys, cidGrp, u16val;

  if (!pMaster || !slaves || !sysId || !grpId)
    return COMMON_STATUS_ERROR;

  for (slot = 1; slot <= N_SB_SLOTS; slot++) {
    cidSys = *(pMaster + (slot << 16) + SBS_CID_SYS); // get CID system ID of a SCU bus slave
    cidGrp = *(pMaster + (slot << 16) + SBS_CID_GRP); // get CID group ID of a SCU bus slave
    if (cidSys == sysId && cidGrp == grpId) {
      *slaves |= (uint32_t)(0x1) << slot;

      DBPRINT1("sb_scan: slot=%d, sys=0x%x, grp=0x%x detected\n",
          slot, sysId, grpId);

      // standard register values of a chosen SCU bus slave
      u16val  = *(pMaster + (slot << 16) + SBS_SLAVE_ID); // get slave ID
      DBPRINT1("\t       id=0x%x\n", u16val);

      u16val  = *(pMaster + (slot << 16) + SBS_FW_VER);  // get FW version
      DBPRINT1("\t   fw ver=0x%x\n", u16val);

      u16val  = *(pMaster + (slot << 16) + SBS_FW_REL);  // get FW release
      DBPRINT1("\t   fw rel=0x%x\n", u16val);

      u16val  = *(pMaster + (slot << 16) + SBS_MACRO_VER); // get version and release of macro
      DBPRINT1("\tmacro ver=0x%x\n", u16val);

      u16val  = *(pMaster + (slot << 16) + SBS_CLK_10K); // get clock frequency of macro
      DBPRINT1("\tmacro clk=%d [MHz]\n", u16val/100);

      u16val  = *(pMaster + (slot << 16) + SBS_EXT_CID_SYS); // get extension system ID
      DBPRINT1("\t  ext sys=0x%x\n", u16val);

      u16val  = *(pMaster + (slot << 16) + SBS_EXT_CID_GRP); // get extension group ID
      DBPRINT1("\t  ext grp=0x%x\n", u16val);

      u16val  = *(pMaster + (slot << 16) + SBS_ECHO); // get echo register
      DBPRINT1("\t     echo=0x%x\n", u16val);

      u16val  = *(pMaster + (slot << 16) + SBS_STATUS); // get status register
      DBPRINT1("\t   status=0x%x\n", u16val);

      // probe extension card of a SCU bus slave
      probeSbSlaveExt(pMaster, slot, pSharedGetSbStd);

    } else {
      DBPRINT1("sb_scan: slot=%d, sys=0x%x, grp=0x%x not found\n",
          slot, sysId, grpId);
    }
  }

  DBPRINT1("sb_scan: slaves=%08x (slot1 starts at bit1)\n", *slaves);
  return COMMON_STATUS_OK;
}

// probe an extension card of a SCU bus slave
// pMaster     - address of the SCU bus master
// slot        - SCU bus slot number
// pSharedDest - destination location in the shared memory
void probeSbSlaveExt(volatile uint16_t* pMaster, uint32_t slot, uint32_t* pSharedDest)
{
  uint16_t u16val, u16val2;
  uint32_t u32val, u32val2;

  u32val = (0x1) << slot;              // encode slot to bit (slot1=bit1, bits=0..31)
  u32val <<= 16;                       // offset for a SCU bus slave
  u16val  = *(pMaster + u32val + SBS_EXT_CID_SYS); // read extension CID system ID
  u16val2 = *(pMaster + u32val + SBS_EXT_CID_GRP); // read extension CID group ID

  if (u16val != SBS_CID_NO_EXT) {
    u32val = u16val;
    u32val <<= 16;
    u32val |= u16val2;

    *(pSharedDest + SBS_EXT_CID_SYS + slot - 1) = u32val;
    DBPRINT1("\textension=yes (sys=0x%04x, grp=0x%04x)\n", u16val, u16val2);

  } else {
    DBPRINT1("\textension=no (sys=0x%04x, grp=0x%04x)\n", u16val, u16val2);
  }
}

// read the register set of a slave on SCU bus
// pSlave - address of the SCU bus slave
// offset - offset of register set
// len    - number of registers
// pData  - data buffer for the register set
// retval - status code
status_t readSbSlaveReg(volatile uint16_t* pSlave, regset_t* regset, uint16_t *pData)
{
  uint16_t i;

  if (!pSlave || !pData)
    return COMMON_STATUS_ERROR;

  for (i = 0; i < regset->len; ++i)
    *(pData + i) = *(pSlave + regset->base + regset->offset + i);

  DBPRINT1("sb_scan: sb=%x, base=%x, off=%x, len=%x\n",
      pSlave, regset->base, regset->offset, regset->len);
  return COMMON_STATUS_OK;
}

// write data to the register set of a slave on SCU bus
// pSlave - address of the SCU bus slave
// offset - offset of register set
// len    - number of registers
// pData  - data buffer for the register set
// retval - status code
status_t writeSbSlaveReg(volatile uint16_t* pSlave, regset_t* regset, uint16_t *pData)
{
  uint16_t i;

  if (!pSlave || !pData)
    return COMMON_STATUS_ERROR;

  for (i = 0; i < regset->len; ++i)
    *(pSlave + regset->base + regset->offset + i) = *(pData + i);

  return COMMON_STATUS_OK;
}

// typical init for lm32
void init()
{
  discoverPeriphery();        // mini-sdb ...
  uart_init_hw();             // needed by WR console
  cpuId = getCpuIdx();
} // init


// determine address and clear shared mem
void initSharedMem(uint32_t *sharedSize)
{
  uint32_t idx;
  uint32_t *pSharedTemp;
  int      i;
  const uint32_t c_Max_Rams = 10;
  sdb_location found_sdb[c_Max_Rams];
  sdb_location found_clu;

  // get pointer to shared memory
  pShared           = (uint32_t *)_startshared;

  // find address of CPU from external perspective
  idx = 0;
  find_device_multi(&found_clu, &idx, 1, GSI, LM32_CB_CLUSTER);
  idx = 0;
  find_device_multi_in_subtree(&found_clu, &found_sdb[0], &idx, c_Max_Rams, GSI, LM32_RAM_USER);
  if(idx >= cpuId) pCpuRamExternal           = (uint32_t *)(getSdbAdr(&found_sdb[cpuId]) & 0x7FFFFFFF); // CPU sees the 'world' under 0x8..., remove that bit to get host bridge perspective

  // print WB addresses (shared RAM, range reserved to user, command buffer etc) to WR console
  pSharedTemp = pCpuRamExternal + (SHARED_OFFS >> 2) + (COMMON_SHARED_CMD >> 2);
  DBPRINT2("sb_scan: CPU RAM External 0x%8x, begin shared 0x%08x, command 0x%08x\n",
      pCpuRamExternal, SHARED_OFFS, pSharedTemp);

  // clear shared mem
  i = 0;
  pSharedTemp        = (uint32_t *)(pShared + (COMMON_SHARED_BEGIN >> 2 ));
  DBPRINT2("sb_scan: app specific shared begin 0x%08x\n", pSharedTemp);
  while (pSharedTemp < (uint32_t *)(pShared + (FBAS_SHARED_END >> 2 ))) {
    *pSharedTemp = 0x0;
    pSharedTemp++;
    i++;
  }

  // get shared memory usage
  *sharedSize = ((uint32_t)(pSharedTemp - pShared) << 2);

  // print shared RAM locations reserved to store user input data
  pSharedSetSbSlaves = (uint32_t *)(pShared + (FBAS_SHARED_SET_SBSLAVES >> 2));
  pSharedGetSbSlaves = (uint32_t *)(pShared + (FBAS_SHARED_GET_SBSLAVES >> 2));
  pSharedGetSbStd = (uint32_t *)(pShared + (FBAS_SHARED_GET_SBSTDBEGIN >> 2));
  DBPRINT1("sb_scan: SHARED_SET_SBSLAVES 0x%08x\n", pSharedSetSbSlaves);
  DBPRINT1("sb_scan: SHARED_GET_SBSLAVES 0x%08x\n", pSharedGetSbSlaves);
  DBPRINT1("sb_scan: SHARED_GET_SBSTDBEGIN 0x%08x\n", pSharedGetSbStd);

}

// clears all statistics
void extern_clearDiag()
{
  // ... insert code here
} // clearDiag

// entry action configured state
uint32_t extern_entryActionConfigured()
{
  uint32_t status = COMMON_STATUS_OK;

  // disable input gate
  fwlib_ioCtrlSetGate(0, 2);

  // configure Etherbone master (src MAC and IP are set by host, i.e. by eb-console or BOOTP)
  if ((status = fwlib_ebmInit(TIM_2000_MS, BROADCAST_MAC, BROADCAST_IP, EBM_NOREPLY)) != COMMON_STATUS_OK) {
    DBPRINT1("sb_scan: ERROR - init of EB master failed! %u\n", (unsigned int)status); // IP unset
  }

  fwlib_publishNICData(); // NIC data (MAC, IP) are assigned to global variables (pSharedIp, pSharedMacHi/Lo)

  return status;
} // entryActionConfigured


// entry action state 'op ready'
uint32_t extern_entryActionOperation()
{
  uint32_t status = COMMON_STATUS_OK;

  //... insert code here

  return status;
} // entryActionOperation

// exit action state 'op ready'
uint32_t extern_exitActionOperation(){
  uint32_t status = COMMON_STATUS_OK;

  //... insert code here

  return status;
} // exitActionOperation


// command handler, handles commands specific for this project
void cmdHandler(uint32_t *reqState, uint32_t cmd)
{
  uint8_t u8val;
  uint16_t u16val, u16val2;
  uint32_t u32val, i, j;
  status_t retval;
  volatile uint16_t *pSlave;

  // check, if the command is valid and request state change
  if (cmd) {                             // check, if cmd is valid
    cntCmd++;
    switch (cmd) {                       // do action according to command
      case FBAS_CMD_PROBE_SB_DIOB:       // probe DIOB card on SCU bus
        if (probeSbSlave(pSbMaster, CID_SYS_DIOB, CID_GRP_DIOB, &sbSlaves) == COMMON_STATUS_OK) {
          *pSharedGetSbSlaves = sbSlaves;

          for (i = 1; i < N_SB_SLOTS; ++i) {
            u32val = (sbSlaves >> i) & 0x01;

            if (u32val) {
              u32val <<= 16;                   // offset for a SCU bus slave
              pSlave = pSbMaster + u32val;     // address of slave device on the SCU bus

              retval = readSbSlaveReg(pSlave, &regSet[DIOB_CFG], configDiob);  // get the DIOB configuration
              retval |= readSbSlaveReg(pSlave, &regSet[DIOB_STS], statusDiob);  // get the DIOB status

              if (retval == COMMON_STATUS_OK) {
                for (j = 0; j < regSet[DIOB_CFG].len; ++j)
                  *(pSharedGetSbStd + (FBAS_SHARED_GET_SBCFGDIOB >> 2) + j) = configDiob[j];

                for (j = 0; j < regSet[DIOB_STS].len; ++j)
                  *(pSharedGetSbStd + (FBAS_SHARED_GET_SBSTSDIOB >> 2) + j) = statusDiob[j];

                break; // FIXME: consider only 1st slave device
              }
            }
          }

          DBPRINT1("sb_scan: DIOB cfg %08x, sts %08x\n",
              (pSharedGetSbStd + (FBAS_SHARED_GET_SBCFGDIOB >> 2)),
              (pSharedGetSbStd + (FBAS_SHARED_GET_SBSTSDIOB >> 2)));
        } else
          DBPRINT1("sb_scan: probe failed!\n");
        break;
      case FBAS_CMD_PROBE_SB_USER:       // probe a slave card (CID must be provided in shared mem)
        u32val = *pSharedSetSbSlaves;
        u16val = (uint16_t)(u32val);         // CID sys addr
        u16val2 = (uint16_t)(u32val >> 16);  // CID group addr

        if (u16val && u16val2) {
          if (probeSbSlave(pSbMaster, u16val, u16val2, &sbSlaves) == COMMON_STATUS_OK) {
            *pSharedGetSbSlaves = sbSlaves;
          } else
            DBPRINT1("sb_scan: probe failed!\n");
        } else
          DBPRINT1("sb_scan: invalid CID (sys=%x, grp=%x)\n", u16val, u16val2);
        break;
      default:
        DBPRINT1("sb_scan: received unknown command '0x%08x'\n", cmd);
        break;
    } // switch
  } // if command
} // cmdHandler


// do action state 'op ready' - this is the main code of this FW
uint32_t doActionOperation(uint32_t actStatus)                // actual status of firmware
{
  uint32_t status;                                            // status returned by routines
  uint32_t nSeconds = 15;                                     // time period in secondes
  uint32_t nUSeconds = 100 * COMMON_ECATIMEOUT;               // time period in microseconds

  status = actStatus;

  return status;
} // doActionOperation

// get MAC/IP address of the Endpoint WB device
uint32_t getEndpointInfo()
{
  uint32_t status;

  status = fwlib_doActionS0();                  // find addresses of common used WB devices
  if (status != COMMON_STATUS_OK) return status;

  pSbMaster = fwlib_getSbMaster();
  DBPRINT1("sb_scan: pECAQ=%08x, pIOCtrl=%08x, pSbMaster=%08x\n", pECAQ, pIOCtrl, pSbMaster);

  status = extern_entryActionConfigured();      // get NIC data
  if (status != COMMON_STATUS_OK) return status;

  uint32_t octet0 = 0x000000ff;
  uint32_t octet1 = octet0 << 8;
  uint32_t octet2 = octet0 << 16;
  uint32_t octet3 = octet0 << 24;

  DBPRINT2("sb_scan: MAC=%02x:%02x:%02x:%02x:%02x:%02x, IP=%d.%d.%d.%d\n",
      (*pSharedMacHi & octet1) >> 8, (*pSharedMacHi & octet0),
      (*pSharedMacLo & octet3) >> 24,(*pSharedMacLo & octet2) >> 16,
      (*pSharedMacLo & octet1) >> 8, (*pSharedMacLo & octet0),
      (*pSharedIp & octet3) >> 24,(*pSharedIp & octet2) >> 16,
      (*pSharedIp & octet1) >> 8, (*pSharedIp & octet0));
  return status;
}

// init last system time
void initLast()
{
  tsLast = getSysTime();
}

void initAppData()
{
  initLast();             // init the last timestamp of the system time
  getEndpointInfo();      // get MAC/IP address of the Endpoint WB device
  cntMpsSignal = 0;
}

int main(void) {
  uint32_t status;                                            // (error) status
  uint32_t cmd;                                               // command via shared memory
  uint32_t actState;                                          // actual FSM state
  uint32_t pubState;                                          // value of published state
  uint32_t reqState;                                          // requested FSM state
  uint32_t *buildID;
  uint32_t sharedSize;                                        // shared memory size

  // init local variables
  reqState       = COMMON_STATE_S0;
  actState       = COMMON_STATE_UNKNOWN;
  pubState       = COMMON_STATE_UNKNOWN;
  status         = COMMON_STATUS_OK;
  buildID        = (uint32_t *)(INT_BASE_ADR + BUILDID_OFFS); // required for 'stack check'

  // init
  init();                                                              // initialize stuff for lm32
  initSharedMem(&sharedSize);                                                     // initialize shared memory
  fwlib_init((uint32_t *)_startshared, pCpuRamExternal, SHARED_OFFS, sharedSize, "sb_scan", SB_SCANNER_FW_VERSION); // init common stuff
  fwlib_clearDiag();                                                   // clear common diagnostic data

  initAppData();                                                       // initialize everything specific to this application

  while (1) {
    check_stack_fwid(buildID);                                         // check for stack corruption
    fwlib_cmdHandler(&reqState, &cmd);                                 // check for common commands and possibly request state changes
    cmdHandler(&reqState, cmd);                                        // check for project relevant commands
    status = COMMON_STATUS_OK;                                         // reset status for each iteration
    status = fwlib_changeState(&actState, &reqState, status);          // handle requested state changes
    switch(actState) {                                                 // state specific do actions
      case COMMON_STATE_OPREADY :
        status = doActionOperation(status);
        if (status == COMMON_STATUS_WRBADSYNC) reqState = COMMON_STATE_ERROR;
        if (status == COMMON_STATUS_ERROR)     reqState = COMMON_STATE_ERROR;
        break;
      default :                                                        // avoid flooding WB bus with unnecessary activity
        status = fwlib_doActionState(&reqState, actState, status);     // handle do actions states
        break;
    } // switch

    // update sum status
    switch (status) {
      case COMMON_STATUS_OK :                                                     // status OK
        statusArray = statusArray |  (0x1 << COMMON_STATUS_OK);                   // set OK bit
        break;
      default :                                                                   // status not OK
        if ((statusArray >> COMMON_STATUS_OK) & 0x1) fwlib_incBadStatusCnt();     // changing status from OK to 'not OK': increase 'bad status count'
        statusArray = statusArray & ~(0x1 << COMMON_STATUS_OK);                   // clear OK bit
        statusArray = statusArray |  (0x1 << status);                             // set status bit and remember other bits set
        break;
    } // switch status

    // update shared memory
    if ((pubState == COMMON_STATE_OPREADY) && (actState  != COMMON_STATE_OPREADY)) fwlib_incBadStateCnt();
    fwlib_publishStatusArray(statusArray);
    pubState             = actState;
    fwlib_publishState(pubState);
    // ... insert code here
  } // while

  return(1);
} // main
