/********************************************************************************************
 *  fbastx.c
 *
 *  created : 2020
 *  author  : Enkhbold Ochirsuren, Dietrich Beck, GSI-Darmstadt
 *  version : 04-February-2021, 14-May-2020
 *
 *  lm32 firmware for SCU running as FBAS TX node
 *  (based on common-libs/fw/example.c)
 *
 * -------------------------------------------------------------------------------------------
 * License Agreement for this software:
 *
 * Copyright (C) 2018  Dietrich Beck
 * GSI Helmholtzzentrum fuer Schwerionenforschung GmbH
 * Planckstrasse 1
 * D-64291 Darmstadt
 * Germany
 *
 * Contact: d.beck@gsi.de
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 3 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library. If not, see <http://www.gnu.org/licenses/>.
 *
 * For all questions and ideas contact: d.beck@gsi.de
 * Last update: 22-November-2018
 ********************************************************************************************/
#define FBASTX_FW_VERSION 0x000002                                     // make this consistent with makefile

// standard includes
#include <stdio.h>
#include <string.h>
#include <inttypes.h>
#include <stdint.h>

// includes specific for bel_projects
#include "dbg.h"                                                        // debug outputs
#include <stack.h>
#include "pp-printf.h"                                                  // print statement
#include "mini_sdb.h"                                                   // sdb stuff
#include "aux.h"                                                        // cpu and IRQ
#include "uart.h"                                                       // WR console
#include "ebm.h"                                                        // EB master
#include "../../../tools/wb_slaves.h"                                   //

// includes for this project
#include <common-defs.h>                                                // common defs for firmware
#include <common-fwlib.h>                                               // common routines for firmware
#include <fbastx_shared_mmap.h>                                         // autogenerated upon building firmware
#include <fbas.h>                                                       // application header file

// stuff required for environment
extern uint32_t* _startshared[];
unsigned int     cpuId, cpuQty;
#define  SHARED  __attribute__((section(".shared")))
uint64_t SHARED  dummy = 0;

volatile uint32_t *pECAQ;               // WB address of ECA queue
volatile uint32_t *pPPSGen;             // WB address of PPS Gen
volatile uint32_t *pWREp;               // WB address of WR Endpoint
volatile uint32_t *pIOCtrl;             // WB address of IO Control

// global variables
// shared memory layout
uint32_t *pShared;                      // pointer to begin of shared memory region
uint32_t *pCpuRamExternal;              // external address (seen from host bridge) of this CPU's RAM
uint32_t *pSharedMacHi;                 // pointer to a "user defined" u32 register; here: high bits of MAC
uint32_t *pSharedMacLo;                 // pointer to a "user defined" u32 register; here: low bits of MAC
uint32_t *pSharedIp;                    // pointer to a "user defined" u32 register; here: IP
uint32_t *pSharedSetNodeType;           // pointer to a "user defined" u32 register; here: node type (RX, TX, CM)
uint32_t *pSharedGetNodeType;           // pointer to a "user defined" u32 register; here: node type (RX, TX, CM)

// other global stuff
uint32_t statusArray;                   // all status infos are ORed bit-wise into sum status, sum status is then published

// application-specific variables
mpsEventData_t mpsEventData;            // data for the MPS event message
uint64_t tsLast = 0;                    // last timestamp of system time
uint32_t cntMpsSignal = 0;              // counter for MPS signals
nodeType_t nodeType = FBAS_NODE_TX;     // default node type

// application-specific function prototypes
static uint32_t pollEcaBlocking(uint32_t usTimeout);
static void wrConsolePeriodic(uint32_t seconds);
static void sendMpsProtocol(uint64_t deadline, uint8_t mpsFlag);

// typical init for lm32
void init()
{
  discoverPeriphery();        // mini-sdb ...
  uart_init_hw();             // needed by WR console
  cpuId = getCpuIdx();
} // init


// determine address and clear shared mem
void initSharedMem()
{
  uint32_t idx;
  uint32_t *pSharedTemp;
  int      i;
  const uint32_t c_Max_Rams = 10;
  sdb_location found_sdb[c_Max_Rams];
  sdb_location found_clu;

  // get pointer to shared memory
  pShared           = (uint32_t *)_startshared;

  // get address to data
  pSharedSetNodeType = (uint32_t *)(pShared + (FBAS_SHARED_SET_NODETYPE >> 2));
  pSharedGetNodeType = (uint32_t *)(pShared + (FBAS_SHARED_GET_NODETYPE >> 2));
  DBPRINT3("fbas%d: SHARED_SET_NODETYPE 0x%08x\n", nodeType, pSharedSetNodeType);
  DBPRINT3("fbas%d: SHARED_GET_NODETYPE 0x%08x\n", nodeType, pSharedGetNodeType);

  // find address of CPU from external perspective
  idx = 0;
  find_device_multi(&found_clu, &idx, 1, GSI, LM32_CB_CLUSTER);
  idx = 0;
  find_device_multi_in_subtree(&found_clu, &found_sdb[0], &idx, c_Max_Rams, GSI, LM32_RAM_USER);
  if(idx >= cpuId) pCpuRamExternal           = (uint32_t *)(getSdbAdr(&found_sdb[cpuId]) & 0x7FFFFFFF); // CPU sees the 'world' under 0x8..., remove that bit to get host bridge perspective

  DBPRINT2("fbas%d: CPU RAM External 0x%8x, begin shared 0x%08x\n", nodeType, pCpuRamExternal, SHARED_OFFS);

  // clear shared mem
  i = 0;
  pSharedTemp        = (uint32_t *)(pShared + (COMMON_SHARED_BEGIN >> 2 ));
  DBPRINT2("fbas%d: COMMON_SHARED_BEGIN 0x%08x\n", nodeType, pSharedTemp);
  // ... insert code here to clear shared RAM
  DBPRINT2("fbas%d: used size of shared mem is %d words (uint32_t), begin %x, end %x\n", nodeType, i, pShared, pSharedTemp-1);
} // initSharedMem


// clears all statistics
void extern_clearDiag()
{
  // ... insert code here
} // clearDiag

// entry action configured state
uint32_t extern_entryActionConfigured()
{
  uint32_t status = COMMON_STATUS_OK;

  // disable input gate
  fwlib_ioCtrlSetGate(0, 2);

  // configure Etherbone master (src MAC and IP are set by host, i.e. by eb-console or BOOTP)
  if ((status = fwlib_ebmInit(TIM_2000_MS, BROADCAST_MAC, BROADCAST_IP, EBM_NOREPLY)) != COMMON_STATUS_OK) {
    DBPRINT1("fbas%d: ERROR - init of EB master failed! %u\n", nodeType, (unsigned int)status); // IP unset
  }

  fwlib_publishNICData(); // NIC data (MAC, IP) are assigned to global variables (pSharedIp, pSharedMacHi/Lo)

  return status;
} // entryActionConfigured


// entry action state 'op ready'
uint32_t extern_entryActionOperation()
{
  uint32_t status = COMMON_STATUS_OK;

  //... insert code here

  return status;
} // entryActionOperation

// exit action state 'op ready'
uint32_t extern_exitActionOperation(){
  uint32_t status = COMMON_STATUS_OK;

  //... insert code here

  return status;
} // exitActionOperation


// command handler, handles commands specific for this project
void cmdHandler(uint32_t *reqState, uint32_t cmd)
{
  uint32_t u32val;
  // check, if the command is valid and request state change
  if (cmd) {                             // check, if cmd is valid
    switch (cmd) {                       // do action according to command
      case FBAS_CMD_SET_NODETYPE:
        u32val = *pSharedSetNodeType;
        if (u32val < FBAS_NODE_UNDEF) {
          nodeType = u32val;
          *pSharedGetNodeType = nodeType;
          DBPRINT3("fbas%d: node type %x\n", nodeType, nodeType);
        } else {
          DBPRINT3("fbas%d: invalid node type %x\n", nodeType, u32val);
        }
        break;
      default:
        DBPRINT3("fbas%d: received unknown command '0x%08x'\n", nodeType, cmd);
        break;
    } // switch
  } // if command
} // cmdHandler


// do action state 'op ready' - this is the main code of this FW
uint32_t doActionOperation(uint32_t actStatus)                // actual status of firmware
{
  uint32_t status;                                            // status returned by routines
  uint32_t nSeconds = 15;                                     // time period in secondes
  uint32_t nUSeconds = 100 * COMMON_ECATIMEOUT;               // time period in microseconds

  status = actStatus;

  pollEcaBlocking(nUSeconds);           // poll ECA action
  wrConsolePeriodic(nSeconds);          // periodic debug (level 3) output at console

  return status;
} // doActionOperation

// get MAC/IP address of the Endpoint WB device
uint32_t getEndpointInfo()
{
  uint32_t status;

  status = fwlib_doActionS0();                  // find addresses of common used WB devices
  if (status != COMMON_STATUS_OK) return status;

  status = extern_entryActionConfigured();      // get NIC data
  if (status != COMMON_STATUS_OK) return status;

  uint32_t octet0 = 0x000000ff;
  uint32_t octet1 = octet0 << 8;
  uint32_t octet2 = octet0 << 16;
  uint32_t octet3 = octet0 << 24;

  DBPRINT2("fbas%d: MAC=%02x:%02x:%02x:%02x:%02x:%02x, IP=%d.%d.%d.%d\n", nodeType,
      (*pSharedMacHi & octet1) >> 8, (*pSharedMacHi & octet0),
      (*pSharedMacLo & octet3) >> 24,(*pSharedMacLo & octet2) >> 16,
      (*pSharedMacLo & octet1) >> 8, (*pSharedMacLo & octet0),
      (*pSharedIp & octet3) >> 24,(*pSharedIp & octet2) >> 16,
      (*pSharedIp & octet1) >> 8, (*pSharedIp & octet0));
  return status;
}

// init of the MPS protocol data
void initMpsData()
{
  mpsEventData.evtId = fwlib_buildEvtidV1(FBAS_TM_GID, FBAS_TM_EVTNO,
      FBAS_TM_FLAGS, FBAS_TM_SID, FBAS_TM_BPID, FBAS_TM_RES);
  mpsEventData.mac = *pSharedMacHi;
  mpsEventData.mac <<= 32;
  mpsEventData.mac |= *pSharedMacLo;
  DBPRINT3("fbas%d: MPS protocol (evtId = %llu, mac = %llu)\n", nodeType,
      mpsEventData.evtId, mpsEventData.mac);
}

// init last system time
void initLast()
{
  tsLast = getSysTime();
}

void initAppData()
{
  initLast();             // init the last timestamp of the system time
  getEndpointInfo();      // get MAC/IP address of the Endpoint WB device
  initMpsData();          // init the MPS protocol data
  cntMpsSignal = 0;
}

// send MPS protocol
void sendMpsProtocol(uint64_t deadline, uint8_t mpsFlag)
{
  if (nodeType != FBAS_NODE_TX) // only FBAS transmitter sends MPS protocol
    return;

  uint64_t evtParam = mpsFlag;
  evtParam <<= 56;
  evtParam |= mpsEventData.mac;
  fwlib_ebmWriteTM(getSysTime(), mpsEventData.evtId, evtParam, 0);
}

uint32_t pollEcaBlocking(uint32_t usTimeout)
{
  uint32_t nextAction;    // action triggered by received ECA event
  uint64_t ecaDeadline;   // deadline of received ECA event
  uint64_t ecaEvtId;      // ID of received ECA event
  uint64_t ecaParam;      // parameter value in received ECA event
  uint32_t ecaTef;        // TEF value in received ECA event
  uint32_t flagIsLate;    // flag indicates that received ECA event is 'late'
  uint64_t now;           // actual timestamp of the system time

  nextAction = fwlib_wait4ECAEvent(usTimeout, &ecaDeadline, &ecaEvtId, &ecaParam, &ecaTef, &flagIsLate);

  if (nextAction) {
    now = getSysTime();

    if (nextAction == FBAS_IO_ACTION)
    {
      cntMpsSignal++;
      sendMpsProtocol(now, (uint8_t)cntMpsSignal);
    }
    int64_t poll = now - ecaDeadline;
    DBPRINT3("fbas%d: ECA action (tag %x, flag %x, ts %llu, now %llu, poll %lli)\n",
        nodeType, nextAction, flagIsLate, ecaDeadline, now, poll);
  }

  return nextAction;
}

// write a debug text to the WR console in given period (seconds)
void wrConsolePeriodic(uint32_t seconds)
{
  uint64_t period = seconds * 1000000000ULL;  // period in system time
  uint64_t soon = tsLast + period;             // next time point for the action
  uint64_t now = getSysTime();                // get the current time

  if (now >= soon) {                          // if the given period is over, then proceed
    //sendMpsProtocol((uint8_t)cntMpsSignal);
    DBPRINT3("fbas%d: now %llu, elap %lli\n", nodeType, now, now - tsLast);
    tsLast = now;
  }
}

int main(void) {
  uint32_t status;                                            // (error) status
  uint32_t cmd;                                               // command via shared memory
  uint32_t actState;                                          // actual FSM state
  uint32_t pubState;                                          // value of published state
  uint32_t reqState;                                          // requested FSM state
  uint32_t *buildID;

  // init local variables
  reqState       = COMMON_STATE_S0;
  actState       = COMMON_STATE_UNKNOWN;
  pubState       = COMMON_STATE_UNKNOWN;
  status         = COMMON_STATUS_OK;
  buildID        = (uint32_t *)(INT_BASE_ADR + BUILDID_OFFS); // required for 'stack check'

  // init
  init();                                                              // initialize stuff for lm32
  initSharedMem();                                                     // initialize shared memory
  fwlib_init((uint32_t *)_startshared, pCpuRamExternal, SHARED_OFFS, "fbastx", FBASTX_FW_VERSION); // init common stuff
  fwlib_clearDiag();                                                   // clear common diagnostic data

  initAppData();                                                       // initialize everything specific to this application

  while (1) {
    check_stack_fwid(buildID);                                         // check for stack corruption
    fwlib_cmdHandler(&reqState, &cmd);                                 // check for common commands and possibly request state changes
    cmdHandler(&reqState, cmd);                                        // check for project relevant commands
    status = COMMON_STATUS_OK;                                         // reset status for each iteration
    status = fwlib_changeState(&actState, &reqState, status);          // handle requested state changes
    switch(actState) {                                                 // state specific do actions
      case COMMON_STATE_OPREADY :
        status = doActionOperation(status);
        if (status == COMMON_STATUS_WRBADSYNC) reqState = COMMON_STATE_ERROR;
        if (status == COMMON_STATUS_ERROR)     reqState = COMMON_STATE_ERROR;
        break;
      default :                                                        // avoid flooding WB bus with unnecessary activity
        status = fwlib_doActionState(&reqState, actState, status);     // handle do actions states
        break;
    } // switch

    // update sum status
    switch (status) {
      case COMMON_STATUS_OK :                                                     // status OK
        statusArray = statusArray |  (0x1 << COMMON_STATUS_OK);                   // set OK bit
        break;
      default :                                                                   // status not OK
        if ((statusArray >> COMMON_STATUS_OK) & 0x1) fwlib_incBadStatusCnt();     // changing status from OK to 'not OK': increase 'bad status count'
        statusArray = statusArray & ~(0x1 << COMMON_STATUS_OK);                   // clear OK bit
        statusArray = statusArray |  (0x1 << status);                             // set status bit and remember other bits set
        break;
    } // switch status

    // update shared memory
    if ((pubState == COMMON_STATE_OPREADY) && (actState  != COMMON_STATE_OPREADY)) fwlib_incBadStateCnt();
    fwlib_publishStatusArray(statusArray);
    pubState             = actState;
    fwlib_publishState(pubState);
    // ... insert code here
  } // while

  return(1);
} // main
