/** @file fbas-mon.c (derived from eb-mon.c)
 *  @brief Command-line tool for monitoring FBAS via Etherbone.
 *
 *  Copyright (C) 2024 GSI Helmholtz Centre for Heavy Ion Research GmbH
 *
 *  Command-line tool for monitoring the FBAS firmware running on LM32
 *
 *  @author Enkhbold Ochirsuren <e.ochirsuren@gsi.de>
 *
 *  @bug Unknown!
 *
 *******************************************************************************
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 3 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library. If not, see <http://www.gnu.org/licenses/>.
 *******************************************************************************
 */

#define FBASMON_VERSION "0.0.1"
#define AHEADT       1000000     // data master works ahead of time [ns]
#define EARLYDT   1000000000     // detection limit for early events [ns]

// standard includes
#include <unistd.h> // getopt
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <time.h>
#include <sys/time.h>

// Etherbone API
#include <etherbone.h>

// Wishbone API
#include <wb_api.h>
#include <wb_slaves.h>

//#include "mini_sdb.h"              // causes error on redefintion of 'struct sdb_emtpy'
#define GSI            0x00000651ULL // vendor ID, uint64_t, defined in 'mini_sdb.h'
#define LM32_RAM_USER  0x54111351U   // device ID, uint32_t, defined in 'min_sdb.h'

#include "common-defs.h"             // common status
#include "fbas.h"
#include "../fw/fbas_shared_mmap.h"  // auto-generated by FW binary compilation

static const char* cmd_options="ab:c:def:ghij:klmoprs:t:u:vw:yz";
static const char* program;
static int verbose;
static eb_device_t deviceOther;      // other EB device for comparing timestamps

// global
eb_device_t device;
eb_socket_t ebSocket;

// statistics
struct stats_addr_s {
  uint32_t avg;             // location of the average value
  uint32_t min;             // location of the minimum value
  uint32_t max;             // location of the maximum value
};

// shared registers (layout in the shared memory of LM32)
struct shared_reg_s {
  uint32_t base;            // base address of the shared memory
  uint32_t state;           // actual state of LM32

  // set (write-only)
  uint32_t cmd;             // user command
  uint32_t set_node;        // set node type (TX or RX)
  uint32_t set_senderid;    // set sender ID

  // get
  uint32_t node;            // get node type
  uint32_t sb_slaves;
  uint32_t cnt;
  uint32_t ts1;             // timestamps
  uint32_t ts2;
  uint32_t ts3;
  uint32_t ts4;
  uint32_t ts5;
  uint32_t ts6;
  uint32_t avg;             // average value
  uint32_t min;             // min value
  uint32_t max;             // max value
  uint32_t vld;             // valid event counter
  uint32_t all;             // total events counter
  uint32_t eca_vld;         // ECA valid counter
  uint32_t eca_ovf;         // ECA overflow counter

  struct stats_addr_s tx_dly;    // transmission delay (LEMO feedback), 64-bit
  struct stats_addr_s sg_lty;    // signalling latency (LEMO feedback), 64-bit
  struct stats_addr_s msg_dly;   // messaging delay, 64-bit
  struct stats_addr_s ttl_prd;   // TTL period, 64-bit
  struct stats_addr_s eca_hndl;  // ECA handling, 64-bit
  struct stats_addr_s ml_prd;    // main loop period, 64-bit

} fbas_reg;

struct stats_val_s {
  uint64_t avg;             // average value
  uint64_t min;             // minimum value
  uint64_t max;             // maximum value
};

struct msr_s {
  struct stats_val_s tx_dly;    // transmission delay (LEMO feedback), 64-bit
  struct stats_val_s sg_lty;    // signalling latency (LEMO feedback), 64-bit
  struct stats_val_s msg_dly;   // messaging delay, 64-bit
  struct stats_val_s ttl_prd;   // TTL period, 64-bit
  struct stats_val_s eca_hndl;  // ECA handling, 64-bit
  struct stats_val_s ml_prd;    // main loop period, 64-bit
} msr;                          // global for delay measurement statistics

/**
 * @brief Exit on error
 *
 * @param where  descriptive error message
 * @param status EB status code
 *
 * @return none
*/
static void die(const char* where, eb_status_t status)
{
  fprintf(stderr, "%s: %s failed: %s\n",
          program, where, eb_status(status));
  exit(1);
}

/**
 * @brief Output usage description
 *
*/
static void help(void)
{
  fprintf(stdout, "Usage: %s [OPTION] <etherbone-device>\n", program);
  fprintf(stdout, "\n");
  fprintf(stdout, "  -a               display gateware 'build type'\n");
  fprintf(stdout, "  -b<busIndex>     display ID (ID of slave on the specified 1-wire bus)\n");
  fprintf(stdout, "  -c<eb-device>    compare timestamp with the one of <eb-device> and display the result\n");
  fprintf(stdout, "  -d               display WR time\n");
  fprintf(stdout, "  -e               display etherbone version\n");
  fprintf(stdout, "  -f<familyCode>   specify family code of 1-wire slave (0x43: EEPROM; 0x28,0x42: temperature)\n");
  fprintf(stdout, "  -g               display WR statistics (lock, time continuity)\n");
  fprintf(stdout, "  -h               display this help and exit\n");
  fprintf(stdout, "  -i               display WR IP\n");
  fprintf(stdout, "  -j<cpu>          display lm32 stall info (default: j0) \n");
  fprintf(stdout, "  -k               display 'ECA-Tap' statistics\n");
  fprintf(stdout, "  -l               display WR link status\n");
  fprintf(stdout, "  -m               display WR MAC\n");
  fprintf(stdout, "  -o               display offset between WR time and system time [ms]\n");
  fprintf(stdout, "  -p               display state of IP\n");
  fprintf(stdout, "  -r               snoop the delay measurements (use it together with -s)\n");
  fprintf(stdout, "  -s <secs> <cpu>  snoop for information continuously (and print warnings. THIS OPTION RESETS ALL STATS!)\n");
  fprintf(stdout, "  -t<busIndex>     display temperature of sensor on the specified 1-wire bus\n");
  fprintf(stdout, "  -u<index>        user 1-wire: specify WB device in case multiple WB devices of the same type exist (default: u0)\n");
  fprintf(stdout, "  -v               display verbose information\n");
  fprintf(stdout, "  -w<index>        WR 1-wire: specify WB device in case multiple WB devices of the same type exist (default: w0)\n");
  fprintf(stdout, "  -y               display WR sync status\n");
  fprintf(stdout, "  -z               display FPGA uptime [h]\n");
  fprintf(stdout, "\n");
  fprintf(stdout, "  wrstatreset  <tWrObs> <tStallObs>  command clears WR statistics and sets observation times (default: 8 50000)\n");
  fprintf(stdout, "  ecatapreset  <lateOffset>          command resets ECA-Tap and sets offset for detection of late events (default: 0)\n");
  fprintf(stdout, "  ecatapclear  <clearFlag>           command clears ECA-Tap counters (b3: late count, b2: count/accu, b1: max, b0: min)\n");
  fprintf(stdout, "  ecatapenable                       command enables capture on ECA-Tap\n");
  fprintf(stdout, "  ecatapdisable                      command disables capture on ECA-Tap\n");
  fprintf(stdout, "\n");
  fprintf(stdout, "Use this tool to get some info about WR enabled hardware.\n");
  fprintf(stdout, "Example1: '%s -v dev/wbm0' display typical information.\n", program);
  fprintf(stdout, "Example2: '%s -b0 -f0x43 dev/wbm0' read ID of EEPROM connected to 1st (user) 1-wire bus\n", program);
  fprintf(stdout, "\n");
  fprintf(stdout, "When using option '-s<n>', the following information is displayed\n");
  fprintf(stdout, "    WR [ns]   | CPU stall[%%]|   ECA [n(Hz)]                |  ECA dl-ts [us]\n");
  fprintf(stdout, "  lock +dt -dt|   max(  act)| nMessages( rate ) early late | min max avg(act)\n");
  fprintf(stdout, "     1  16   0| 32.71(17.87)|      2501(  69.0)     0    0 | 879 986   935(935)\n");
  fprintf(stdout, "     '   '   '      '     '           '      '      '    '    '   '     '   '\n");
  fprintf(stdout, "     '   '   '      '     '           '      '      '    '    '   '     '   '\n");
  fprintf(stdout, "     '   '   '      '     '           '      '      '    '    '   '     '   '- actual average (dl - ts)\n");
  fprintf(stdout, "     '   '   '      '     '           '      '      '    '    '   '     '- average (dl - ts)\n");
  fprintf(stdout, "     '   '   '      '     '           '      '      '    '    '   '- max (dl - ts) since last 'early event'\n");
  fprintf(stdout, "     '   '   '      '     '           '      '      '    '    '- min (deadline - timestamp) since last 'late event'\n");
  fprintf(stdout, "     '   '   '      '     '           '      '      '    '- # of late messages\n");
  fprintf(stdout, "     '   '   '      '     '           '      '       - # of early messages\n");
  fprintf(stdout, "     '   '   '      '     '           '      ' - actual message rate [Hz]\n");
  fprintf(stdout, "     '   '   '      '     '           '- total # of messages\n");
  fprintf(stdout, "     '   '   '      '     ' - actual rate of eCPU stalls (should be below '50.0')\n");
  fprintf(stdout, "     '   '   '      '- max continous eCPU stall (should be below '50.0')\n");
  fprintf(stdout, "     '   '   '- WR time continuity: maximum negative difference (should be '0')\n");
  fprintf(stdout, "     '   '- WR time continuity: maximum positive difference (should be '8' for a 125 MHz CPU clock)\n");
  fprintf(stdout, "     '- WR lock: '1' signals 'TRACK_PHASE'\n");
  fprintf(stdout, "\n");
  fprintf(stdout, "Option '-r' is for snoopping the delay measurement and used together with '-s'.\n");
  fprintf(stdout, " WR  | ECA [n(Hz)]                  |    ECA dl-ts [us]      | Delay avg/max [us]\n");
  fprintf(stdout, "lock | nMessages ( rate )      late |    max    avg    (act) | TX : Msg : Sig : ML\n");
  fprintf(stdout, "   1 |        20 (   1.0)         1 | 723596 408577 (154601) | 1/10 : 2/20 : 3/30: 4/40\n");
  fprintf(stdout, "                                                               '      '      '     '- main loop\n");
  fprintf(stdout, "                                                               '      '      '- signalling latency\n");
  fprintf(stdout, "                                                               '      '- messaging delay\n");
  fprintf(stdout, "                                                               '- transmission delay\n");
  fprintf(stdout, "\n");
  fprintf(stdout, "Report software bugs to <d.beck@gsi.de>\n");
  fprintf(stdout, "Version %s. Licensed under the LGPL v3.\n", FBASMON_VERSION);
}

/**
 * @brief Output the statistics header to stdout
*/
static void printStatsHeader(void)
{
  fprintf(stdout, "  WR [ns]   | CPU stall[%%]|   ECA [n(Hz)]                |  ECA dl-ts [us]\n");
  fprintf(stdout, "lock +dt -dt|   max(  act)| nMessages( rate ) early late | min max avg(act)\n");
}

/**
 * @brief Output the statistics data to stdout
 *
 * Certain statistics are not evaluated:
 * - latency: events from TX are not sent ahead
 *
*/
void printStatsData(int snoopInterval, int snoopLockFlag, int64_t contMaxPosDT, int64_t contMaxNegDT, double snoopStallMax, double snoopStallAct,
                    uint64_t ecaNMessage, int64_t ecaMin, int64_t ecaMax, int64_t ecaDtSum, int ecaLate, int ecaEarly)
{
  int average;                        // total average (dl-ts)
  int averageAct;                     // actual average (dl-ts)
  int64_t  dtSumAct;
  uint64_t nMessageAct;

  static uint64_t nMessagePrev = 0;
  static uint64_t dtSumPrev    = 0;

  average      = (int)(ecaDtSum/(1000*ecaNMessage+1)); // ns -> us

  dtSumAct     = ecaDtSum - dtSumPrev;
  nMessageAct  = ecaNMessage - nMessagePrev;
  averageAct   = (int)(dtSumAct/(1000*nMessageAct+1)); // ns -> us

  nMessagePrev = ecaNMessage;
  dtSumPrev    = ecaDtSum;

  fprintf(stdout, "%4d ", snoopLockFlag);
  fprintf(stdout, "%3d ", (int)contMaxPosDT);
  fprintf(stdout, "%3d|", (int)contMaxNegDT);
  fprintf(stdout, " %5.2f(%5.2f)|", snoopStallMax, snoopStallAct);
  if (ecaNMessage == 0) fprintf(stdout, " %9"PRIu64"(%6.1f)   %3d  %3d | %3d %3d %3d(%3d)", (uint64_t)0, 0.0, 0, 0, 0, 0, 0, 0);
  else                  fprintf(stdout, " %9"PRIu64"(%6.1f)   %3d  %3d | %3d %3d %3d(%3d)", ecaNMessage, (double)nMessageAct/(double)snoopInterval,
                                ecaEarly, ecaLate, (int)(ecaMin/1000), (int)(ecaMax/1000), average, averageAct);
  fprintf(stdout, "\n");
  fflush(stdout);

}

/**
 * @brief Output the delay measurement header to stdout
*/
static void printDelayMeasureHeader(void)
{
  fprintf(stdout, " WR  | ECA [n(Hz)]                  |    ECA dl-ts [us]      | Delay avg/max [us]\n");
  fprintf(stdout, "lock | nMessages ( rate )      late |    max    avg    (act) | TX : Msg : Sig : ML\n");
}

/**
 * @brief Output the measured average delay, latency to stdout
 *
*/
static void printDelayMeasureData(int snoopInterval, int snoopLockFlag, uint64_t ecaNMessage, int64_t ecaMax, int64_t ecaDtSum, int ecaLate,
                                  const struct msr_s *msr)
{
  int average;                        // total average (dl-ts)
  int averageAct;                     // actual average (dl-ts)
  int64_t  dtSumAct;
  uint64_t nMessageAct;

  static uint64_t nMessagePrev = 0;
  static uint64_t dtSumPrev    = 0;

  average      = (int)(ecaDtSum/(1000*ecaNMessage+1)); // ns -> us

  dtSumAct     = ecaDtSum - dtSumPrev;
  nMessageAct  = ecaNMessage - nMessagePrev;
  averageAct   = (int)(dtSumAct/(1000*nMessageAct+1)); // ns -> us

  nMessagePrev = ecaNMessage;
  dtSumPrev    = ecaDtSum;

  fprintf(stdout, "%4d ", snoopLockFlag);
  if (ecaNMessage == 0)
    fprintf(stdout, "| %9"PRIu64" (%6.1f) %9d | %6d %6d (%6d) | %ld/%ld : %ld/%ld : %ld/%ld : %ld/%ld", (uint64_t)0, 0.0, 0, 0, 0, 0,
            msr->tx_dly.avg, msr->tx_dly.max, msr->msg_dly.avg, msr->msg_dly.max, msr->sg_lty.avg, msr->sg_lty.max, msr->ml_prd.avg, msr->ml_prd.max);
  else
    fprintf(stdout, "| %9"PRIu64" (%6.1f) %9d | %6d %6d (%6d) | %ld/%ld : %ld/%ld : %ld/%ld : %ld/%ld", ecaNMessage, (double)nMessageAct/(double)snoopInterval,
            ecaLate, (int)(ecaMax/1000), average, averageAct,
            msr->tx_dly.avg, msr->tx_dly.max, msr->msg_dly.avg, msr->msg_dly.max, msr->sg_lty.avg, msr->sg_lty.max, msr->ml_prd.avg, msr->ml_prd.max);
  fprintf(stdout, "\n");
  fflush(stdout);

}

/**
 * @brief Print memory address of the shared registers
 *
 * @param reg Pointer to the registers
*/
static void printSharedRegs(struct shared_reg_s *reg)
{
  fprintf(stdout, "Register:      address (hex)\n");
  fprintf(stdout, "Base:          0x%x\n", reg->base);
  fprintf(stdout, "State:         0x%x\n", reg->state);

  fprintf(stdout, "Command:       0x%x\n", reg->cmd);
  fprintf(stdout, "Set node type: 0x%x\n", reg->set_node);
  fprintf(stdout, "Set sender ID: 0x%x\n", reg->set_senderid);

  fprintf(stdout, "Get node type: 0x%x\n", reg->node);
  fprintf(stdout, "SCU bus slave: 0x%x\n", reg->sb_slaves);
  fprintf(stdout, "Count:         0x%x\n", reg->cnt);
  fprintf(stdout, "Timestamp 1:   0x%x\n", reg->ts1);
  fprintf(stdout, "Timestamp 2:   0x%x\n", reg->ts2);
  fprintf(stdout, "Timestamp 3:   0x%x\n", reg->ts3);
  fprintf(stdout, "Timestamp 4:   0x%x\n", reg->ts4);
  fprintf(stdout, "Timestamp 5:   0x%x\n", reg->ts5);
  fprintf(stdout, "Timestamp 6:   0x%x\n", reg->ts6);
  fprintf(stdout, "Summary statistics:\n");
  fprintf(stdout, "Average:       0x%x\n", reg->avg);
  fprintf(stdout, "Minimum:       0x%x\n", reg->min);
  fprintf(stdout, "Maximum:       0x%x\n", reg->max);
  fprintf(stdout, "Valid:         0x%x\n", reg->vld);
  fprintf(stdout, "All:           0x%x\n", reg->all);
  fprintf(stdout, "ECA valid:     0x%x\n", reg->eca_vld);
  fprintf(stdout, "ECA ovflw:     0x%x\n", reg->eca_ovf);
  fprintf(stdout, "Delay measurements:\n");
  fprintf(stdout, "Transmit delay:    0x%x\n", reg->tx_dly.avg);
  fprintf(stdout, "Signaling latency: 0x%x\n", reg->sg_lty.avg);
  fprintf(stdout, "Messaging delay:   0x%x\n", reg->msg_dly.avg);
  fprintf(stdout, "TTL period:        0x%x\n", reg->ttl_prd.avg);
  fprintf(stdout, "ECA handle delay:  0x%x\n", reg->eca_hndl.avg);
  fprintf(stdout, "Main loop period:  0x%x\n", reg->ml_prd.avg);
}

/**
 * @brief Initialize the shared registers
 *
 * @param device     Target WB device
 * @param reg        Registers
 *
 * @return status     COMMON_STATUS_OK on success
*/
uint32_t wb_init_shared_regs(const eb_device_t device, struct shared_reg_s *reg)
{
  eb_status_t         status;
  struct sdb_device   sdbDevice;       // instantiated lm32 core
  int                 nDevices = 1;    // number of instantiated cores

  //  get Wishbone address of lm32
  if ((status = eb_sdb_find_by_identity(device, GSI, LM32_RAM_USER, &sdbDevice, &nDevices)) != EB_OK)
   return COMMON_STATUS_EB;

  reg->base         = sdbDevice.sdb_component.addr_first;
  reg->state        = reg->base + SHARED_OFFS + COMMON_SHARED_STATE;

  reg->cmd          = reg->base + SHARED_OFFS + COMMON_SHARED_CMD;
  reg->set_node     = reg->base + SHARED_OFFS + FBAS_SHARED_SET_NODETYPE;
  reg->set_senderid = reg->base + SHARED_OFFS + FBAS_SHARED_SENDERID;

  reg->node         = reg->base + SHARED_OFFS + FBAS_SHARED_GET_NODETYPE;
  reg->sb_slaves    = reg->base + SHARED_OFFS + FBAS_SHARED_GET_SBSLAVES;
  reg->cnt          = reg->base + SHARED_OFFS + FBAS_SHARED_GET_CNT;
  reg->ts1          = reg->base + SHARED_OFFS + FBAS_SHARED_GET_TS1;
  reg->ts2          = reg->base + SHARED_OFFS + FBAS_SHARED_GET_TS2;
  reg->ts3          = reg->base + SHARED_OFFS + FBAS_SHARED_GET_TS3;
  reg->ts4          = reg->base + SHARED_OFFS + FBAS_SHARED_GET_TS4;
  reg->ts5          = reg->base + SHARED_OFFS + FBAS_SHARED_GET_TS5;
  reg->ts6          = reg->base + SHARED_OFFS + FBAS_SHARED_GET_TS6;
  reg->avg          = reg->base + SHARED_OFFS + FBAS_SHARED_GET_AVG;
  reg->min          = reg->base + SHARED_OFFS + FBAS_SHARED_GET_MIN;
  reg->max          = reg->base + SHARED_OFFS + FBAS_SHARED_GET_MAX;
  reg->vld          = reg->base + SHARED_OFFS + FBAS_SHARED_GET_VLD;
  reg->all          = reg->base + SHARED_OFFS + FBAS_SHARED_GET_ALL;
  reg->eca_vld      = reg->base + SHARED_OFFS + FBAS_SHARED_ECA_VLD;
  reg->eca_ovf      = reg->base + SHARED_OFFS + FBAS_SHARED_ECA_OVF;
  reg->tx_dly.avg   = reg->base + SHARED_OFFS + FBAS_SHARED_TX_DLY_AVG;
  reg->sg_lty.avg   = reg->base + SHARED_OFFS + FBAS_SHARED_SG_LTY_AVG;
  reg->msg_dly.avg  = reg->base + SHARED_OFFS + FBAS_SHARED_MSG_DLY_AVG;
  reg->ttl_prd.avg  = reg->base + SHARED_OFFS + FBAS_SHARED_TTL_PRD_AVG;
  reg->eca_hndl.avg = reg->base + SHARED_OFFS + FBAS_SHARED_ECA_HNDL_AVG;
  reg->ml_prd.avg   = reg->base + SHARED_OFFS + FBAS_SHARED_ML_PRD_AVG;
  reg->tx_dly.min   = reg->base + SHARED_OFFS + FBAS_SHARED_TX_DLY_MIN;
  reg->sg_lty.min   = reg->base + SHARED_OFFS + FBAS_SHARED_SG_LTY_MIN;
  reg->msg_dly.min  = reg->base + SHARED_OFFS + FBAS_SHARED_MSG_DLY_MIN;
  reg->ttl_prd.min  = reg->base + SHARED_OFFS + FBAS_SHARED_TTL_PRD_MIN;
  reg->eca_hndl.min = reg->base + SHARED_OFFS + FBAS_SHARED_ECA_HNDL_MIN;
  reg->ml_prd.min   = reg->base + SHARED_OFFS + FBAS_SHARED_ML_PRD_MIN;
  reg->tx_dly.max   = reg->base + SHARED_OFFS + FBAS_SHARED_TX_DLY_MAX;
  reg->sg_lty.max   = reg->base + SHARED_OFFS + FBAS_SHARED_SG_LTY_MAX;
  reg->msg_dly.max  = reg->base + SHARED_OFFS + FBAS_SHARED_MSG_DLY_MAX;
  reg->ttl_prd.max  = reg->base + SHARED_OFFS + FBAS_SHARED_TTL_PRD_MAX;
  reg->eca_hndl.max = reg->base + SHARED_OFFS + FBAS_SHARED_ECA_HNDL_MAX;
  reg->ml_prd.max   = reg->base + SHARED_OFFS + FBAS_SHARED_ML_PRD_MAX;

  return COMMON_STATUS_OK;
}

/**
 * @brief Read data from the shared memory
 *
 * Read data from the shared memory specified by 'from' and
 * store to the 'dst' buffer.
 *
 * @param device Target WB device
 * @param width  Data width (32/64-bit)
 * @param from   WB address to read
 * @param dst    Pointer to destination data buffer
 * @param len    Amount to read
*/
static uint32_t wb_read_shared(const eb_device_t device, const eb_width_t width,
                        eb_address_t from, eb_data_t *dst, const size_t len)
{
  eb_cycle_t   eb_cycle;
  eb_status_t  eb_status;

  if (!device) {
    fprintf(stderr, "Null WB target.\n");
    return COMMON_STATUS_EB;
  }

  if (width > sizeof(eb_data_t)) {
    fprintf(stderr, "local Etherbone library only supports %s-bit operations.\n",
            eb_width_data((sizeof(eb_data_t) << 1) -1));
    return COMMON_STATUS_EB;
  }
  else if (width == EB_DATA64) {
    fprintf(stderr, "direct %s-bit data access is denied\n", eb_width_data(width));
    return COMMON_STATUS_EB;
  }

  if ((eb_status = eb_cycle_open(device, 0, eb_block, &eb_cycle)) != EB_OK) {
    fprintf(stderr, "eb_cycle_open() failed\n");
    return COMMON_STATUS_EB;
  }

  for (int i = 0; i < len; ++i)
    eb_cycle_read(eb_cycle, (from + i*width),
    EB_BIG_ENDIAN | width, (dst + i));

  if ((eb_status = eb_cycle_close(eb_cycle)) != EB_OK) {
    fprintf(stderr, "eb_cycle_close() failed\n");
    return COMMON_STATUS_EB;
  }

  return COMMON_STATUS_OK;
}

/**
 * @brief Read 32-bit data from the shared memory
 *
 * Read 32-bit data from the shared memory specified by 'from' and
 * store to the 'dst' buffer.
 *
 * @param device Target WB device
 * @param from   WB address to read
 * @param dst    Pointer to destination data buffer
 * @param len    Amount to read
*/
static uint32_t wb_read_32(const eb_device_t device, const uint32_t from,
                        uint32_t *dst, const size_t len)
{
  return wb_read_shared(device, EB_DATA32, (eb_address_t)from, (eb_data_t *)dst, len);
}

int main(int argc, char** argv) {
  #define BUILDTYPELEN   256
  #define STALLTOBS    50000
  #define WRTOBS           8
  #define N_STATS          5

  eb_status_t       status;
  eb_socket_t       socket;
  int               devIndex=-1;  // 0,1,2... - there may be more than 1 device on the WB bus
  unsigned int      busIndex=-1;  // index of 1-wire bus connected to a controller

  int               i;            // counter for comparing WR time with other device
  int               nCompare = 5; // number of compares
  uint64_t          nsecsDiff64;
  int               diffIsPositive;

  const char* devName;
  const char* devNameOther=NULL;
  const char* command;

  int         getEBVersion=0;
  int         getWRDate=0;
  int         getWROffset=0;
  int         getWRSync=0;
  int         getWRMac=0;
  int         getWRLink=0;
  int         getWRIP=0;
  int         getWRIPState=0;
  int         getWRStats=0;
  int         getBoardID=0;
  int         getBoardTemp=0;
  int         getWRDateOther=0;
  int         getWRUptime=0;
  int         getBuildType=0;
  int         getCPUStall=0;
  int         getECATap=0;
  int         snoopDelayStats=0;
  int         snoopMode=0;
  int         clearEcaStats=0;
  int         exitCode=0;

  unsigned int family         = 0;    // 1-Wire: familyCode
  unsigned int user1Wire      = 1;    // 1-Wire: 1 - User-1Wire; 0 - WR-Periph-1Wire
  unsigned int ecpu           = 0;    // # of embedded cpu (for 'stall' statistics)
  unsigned int snoopSecs      = 0;    // # of seconds; poll rate for snoop mode
  int          snoopLockFlag  = 0;
  double       snoopStallMax  = 0;
  double       snoopStallAct  = 0;
  uint32_t     nSecs;

  uint64_t    nsecs64, nsecsOther64;
  uint64_t    nsecsSum64, nsecsSumOther64;
  uint64_t    nsecsRound64, nsecsRoundOther64;
  uint64_t    tmpa64, tmpb64;
  uint64_t    usecs64;
  uint64_t    hostusecs64;
  int64_t     offset;
  uint64_t    mac;
  uint64_t    lockLossTS;
  uint64_t    lockAcqTS;
  uint32_t    lockNAcq;
  uint64_t    contObsT;
  int64_t     contMaxPosDT;
  uint64_t    contMaxPosTS;
  int64_t     contMaxNegDT;
  uint64_t    contMaxNegTS;
  uint64_t    stallObsT;
  uint32_t    stallMax;
  uint32_t    stallAct;
  uint64_t    stallTS;
  short       ecaClearFlag;
  uint64_t    ecaNMessage;
  int64_t     ecaDtSum;
  int64_t     ecaDtMin;
  int64_t     ecaDtMax;
  uint32_t    ecaNLate;
  int32_t     ecaLateOffset;
  int         ecaSumEarly;
  int         link;
  uint32_t    uptime;
  int         syncState;
  int         ip;
  int         ipState;
  uint64_t    id;
  double      temp;
  char linkStr[64];
  char ipStateStr[64];
  char syncStr[64];
  char timestr[60];
  char dummy[64];
  uint32_t dummy32;
  char buildType[BUILDTYPELEN];
  time_t secs;
  const struct tm* tm;
  struct timeval htm;

  int opt, error=0;
  char *tail;

  #define N_STATS_ITEMS 5          // statistics items
  #define N_STATS_ENTRIES 3        // entries per item
  uint64_t sumStat[N_STATS_ITEMS * N_STATS_ENTRIES];

  program = argv[0];

  while ((opt = getopt(argc, argv, cmd_options)) != -1) {
    switch (opt) {
      case 'a':
        getBuildType=1;
        break;
      case 'b':
        getBoardID=1;
        busIndex = strtol(optarg, &tail, 0);
        if (*tail != 0) {
          fprintf(stderr, "Specify a proper number, not '%s'!\n", optarg);
          exit(1);
        } // if *tail
        break;
      case 'c':
        getWRDateOther=1;
        devNameOther = optarg;
        break;
      case 'd':
        getWRDate=1;
        break;
      case 'f':
        family = strtol(optarg, &tail, 0);
        if (*tail != 0) {
          fprintf(stderr, "Specify a proper number, not '%s'!\n", optarg);
          exit(1);
        } // if *tail
        break;
      case 'g':
        getWRStats=1;
        break;
      case 'j':
        getCPUStall=1;
        ecpu   = strtol(optarg, &tail, 0);
        if (ecpu > 16) {
          fprintf(stderr, "# of cpu '%d' unreasonable large!\n", ecpu);
          exit(1);
        } // if ecpu
        if (*tail != 0) {
          fprintf(stderr, "Specify a proper number, not '%s'!\n", optarg);
          exit(1);
        } // if *tail
        break;
      case 'k':
        getECATap=1;
        break;
      case 'o':
        getWROffset=1;
        break;
      case 'm':
        getWRMac=1;
        break;
      case 'l':
        getWRLink=1;
        break;
      case 'i':
        getWRIP=1;
        break;
      case 'p':
        getWRIPState=1;
        break;
      case 'y':
        getWRSync=1;
        break;
      case 'z':
        getWRUptime=1;
        break;
      case 'r':
        snoopDelayStats=1;
        break;
      case 's':
        snoopMode=1;
        if (argv[optind-1] != NULL) {                          // need to parse '-s1 0' as well as '-s 1 0'
          sprintf(dummy, "huhu%s", argv[optind-1]);            // add dummy text to be sure we have a non-digit as prefix
          sscanf(dummy,  "%*[^0123456789]%d", &snoopSecs);     // ignore preceeding non-digits
          if (snoopSecs < 1) snoopSecs = 1;
        }
        else                        {fprintf(stderr, "missing '# of seconds'!\n"); exit(1);}
        if (argv[optind+0] != NULL) {ecpu      = strtol(argv[optind+0], &tail, 0); }
        else                        {fprintf(stderr, "missing '# of ecpu'!\n"); exit(1);}
        if ( ecpu > 16) {
          fprintf(stderr, "# of cpu '%d' unreasonable large!\n", ecpu);
          exit(1);
        }
        break;
      case 't':
        getBoardTemp=1;
        busIndex = strtol(optarg, &tail, 0);
        if (*tail != 0) {
          fprintf(stderr, "Specify a proper number, not '%s'!\n", optarg);
          exit(1);
        }
        break;
      case 'e':
        getEBVersion=1;
        break;
      case 'u':
        user1Wire = 1;
        devIndex  = strtol(optarg, &tail, 0);
        if (*tail != 0) {
          fprintf(stderr, "Specify a proper number, not '%s'!\n", optarg);
          exit(1);
        } // if *tail
        break;
      case 'v':
        getWRDate=1;
        getWROffset=1;
        getWRSync=1;
        getWRMac=1;
        getWRLink=1;
        getWRIP=1;
        getWRIPState=1;
        getWRUptime=1;
        getEBVersion=1;
        getBuildType=1;
        verbose=1;
        break;
      case 'w':
        user1Wire = 0;
        devIndex  = strtol(optarg, &tail, 0);
        if (*tail != 0) {
          fprintf(stderr, "Specify a proper number, not '%s'!\n", optarg);
          exit(1);
        } // if *tail
        break;
      case 'h':
        help();
        return 0;
      case ':':
      case '?':
        error = 1;
        break;
      default:
        fprintf(stderr, "%s: bad getopt result\n", program);
        return 1;
    } // switch opt
  } // while opt

  if (error) {
    help();
    return 1;
  }

  if (optind >= argc) {
    fprintf(stderr, "%s: expecting one non-optional argument: <etherbone-device>\n", program);
    fprintf(stderr, "\n");
    help();
    return 1;
  }

  devName = argv[optind];
  if (devIndex < 0) devIndex = 0; // default: grab first device of the requested type on the wishbone bus

  if (optind+1 < argc)  command = argv[++optind];
  else command = NULL;

  if (getEBVersion) {
    if (verbose) fprintf(stdout, "EB source / EB version: ");
    fprintf(stdout, "%s / %s\n", eb_source_version(), eb_build_info());
  }

  // open Etherbone device and socket (if protocol is UDP, then waits for 200ms)
  if ((status = wb_open(devName, &device, &socket)) != EB_OK) {
    fprintf(stderr, "can't open connection to device %s (%s) \n", devName, eb_status(status));
    return (1);
  }

  if (snoopMode) { /* chk: mit der heissen Nadel gestrickt */
    // init
    wb_eca_stats_reset(device, devIndex, 0);
    wb_eca_stats_enable(device, devIndex, 0x1);
    wb_wr_stats_reset(device, devIndex, WRTOBS, STALLTOBS);

    fprintf(stdout, "local Etherbone library supports %s-bit operations.\n",
            eb_width_data((sizeof(eb_data_t) << 1) -1));

    nSecs           = snoopSecs;
    ecaSumEarly     = 0;

    if (snoopDelayStats) {
      // init shared registers
      if (wb_init_shared_regs(device, &fbas_reg) == COMMON_STATUS_OK)
        printSharedRegs(&fbas_reg);
      printDelayMeasureHeader();
    }
    else
      printStatsHeader();

    while(1) {
      // get data
      // wr lock
      wb_wr_get_sync_state(device, devIndex, &syncState);
      if (syncState == WR_PPS_GEN_ESCR_MASK) snoopLockFlag = 1;
      else                                   snoopLockFlag = 0;
      if (!snoopLockFlag) {
        fprintf(stdout,                         "\t error - WR not locked (resetting DM-Diagnostics)\n");
        wb_wr_stats_reset(device, devIndex, WRTOBS, STALLTOBS);
      } // if !snoopLockFlag

      // time continuity
      wb_wr_stats_get_continuity(device, devIndex, &contObsT, &contMaxPosDT, &contMaxPosTS, &contMaxNegDT, &contMaxNegTS);
      if (contMaxPosDT > 16)    fprintf(stdout, "\t error - WR time (posDT) jumps by %d [ns]\n", (int)contMaxPosDT);
      if (contMaxNegDT != 0)    fprintf(stdout, "\t error - WR time (negDT) jumps by %d [ns]\n", (int)contMaxNegDT);

      // CPU stalls
      wb_wr_stats_get_stall(device, devIndex, ecpu, &stallObsT, &stallMax, &stallAct, &stallTS);
      snoopStallMax = (double)stallMax / (double)stallObsT * 100.0;
      snoopStallAct = (double)stallAct / (double)stallObsT * 100.0;
      if (snoopStallMax > 50.0) fprintf(stdout, "\t error - max CPU stall %f\n", snoopStallMax);

      // ECA
      wb_eca_stats_get(device, devIndex, &ecaNMessage, &ecaDtSum, &ecaDtMin, &ecaDtMax, &ecaNLate, &ecaLateOffset);
      if (ecaDtMin < ecaLateOffset) {
        if (!snoopDelayStats)
          fprintf(stdout,                         "\t error: late event %f (min) %f (lateOffset) [us]\n",
                  (double)ecaDtMin/1000.0, (double)ecaLateOffset/1000.0);
        if (clearEcaStats)
          wb_eca_stats_clear(device, devIndex, 0x1);
      }
      if (ecaDtMax > 1000000000) {  /* chk */
        ecaSumEarly++;              /* chk */
        fprintf(stdout,                         "\t error - early event %f [us]\n", (double)ecaDtMax/1000.0);
        wb_eca_stats_clear(device, devIndex, 0x2);
      }

      if (nSecs >= snoopSecs) {
        if (snoopDelayStats) {

          // read average transmission delay, 32-bit data access
          if (wb_read_32(device, fbas_reg.tx_dly.avg, (uint32_t *)sumStat, 2) == COMMON_STATUS_OK)
            msr.tx_dly.avg = (sumStat[1] + (sumStat[0] << 32))/1000;    // ns->us
          if (wb_read_32(device, fbas_reg.tx_dly.max, (uint32_t *)sumStat, 2) == COMMON_STATUS_OK)
            msr.tx_dly.max = (sumStat[1] + (sumStat[0] << 32))/1000;    // ns->us

          // read average signalling latency
          if (wb_read_32(device, fbas_reg.sg_lty.avg, (uint32_t *)sumStat, 2) == COMMON_STATUS_OK)
            msr.sg_lty.avg = (sumStat[1] + (sumStat[0] << 32))/1000;    // ns->us
          if (wb_read_32(device, fbas_reg.sg_lty.max, (uint32_t *)sumStat, 2) == COMMON_STATUS_OK)
            msr.sg_lty.max = (sumStat[1] + (sumStat[0] << 32))/1000;    // ns->us

          // read average messaging delay
          if (wb_read_32(device, fbas_reg.msg_dly.avg, (uint32_t *)sumStat, 2) == COMMON_STATUS_OK)
            msr.msg_dly.avg = (sumStat[1] + (sumStat[0] << 32))/1000;    // ns->us
          if (wb_read_32(device, fbas_reg.msg_dly.max, (uint32_t *)sumStat, 2) == COMMON_STATUS_OK)
            msr.msg_dly.max = (sumStat[1] + (sumStat[0] << 32))/1000;    // ns->us

          // read average period of the main loop
          if (wb_read_32(device, fbas_reg.ml_prd.avg, (uint32_t *)sumStat, 2) == COMMON_STATUS_OK)
            msr.ml_prd.avg = (sumStat[1] + (sumStat[0] << 32))/1000;    // ns->us
          if (wb_read_32(device, fbas_reg.ml_prd.max, (uint32_t *)sumStat, 2) == COMMON_STATUS_OK)
            msr.ml_prd.max = (sumStat[1] + (sumStat[0] << 32))/1000;    // ns->us

          printDelayMeasureData(snoopSecs, snoopLockFlag, ecaNMessage, ecaDtMax, ecaDtSum, ecaNLate, &msr);
        }
        else
          printStatsData(snoopSecs, snoopLockFlag, contMaxPosDT, contMaxNegDT, snoopStallMax, snoopStallAct,
                       ecaNMessage, ecaDtMin, ecaDtMax, ecaDtSum, ecaNLate, ecaSumEarly);
        nSecs = 1;
      } // if nSecs
      else
        nSecs++;

      usleep(1000000);  // iterate once per second
    } // while
  } // if snoopMode

  if (getWRDateOther) {
    if ((status = wb_open(devNameOther, &deviceOther, &socket)) != EB_OK) {
      fprintf(stderr, "can't open connection to device %s \n", devNameOther);
      return (1);
    }

    // do one round, to be sure WR network "knows" route to other device
    if ((status = wb_wr_get_time(deviceOther, 0,        &nsecsOther64)) != EB_OK) die("WR get time other", status);
    if ((status = wb_wr_get_time(device,      devIndex, &nsecs64))      != EB_OK) die("WR get time", status);

    // now start
    nsecsSum64      = 0;
    nsecsSumOther64 = 0;

    for (i=0; i < nCompare; i++) {
      if ((status = wb_wr_get_time(device,      devIndex, &tmpa64)) != EB_OK) die("WR get time", status);
      if ((status = wb_wr_get_time(deviceOther, 0,        &tmpb64)) != EB_OK) die("WR get time other", status);

      nsecsSum64      += tmpa64;
      nsecsSumOther64 += tmpb64;
    }

    nsecs64       = (uint64_t)((double)(nsecsSum64)      / (double)nCompare);
    nsecsOther64  = (uint64_t)((double)(nsecsSumOther64) / (double)nCompare);

    // determine the roundtrip time for device
    wb_wr_get_time(device, 0, &tmpa64);
    for (i=0; i < nCompare; i++) wb_wr_get_time(device, 0, &tmpb64);
    nsecsRound64 = tmpb64 - tmpa64;
    nsecsRound64 = (uint64_t)((double)nsecsRound64/(double)nCompare);

    // determine the roundtrip time for other device
    wb_wr_get_time(deviceOther, 0, &tmpa64);
    for (i=0; i < nCompare; i++) wb_wr_get_time(deviceOther, 0, &tmpb64);
    nsecsRoundOther64 = tmpb64 - tmpa64;
    nsecsRoundOther64 = (uint64_t)((double)nsecsRoundOther64/(double)nCompare);

    // nsecsOther64 has been measured after the nsecs64 has been completed. So we need to subtract that roundtrip time of the first device
    nsecsOther64 = nsecsOther64 - nsecsRound64;

    // the timestamps nsecs64 and nsecsOther64 are measured after the etherbone packet arrived at the FPGA
    // we use the simplified model, that the the transmission times to and from the remote FPGA are identical (symmetry) and that the roundtrip is only due to total transmission time
    // hece, the timestamp is latched after half of the roundtrip time, so we need to subtract that from both values

    nsecsOther64 = nsecsOther64 - (nsecsRoundOther64 >> 1);
    nsecs64      = nsecs64      - (nsecsRound64      >> 1);

    if (nsecs64 > nsecsOther64) {
      nsecsDiff64    = nsecs64 - nsecsOther64;
      diffIsPositive = 1;
    }
    else {
      nsecsDiff64    = nsecsOther64 - nsecs64;
      diffIsPositive = 0;
    }

      fprintf(stdout, "WR differs by ");
      if (diffIsPositive) fprintf(stdout, "+");
      else                fprintf(stdout, "-");
      fprintf(stdout, "%"PRIu64" us\n", nsecsDiff64 / 1000);
  }

  if (getWRDate || getWROffset) {
    if ((status = wb_wr_get_time(device, devIndex, &nsecs64)) != EB_OK) die("WR get time", status);
    secs     = (unsigned long)((double)nsecs64 / 1000000000.0);
    usecs64  = nsecs64 / 1000.0;

    if (getWROffset) {
      // get system time
      gettimeofday(&htm, NULL);
      hostusecs64 = htm.tv_sec*1000000 + htm.tv_usec;
      offset      = usecs64 - hostusecs64;
      if (verbose) fprintf(stdout, "WR_time - host_time [ms]: ");
      fprintf(stdout, "%9.3f\n", (double)offset/1000.0);
    }

    if (getWRDate) {
      // Format the date
      tm = gmtime(&secs);
      strftime(timestr, sizeof(timestr), "%Y-%m-%d %H:%M:%S %Z", tm);

      if (verbose) fprintf(stdout, "Current TAI: ");
      fprintf(stdout, "%s (%lu us)", timestr, usecs64 - secs * 1000000);
      fprintf(stdout, ", %"PRIu64" us\n", nsecs64 / 1000);
    }
  } // if getWRDate

  if (getWRSync) {
    if ((status = wb_wr_get_sync_state(device, devIndex, &syncState)) != EB_OK) die("WR get sync state", status);
    if ((syncState == WR_PPS_GEN_ESCR_MASK))
      sprintf(syncStr,"TRACKING");
    else if ((syncState == WR_PPS_GEN_ESCR_MASKTS))
      sprintf(syncStr,"TIME");
    else if ((syncState == WR_PPS_GEN_ESCR_MASKPPS))
      sprintf(syncStr, "PPS");
    else
      sprintf(syncStr, "NO SYNC");
    if (verbose) fprintf(stdout, "Sync Status: ");
    fprintf(stdout, "%s\n", syncStr);
  } // getWRSync

  if (getWRMac) {
    if ((status = wb_wr_get_mac(device, devIndex, &mac)) != EB_OK) die("WR get MAC", status);
    if (verbose) fprintf(stdout, "MAC: ");
    fprintf(stdout, "%012llx\n", (long long unsigned)mac);
  }

  if (getWRLink) {
    if ((status = wb_wr_get_link(device, devIndex, &link)) != EB_OK) die("WR get link state", status);
    if (link)
      sprintf(linkStr, "LINK_UP");
    else
      sprintf(linkStr, "LINK_DOWN");
    if (verbose) fprintf(stdout, "Link Status: ");
    fprintf(stdout, "%s\n", linkStr);
  }

  if (getWRIP) {
    if ((status = wb_wr_get_ip(device, devIndex, &ip)) != EB_OK) die("WR get IP", status);
    if (verbose) fprintf(stdout, "IP: ");
    fprintf(stdout, "%03d.%03d.%03d.%03d\n", (ip & 0xFF000000) >> 24, (ip & 0x00FF0000) >> 16, (ip & 0x0000FF00) >> 8, ip & 0x000000FF);
  }

  if(getWRIPState) {
     if ((status = wb_get_build_type(device, BUILDTYPELEN, buildType, &dummy32)) != EB_OK) die("WB get build type (for IP state)", status);
     if ((status = wb_wr_get_ip_state(device, devIndex, dummy32, &ipState)) != EB_OK) die("WB get IP state", status);
     switch (ipState) {
       case -1 :
         sprintf(ipStateStr, "unknown");
         break;
       case 0 :
         sprintf(ipStateStr, "invalid");
         break;
       case 1 :
         sprintf(ipStateStr, "valid (BOOTP)");
         break;;
       case 2:
         sprintf(ipStateStr, "valid (static)");
         break;
       default :
         sprintf(ipStateStr, "error");
         break;
     } // switch ipState
     if (verbose)  fprintf(stdout, "IP state: ");
     fprintf(stdout, "%s\n", ipStateStr);
  }

  if (getWRUptime) {
    if ((status = wb_wr_get_uptime(device, devIndex, &uptime)) != EB_OK) die("WR get uptime", status);
    if (verbose) fprintf(stdout, "FPGA uptime [h]: ");
    fprintf(stdout, "%013.2f\n", (double)uptime / 3600.0 );
  }

  if (getBuildType) {
    if ((status = wb_get_build_type(device, BUILDTYPELEN, buildType, &dummy32)) != EB_OK) die("WB get build type", status);
    if (verbose) fprintf(stdout, "FPGA build type: ");
    fprintf(stdout, "%s\n", buildType);
  }

  if (getBoardID) {
    if (!family) die("family code not specified (1-wire)", EB_OOM);
    if ((status = wb_1wire_get_id(device, devIndex, busIndex, family, user1Wire, &id)) != EB_OK) die("WR get board ID", status);
    if (verbose) fprintf(stdout, "ID: ");
    fprintf(stdout, "0x%016"PRIx64"\n", id);
  }

  if (getBoardTemp) {
    if (!family) die("family code not specified (1-wire)", EB_OOM);
    if ((status = wb_1wire_get_temp(device, devIndex, busIndex, family, user1Wire, &temp)) != EB_OK) die("WR get board temperature", status);
    if (verbose) fprintf(stdout, "temp: ");
    fprintf(stdout, "%.4f\n", (float)temp);
  }

  if (getWRStats || getCPUStall || getECATap) {
    fprintf(stdout, "\n");
    fprintf(stdout, "=============\n");
    fprintf(stdout, "Statistics\n");
    fprintf(stdout, "=============\n");
  } // if getWRStats || ...

  if (getWRStats) {
    fprintf(stdout, "= White Rabbit\n");

    // WR stats: lock
    fprintf(stdout, "-- locks...\n");
    if ((status = wb_wr_stats_get_lock(device, devIndex, &lockLossTS, &lockAcqTS, &lockNAcq)) != EB_OK) die("WR get lock statistics", status);
    fprintf(stdout, "---# of acquired locks: %d\n", lockNAcq);

    if (lockLossTS == 0xffffffffffffffff)
      fprintf(stdout, "---WR lock lost       : N/A\n");
    else {
      secs = (unsigned long)((double)lockLossTS / 1000000000.0);
      tm = gmtime(&secs);
      strftime(timestr, sizeof(timestr), "%Y-%m-%d %H:%M:%S %Z", tm);
      fprintf(stdout, "---WR lock lost       : %s\n", timestr);
    }

    if (lockAcqTS == 0xffffffffffffffff)
      fprintf(stdout, "---WR lock acquired   : N/A\n");
    else {
      secs = (unsigned long)((double)lockAcqTS / 1000000000.0);
      tm = gmtime(&secs);
      strftime(timestr, sizeof(timestr), "%Y-%m-%d %H:%M:%S %Z", tm);
      fprintf(stdout, "---WR lock aquired    : %s\n", timestr);
    }

    // WR stats: time continuity
    fprintf(stdout, "-- time continuity [ns]\n");
    if ((status = wb_wr_stats_get_continuity(device, devIndex, &contObsT, &contMaxPosDT, &contMaxPosTS, &contMaxNegDT, &contMaxNegTS)) != EB_OK) die("WR get lock statistics", status);
    fprintf(stdout, "--- observation period: %"PRIu64"\n", contObsT);
    fprintf(stdout, "---- max pos diff     : %"PRId64"\n", contMaxPosDT);
    secs = (unsigned long)((double)contMaxPosTS / 1000000000.0);
    tm = gmtime(&secs);
    strftime(timestr, sizeof(timestr), "%Y-%m-%d %H:%M:%S %Z", tm);
    fprintf(stdout, "---- TS of pos  diff  : %s\n", timestr);
    fprintf(stdout, "---- max neg diff     : %"PRId64"\n", contMaxNegDT);
    secs = (unsigned long)((double)contMaxNegTS / 1000000000.0);
    tm = gmtime(&secs);
    strftime(timestr, sizeof(timestr), "%Y-%m-%d %H:%M:%S %Z", tm);
    fprintf(stdout, "---- TS of neg diff   : %s\n", timestr);
  } // if getWRStats

  if (getCPUStall) {
    fprintf(stdout, "= lm32 stalls for CPU %d [cycles]\n", ecpu);
    if ((status = wb_wr_stats_get_stall(device, devIndex, ecpu, &stallObsT, &stallMax, &stallAct, &stallTS)) != EB_OK) die("WR get CPU stall statistics", status);
    fprintf(stdout, "--- observation period: %"PRIu64"\n", stallObsT);
    fprintf(stdout, "---- stall time max   : %u\n", stallMax);
    fprintf(stdout, "---- stall time act   : %u\n", stallAct);
    secs = (unsigned long)((double)stallTS / 1000000000.0);
    tm = gmtime(&secs);
    strftime(timestr, sizeof(timestr), "%Y-%m-%d %H:%M:%S %Z", tm);
    fprintf(stdout, "---- TS of 'time max' : %s\n", timestr); 
  } // if getCPUStall

  if (getECATap) {
    fprintf(stdout, "= ECA-Tap (input) [ns]\n");
    if ((status = wb_eca_stats_get(device, devIndex, &ecaNMessage, &ecaDtSum, &ecaDtMin, &ecaDtMax, &ecaNLate, &ecaLateOffset)) != EB_OK) fprintf(stdout, "warning: can't ECA-Tap statistics (can't find in gateware)\n");
    fprintf(stdout, "--- # of messages     : %"PRIu64"\n", ecaNMessage);
    fprintf(stdout, "--- ave (dl - ts)     : %d\n", (int32_t)((double)ecaDtSum/(double)ecaNMessage));
    fprintf(stdout, "--- min (dl - ts)     : %"PRId64"\n", ecaDtMin);
    fprintf(stdout, "--- max (dl - ts)     : %"PRId64"\n", ecaDtMax);
    fprintf(stdout, "--- calc latency      : %d\n", AHEADT - (int32_t)((double)ecaDtSum/(double)ecaNMessage));
    fprintf(stdout, "--- late offset       : %d\n", ecaLateOffset);
    fprintf(stdout, "--- # of late messages: %u\n", ecaNLate);
  } // getECATap

  if (command) {

    if (!strcasecmp(command, "wrstatreset")) {
      if (optind+3  != argc) {printf("expecting exactly two arguments: wrstatclear  <tWrObs> <tStallObs>\n"); return 1;}
      contObsT = strtoul(argv[optind+1], &tail, 0);
      stallObsT = strtoul(argv[optind+2], &tail, 0);
      wb_wr_stats_reset(device, devIndex, contObsT, stallObsT);
      fprintf(stdout, "fbas-mon: %s\n", command);
    } // wrstatreset

    if (!strcasecmp(command, "ecatapreset")) {
      if (optind+2  != argc) {printf("expecting exactly one argument: ecatapreset <lateOffset>\n"); return 1;}
      ecaLateOffset = strtol(argv[optind+1], &tail, 0);
      wb_eca_stats_reset(device, devIndex, ecaLateOffset);
      fprintf(stdout, "fbas-mon: %s\n", command);
    } // ecatapreset

    if (!strcasecmp(command, "ecatapclear")) {
      if (optind+2  != argc) {printf("expecting exactly one argument: ecatapclear <clearFlag>\n"); return 1;}
      ecaClearFlag = strtoul(argv[optind+1], &tail, 0);
      wb_eca_stats_clear(device, devIndex, ecaClearFlag);
      fprintf(stdout, "fbas-mon: %s\n", command);
    } // ecatapclear

    if (!strcasecmp(command, "ecatapenable")) {
      wb_eca_stats_enable(device, devIndex, 0x1);
      fprintf(stdout, "fbas-mon: %s\n", command);
    } // ecatapenable

    if (!strcasecmp(command, "ecatapdisable")) {
      wb_eca_stats_enable(device, devIndex, 0x0);
      fprintf(stdout, "fbas-mon: %s\n", command);
    } // ecatapdisable

  } // if command

  wb_close(device, socket);
  wb_close(deviceOther, socket);

  return exitCode;
}
