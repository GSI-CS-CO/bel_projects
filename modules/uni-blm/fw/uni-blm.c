/********************************************************************************************
 *  uni-blm.c
 *
 *  created : 2025
 *  author  : Dietrich Beck, Matthias Loy GSI-Darmstadt
 *  version : 21-Jul-2025
 *
 *  firmware required for UNILAC blm
 *  
 *  This firmware is an example program
 *  
 * -------------------------------------------------------------------------------------------
 * License Agreement for this software:
 *
 * Copyright (C) 2018  Dietrich Beck
 * GSI Helmholtzzentrum fuer Schwerionenforschung GmbH
 * Planckstrasse 1
 * D-64291 Darmstadt
 * Germany
 *
 * Contact: d.beck@gsi.de
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either

 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *  
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library. If not, see <http://www.gnu.org/licenses/>.
 *
 * For all questions and ideas contact: d.beck@gsi.de
 * Last update: 15-April-2019
 ********************************************************************************************/
#define UNIBLM_FW_VERSION      0x000002  // make this consistent with makefile

// standard includes
#include <string.h>
#include <inttypes.h>
#include <stdint.h>

// includes specific for bel_projects
#include "dbg.h"                                                        // debug outputs
#include <stack.h>                                                      // stack check
#include "pp-printf.h"                                                  // print
#include "mini_sdb.h"                                                   // sdb stuff
#include "aux.h"                                                        // cpu and IRQ
#include "uart.h"                                                       // WR console

// includes for this project 
#include <common-defs.h>                                                // common defs for firmware
#include <common-fwlib.h>                                               // common routines for firmware
#include <uni-blm.h>                                                    // specific defs for uni-blm
#include <uniblm_shared_mmap.h>                                         // autogenerated upon building firmware

/* For UNILAC BLM crate */
static const unsigned int diobSlotNumber = 2;

#define BUS_SLAVE_OFFSET(SLOT_NUMBER) ((SLOT_NUMBER) * (1 << 16))
static const uint32_t BUS_SLAVE_ECHO_REGISTER = 0x10;
/// For manually loading thrashold data set
/// bit 0..7: Data set to be loaded
/// bit 8..11: Counter group to be loaded to
/// bit 12: Commit the operation
static const uint32_t EVENT_THRESHOLD_RELOAD_REGISTER = 0xa02;

volatile uint16_t* pScuBaseAddress = NULL;


// stuff required for environment
extern uint32_t* _startshared[];
unsigned int     cpuId, cpuQty;
#define  SHARED  __attribute__((section(".shared")))
uint64_t SHARED  dummy = 0;

// global variables 
volatile uint32_t *pShared;                // pointer to begin of shared memory region
volatile uint32_t *pSharedSetEventKey;     // pointer to a "user defined" u32 register; here: set event key
volatile uint32_t *pSharedGetReloadCounters[UNIBLM_NUMBER_OF_COUNTER_GROUPS]; // pointers to "user defined" u32 registers; here: get counter of reload events for counter groups.

uint32_t *cpuRamExternal;                  // external address (seen from host bridge) of this CPU's RAM

uint64_t statusArray;                      // all status infos are ORed bit-wise into statusArray, statusArray is then published
uint32_t nEvtsLate;                        // # of late timing messages
uint32_t offsDone;                         // offset deadline WR message to time when we are done [ns]
int32_t  comLatency;                       // latency for messages received via ECA
 
int32_t  maxComLatency;                    // max of com latency
uint32_t maxOffsDone;                      // max of offset done

uint32_t eventKey;                         // used by the BLM diob gateware to filter incoming ECA events (Not used yet)
uint32_t reloadCounters[UNIBLM_NUMBER_OF_COUNTER_GROUPS];


void init() // typical init for lm32
{
  discoverPeriphery();        // mini-sdb ...
  uart_init_hw();             // needed by WR console   
  cpuId = getCpuIdx();
} // init


// determine address and clear shared mem
void initSharedMem(uint32_t *reqState, uint32_t *sharedSize)
{
  uint32_t idx;
  uint32_t *pSharedTemp;
  const uint32_t c_Max_Rams = 10;
  sdb_location   found_sdb[c_Max_Rams];
  sdb_location   found_clu;
  
  // get pointer to shared memory
  pShared                    = (uint32_t *)_startshared;

  // get address to data
  pSharedSetEventKey         = (uint32_t *)(pShared + (UNIBLM_SHARED_SET_EVENT_KEY         >> 2));
  for(unsigned int counterIndex=0; counterIndex<UNIBLM_NUMBER_OF_COUNTER_GROUPS; ++counterIndex) {
    pSharedGetReloadCounters[counterIndex] = (uint32_t *)(pShared + ((UNIBLM_SHARED_GET_RELOAD_COUNTER_0+(_32b_SIZE_*counterIndex)) >> 2));
  }

  // find address of CPU from external perspective
  idx = 0;
  find_device_multi(&found_clu, &idx, 1, GSI, LM32_CB_CLUSTER);
  if (idx == 0) {
    *reqState = COMMON_STATE_FATAL;
    DBPRINT1("uni-blm: fatal error - did not find LM32-CB-CLUSTER!\n");
  } // if idx
  idx = 0;
  find_device_multi_in_subtree(&found_clu, &found_sdb[0], &idx, c_Max_Rams, GSI, LM32_RAM_USER);
  if (idx == 0) {
    *reqState = COMMON_STATE_FATAL;
    DBPRINT1("uni-blm: fatal error - did not find THIS CPU!\n");
  } // if idx
  else cpuRamExternal = (uint32_t *)(getSdbAdr(&found_sdb[cpuId]) & 0x7FFFFFFF); // CPU sees the 'world' under 0x8..., remove that bit to get host bridge perspective

  DBPRINT2("uni-blm: CPU RAM external 0x%8x, shared offset 0x%08x\n", cpuRamExternal, SHARED_OFFS);
  DBPRINT2("uni-blm: fw common shared begin   0x%08x\n", pShared);
  DBPRINT2("uni-blm: fw common shared end     0x%08x\n", pShared + (COMMON_SHARED_END >> 2));

  // clear shared mem
  pSharedTemp        = (uint32_t *)(pShared + (COMMON_SHARED_END >> 2 ) + 1);
  DBPRINT2("uni-blm: fw specific shared begin 0x%08x\n", pSharedTemp);
  while (pSharedTemp < (uint32_t *)(pShared + (UNIBLM_SHARED_END >> 2 ))) {
    *pSharedTemp = 0x0;
    pSharedTemp++;
  } // while pSharedTemp
  DBPRINT2("uni-blm: fw specific shared end   0x%08x\n", pSharedTemp);

  *sharedSize        = (uint32_t)(pSharedTemp - pShared) << 2;

  // basic info to wr console
  DBPRINT1("\n");
  DBPRINT1("uni-blm: initSharedMem, shared size [bytes]: %d\n", *sharedSize);
  DBPRINT1("\n");
} // initSharedMem


// clear project specific diagnostics
void extern_clearDiag()
{
  statusArray   = 0x0;  
  nEvtsLate     = 0x0;
  offsDone      = 0x0;
  comLatency    = 0x0;
  maxComLatency = 0x0;
  maxOffsDone   = 0x0;
  memset(reloadCounters, 0, sizeof(reloadCounters));
} // extern_clearDiag 


// entry action 'configured' state
uint32_t extern_entryActionConfigured()
{
  eventKey     =  *pSharedSetEventKey;

  // get and publish NIC data
  fwlib_publishNICData(); 


  return COMMON_STATUS_OK;
} // extern_entryActionConfigured


// entry action 'operation' state
uint32_t extern_entryActionOperation()
{
  unsigned int      i;
  uint64_t tDummy;
  uint64_t eDummy;
  uint64_t pDummy;
  uint32_t fDummy;
  uint32_t flagDummy1, flagDummy2, flagDummy3, flagDummy4;
  int      enable_fifo;

  // clear diagnostics
  fwlib_clearDiag();

  // flush ECA queue for lm32
  i = 0;
  while (fwlib_wait4ECAEvent(1000, &tDummy, &eDummy, &pDummy, &fDummy, &flagDummy1, &flagDummy2, &flagDummy3, &flagDummy4) !=  COMMON_ECADO_TIMEOUT) {
    i++;
  }
  DBPRINT1("uni-blm: ECA queue flushed - removed %u pending entries from ECA queue\n", i);
    
  // init get values
  for(unsigned int counterIndex=0; counterIndex<UNIBLM_NUMBER_OF_COUNTER_GROUPS; ++counterIndex) {
    *pSharedGetReloadCounters[counterIndex] = 0;
  }

  nEvtsLate                 = 0;
  offsDone                  = 0;
  comLatency                = 0;
  maxComLatency             = 0;
  maxOffsDone               = 0;
  memset(reloadCounters, 0, sizeof(reloadCounters));

  return COMMON_STATUS_OK;
} // extern_entryActionOperation


uint32_t extern_exitActionOperation()
{ 
  return COMMON_STATUS_OK;
} // extern_exitActionOperation


// do action of state operation: This is THE central code of this firmware
uint32_t doActionOperation(uint64_t *tAct,                    // actual time
                           uint32_t actStatus)                // actual status of firmware
{
  uint32_t status;                                            // status returned by routines
  uint32_t flagIsLate;                                        // flag indicating that we received a 'late' event from ECA
  uint32_t receivedTag;                                       // action triggered by event received from ECA
  uint64_t recEvtId;                                          // evt ID received
  uint32_t flagIsDelayed;                                     // flag 'delayed'
  uint32_t flagIsEarly;                                       // flag 'early'
  uint32_t flagIsConflict;                                    // flag 'conflict'
  uint64_t recDeadline;                                       // deadline received from ECA
  uint64_t recParam;                                          // param received
  uint32_t recTEF;                                            // TEF received
  uint32_t recSid;                                            // SID received

  uint64_t sysTime;
  
  status = actStatus;

  receivedTag = fwlib_wait4ECAEvent(COMMON_ECATIMEOUT * 1000, &recDeadline, &recEvtId, &recParam, &recTEF, &flagIsLate, &flagIsEarly, &flagIsConflict, &flagIsDelayed);

  switch (receivedTag) {
    case COMMON_ECADO_TIMEOUT:
      /* nothing to do... */
      flagIsLate = 0;
      break;
    default:
      {
        recSid = (uint32_t)((recEvtId >> 20) & 0x00000fff);

        unsigned int counterGroup = receivedTag & 0xf; // counter group at bit pos 8. It is taken from the received tag
        uint16_t registerValue = recSid & 0xff; // Sequence Id equals Dataset at bit pos 0
        registerValue |= counterGroup << 8;
        registerValue |= 0x1000; // trigger

        pScuBaseAddress[BUS_SLAVE_OFFSET(diobSlotNumber)+EVENT_THRESHOLD_RELOAD_REGISTER] = registerValue;
        pScuBaseAddress[BUS_SLAVE_OFFSET(diobSlotNumber)+EVENT_THRESHOLD_RELOAD_REGISTER] = 0;

        reloadCounters[counterGroup]++;
        offsDone = getSysTime() - recDeadline;
      }
      break;
  }

  // check for late event
  if ((status == COMMON_STATUS_OK) && flagIsLate) {
    nEvtsLate++;
  } // if flagIslate

  // check WR sync state
  if (fwlib_wrCheckSyncState() == COMMON_STATUS_WRBADSYNC) {
    status = COMMON_STATUS_WRBADSYNC;
  }
  return status;
} // doActionOperation


int main(void) {
  uint64_t tActMessage;                         // time of actual message
  uint32_t status;                              // (error) status
  uint32_t actState;                            // actual FSM state
  uint32_t pubState;                            // value of published state
  uint32_t reqState;                            // requested FSM state
  uint32_t dummy1;                              // dummy parameter
  uint32_t sharedSize;                          // size of shared memory
  uint32_t *buildID;                            // build ID of lm32 firmware

  // init local variables
  buildID        = (uint32_t *)(INT_BASE_ADR + BUILDID_OFFS);                 // required for 'stack check'  

  reqState       = COMMON_STATE_S0;
  actState       = COMMON_STATE_UNKNOWN;
  pubState       = COMMON_STATE_UNKNOWN;
  status         = COMMON_STATUS_OK;

  eventKey = 0;
  memset(reloadCounters, 0, UNIBLM_NUMBER_OF_COUNTER_GROUPS*sizeof(reloadCounters[0]));
  nEvtsLate      = 0;

  init();                                                                     // initialize stuff for lm32
  initSharedMem(&reqState, &sharedSize);                                      // initialize shared memory
  fwlib_init((uint32_t *)_startshared, cpuRamExternal, SHARED_OFFS, sharedSize, "uni-blm", UNIBLM_FW_VERSION); // init common stuff
  fwlib_clearDiag();
  pScuBaseAddress = (uint16_t*)find_device_adr(GSI, SCU_BUS_MASTER);
  if (pScuBaseAddress == (uint16_t*)ERROR_NOT_FOUND) {
    pp_printf("no scu bus master base address found!\n");
  }
  // clear common diagnostics data
 
  while (1) {
    check_stack_fwid(buildID);                                                // check stack status
    fwlib_cmdHandler(&reqState, &dummy1);                                     // check for commands and possibly request state changes
    status = COMMON_STATUS_OK;                                                // reset status for each iteration

    // state machine
    status = fwlib_changeState(&actState, &reqState, status);                 // handle requested state changes
    switch(actState) {                                                        // state specific do actions
      case COMMON_STATE_OPREADY :
        status = doActionOperation(&tActMessage, status);
        if (status == COMMON_STATUS_WRBADSYNC)      reqState = COMMON_STATE_ERROR;
        if (status == COMMON_STATUS_ERROR)          reqState = COMMON_STATE_ERROR;
        break;
      default :                                                               // avoid flooding WB bus with unnecessary activity
        status = fwlib_doActionState(&reqState, actState, status);            // other 'do actions' are handled here
        break;
    } // switch
    
    switch (status) {
      case COMMON_STATUS_OK :                                                 // status OK
        statusArray = statusArray |  (0x1 << COMMON_STATUS_OK);               // set OK bit
        break;
      default :                                                               // status not OK
        if ((statusArray >> COMMON_STATUS_OK) & 0x1) fwlib_incBadStatusCnt(); // changing status from OK to 'not OK': increase 'bad status count'
        statusArray = statusArray & ~((uint64_t)0x1 << COMMON_STATUS_OK);     // clear OK bit
        statusArray = statusArray |  ((uint64_t)0x1 << status);               // set status bit and remember other bits set
        break;
    } // switch status
    
    if ((pubState == COMMON_STATE_OPREADY) && (actState  != COMMON_STATE_OPREADY)) fwlib_incBadStateCnt();
    fwlib_publishStatusArray(statusArray);
    pubState = actState;
    fwlib_publishState(pubState);

    if (comLatency > maxComLatency) maxComLatency = comLatency;
    if (offsDone   > maxOffsDone)   maxOffsDone   = offsDone;
    fwlib_publishTransferStatus(0, 0, 0, nEvtsLate, maxOffsDone, maxComLatency);

    for(unsigned int counterIndex=0; counterIndex<UNIBLM_NUMBER_OF_COUNTER_GROUPS; ++counterIndex) {
      *pSharedGetReloadCounters[counterIndex] = reloadCounters[counterIndex];
    }

  } // while

  return(1); // this should never happen ...
} // main
