/********************************************************************************************
 *  dm-unipz.c
 *
 *  created : 2017
 *  author  : Dietrich Beck, GSI-Darmstadt
 *  version : 19-Jul-2024
 *
 *  lm32 program for gateway between UNILAC Pulszentrale and FAIR-style Data Master
 * 
 * -------------------------------------------------------------------------------------------
 * License Agreement for this software:
 *
 * Copyright (C) 2017  Dietrich Beck
 * GSI Helmholtzzentrum fuer Schwerionenforschung GmbH
 * Planckstrasse 1
 * D-64291 Darmstadt
 * Germany
 *
 * Contact: d.beck@gsi.de
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 3 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *  
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library. If not, see <http://www.gnu.org/licenses/>.
 *
 * For all questions and ideas contact: d.beck@gsi.de
 * Last update: 25-April-2015
 ********************************************************************************************/
#define DMUNIPZ_FW_VERSION 0x000820                                     // make this consistent with makefile

// standard includes
#include <stdio.h>
#include <string.h>
#include <inttypes.h>
#include <stdint.h>

// includes specific for bel_projects
#include "dbg.h"                                                        // debug outputs
#include <stack.h>
#include "ebm.h"                                                        // EB master
#include "pp-printf.h"                                                  // print statement
#include "mini_sdb.h"                                                   // sdb stuff
#include "aux.h"                                                        // cpu and IRQ
#include "uart.h"                                                       // WR console
#include "../../../top/gsi_scu/scu_mil.h"                               // register layout of 'MIL macro'

// includes for this project
#include <common-defs.h>
#include <common-fwlib.h>
#include <dm-unipz.h>
#include <dmunipz_shared_mmap.h>                                        // autogenerated upon building firmware
#include "../../ftm/include/ftm_common.h"                               // defs and regs for data master
#include "../../../syn/gsi_pexarria5/ftm/ftm_shared_mmap.h"             // info on shared map for data master lm32 cluster


uint32_t dmExt2BaseAddr(uint32_t extAddr) // data master external address -> external base address
{
  uint32_t r;                                                           // RAM size
  uint32_t m;                                                           // mask
  uint32_t baseAddr;

  // round ram size up to next 2^n value
  r = RAM_SIZE;
  r--;
  r |= r >> 1;
  r |= r >> 2;
  r |= r >> 4;
  r |= r >> 8;
  r |= r >> 16;
  r++;

  // decrement to obtain mask for 'lower' address bit
  m = r - 1;

  // apply inverse mask to get rid of bits for external address range
  baseAddr = extAddr & ~m;

  return baseAddr;
} //dmExt2BaseAddr


uint32_t dmExt2IntAddr(uint32_t extAddr) // data master external address -> internal address
{
  uint32_t intAddr;
  uint32_t extBaseAddr;

  extBaseAddr = dmExt2BaseAddr(extAddr);

  intAddr     = extAddr - extBaseAddr;
  intAddr     = intAddr + INT_BASE_ADR;

  return intAddr;
} //dmExt2IntAddr


uint32_t dmInt2ExtAddr(uint32_t intAddr, uint32_t extBaseAddr) // data master internal address -> external address
{
  uint32_t extAddr;

  extAddr = intAddr - INT_BASE_ADR;
  extAddr = extAddr + extBaseAddr;

  return extAddr;
} //dmInt2ExtAddr


// stuff required for environment
extern uint32_t*       _startshared[];
unsigned int cpuId, cpuQty;
#define SHARED __attribute__((section(".shared")))
uint64_t SHARED dummy = 0;

// global variables 
volatile uint32_t *pShared;             // pointer to begin of shared memory region                              
uint32_t *pSharedNIterMain;             // pointer to a "user defined" u32 register; here: publish # of iterations of main loop
uint32_t *pSharedVirtAcc;               // pointer to a "user defined" u32 register; here: publish # of virtual accelerator requested by Data Master
uint32_t *pSharedVirtAccRec;            // pointer to a "user defined" u32 register; here: publish # of virtual accelerator received from UNIPZ
uint32_t *pSharedNoBeam;                // pointer to a "user defined" u32 register; here: publish 'no beam' flag requested by Data Master
uint32_t *pSharedDtStart;               // pointer to a "user defined" u32 register; here: publish difference between actual time and start of injection-thread @ DM
uint32_t *pSharedDtSync1;               // pointer to a "user defined" u32 register; here: publish time difference between EVT_READY_TO_SIS and EVT_MB_TRIGGER
uint32_t *pSharedDtSync2;               // pointer to a "user defined" u32 register; here: publish time difference between EVT_READY_TO_SIS and CMD_UNI_TCREL
uint32_t *pSharedDtInject;              // pointer to a "user defined" u32 register; here: publish time difference between CMD_UNI_BREQ and EVT_MB_TRIGGER
uint32_t *pSharedDtTransfer;            // pointer to a "user defined" u32 register; here: publish time difference between CMD_UNI_TKREQ and EVT_MB_TRIGGER
uint32_t *pSharedDtTkreq;               // pointer to a "user defined" u32 register; here: publish time difference between CMD_UNI_TKREQ and reply from UNIPZ
uint32_t *pSharedDtBreq;                // pointer to a "user defined" u32 register; here: publish time difference between CMD_UNI_BREQ and reply from UNIPZ
uint32_t *pSharedDtBprep;               // pointer to a "user defined" u32 register; here: publish time difference between CMD_UNI_BREQ and begin of request to UNIPZ
uint32_t *pSharedDtReady2Sis;           // pointer to a "user defined" u32 register; here: publish time difference between CMD_UNI_BREQ and EVT_READY_TO_SIS
uint32_t *pSharedNR2sTransfer;          // pointer to a "user defined" u32 register; here: publish # of EVT_READY_TO_SIS events in between CMD_UNI_TKREQ and CMD_UNI_TKREL
uint32_t *pSharedNR2sCycle;             // pointer to a "user defined" u32 register; here: publish # of EVT_READY_TO_SIS events in between CMD_UNI_TKREL and the following CMD_UNI_TKREL
uint32_t *pSharedNBooster;              // pointer to a "user defined" u32 register; here: publish # of booster injections
volatile uint32_t *pSharedDstMacHi;     // pointer to a "user defined" u64 register; here: get MAC of the Data Master WR interface from host
volatile uint32_t *pSharedDstMacLo;     // pointer to a "user defined" u64 register; here: get MAC of the Data Master WR interface from host
volatile uint32_t *pSharedDstIP;        // pointer to a "user defined" u32 register; here: get IP of Data Master WR interface from host
volatile uint32_t *pSharedThrdOffset;   // pointer to a "user defined" u32 register; here: TS_STARTTHREAD = OFFSETTHRD + TS_MILEVENT; values in ns
volatile uint32_t *pSharedUniTimeout;   // pointer to a "user defined" u32 register; here: timeout value for UNIPZ
volatile uint32_t *pSharedTkTimeout;    // pointer to a "user defined" u32 register; here: timeout value for TK (via UNIPZ)

uint32_t *cpuRamExternal;               // external address (seen from host bridge) of this CPU's RAM

WriteToPZU_Type  writePZUData;          // Modulbus SIS, I/O-Modul 1, Bits 0..15

uint64_t statusArray;                   // all status infos are ORed bit-wise into statusArray, statusArray is then published
uint32_t statusTransfer;                // status of transfer
uint32_t nTransfer;                     // # of transfers
uint32_t nMulti;                        // # of 'multi-multi-injections' within current transfer
uint32_t nBoost;                        // # of 'booster cycles' within current transfer
uint32_t thrdOffset;                    // offset added to obtain timestamp for start of 'injection-thread' at DM
uint32_t uniTimeout;                    // timeout value for UNIPZ
uint32_t tkTimeout;                     // timeout value for TK (via UNIPZ)
uint32_t nBadStatus;                    // # of bad status (=error) incidents
uint32_t nBadState;                     // # of bad state (=FATAL, ERROR, UNKNOWN) incidents
uint64_t tReady2Sis;                    // time, when EVT_READY_TO_SIS was received
uint64_t tBreq;                         // time, when CMD_UNI_BREQ was received
uint64_t tTkreq;                        // time, when CMD_UNI_TCREQ was received
uint32_t flagTkReq;                     // flag for diagnostics: set to '1', when CMD_UNI_TCREQ is received; set to '0', when CMD_UNI_TCREL is received
uint32_t nR2sTransfer;                  // # of EVT_READY_TO_SIS events in between CMD_UNI_TKREQ and CMD_UNI_TKREL
uint32_t nR2sTotal;                     // total # of EVT_READY_TO_SIS events
uint32_t nR2sLastTkrel;                 // # of EVT_READY_TO_SIS events at last CMD_UNI_TKREL
uint32_t nR2sCycle;                     // # of EVT_READY_TO_SIS events since last CMD_UNI_TKREL
uint32_t flagDebug;                     // debug flag

#define DM_NBLOCKS       1              // max number of blocks changed within the Data Master
dmComm  dmCmds[DM_NBLOCKS];             // data for treatment of blocks
#define REQTK            0              // handles DM for TK request; flow command

#define DM_NTHREADS      1              // max number of threads changed within the Data Master
dmThrd  dmThrs[DM_NTHREADS];            // data for treatment of threads
#define REQBEAM          0              // handles DM for beam request; thread handling

uint32_t nLate;                         // # of late messages
uint32_t offsDone;                      // offset deadline WR message to time when we are done [ns]
int32_t  comLatency;                    // latency for messages received via ECA

int32_t  maxComLatency;
uint32_t maxOffsDone;



// check thread control data
uint32_t dmCheckThr(uint32_t blk)
{
  // two checks are run on the data of the thread control, which we intend to send to the Data Master later
  // verify, the addresses of thread data are non-zero

  // exclude non-zero 'origin' addresses
  if (!(dmThrs[blk].dynpar)) {
    DBPRINT3("dm-unipz: check thread: dynpar is 0x0\n");
    return DMUNIPZ_STATUS_INVALIDTHRADDR;
  } // if !dynpar

  // exclude non-zero 'thread staging' addresses
  if (!(dmThrs[blk].TSAddr)) {
    DBPRINT3("dm-unipz: check thread: dynpar is 0x0\n");
    return DMUNIPZ_STATUS_INVALIDTHRADDR;
  } // if !TSAddr

  // exclude non-zero 'start register' addresses
  if (!(dmThrs[blk].StartAddr)) {
    DBPRINT3("dm-unipz: check thread: dynpar is 0x0\n");
    return DMUNIPZ_STATUS_INVALIDTHRADDR;
  } // if !StartAdddr
  
  return COMMON_STATUS_OK;
} // dmCheckThr


// clear thread control data
uint32_t dmClearThr(uint32_t blk)
{
  // - thread control data is received with every CMD_UNI_BREQ(_NOWAIT) event from the Data Master
  // - this data is only valid for a single booster cycle
  // - from the gateway point of view, a cycle is terminated when a EVT_READY_TO_SIS has been
  //   received from UNIPZ and thread handling for DM is complete
  // - from then on, the thread control data are no longer valid
  // ==> the control data data should be cleared after every EVT_READY_TO_SIS command
  // - this prevents thread handling int the Data Master in case the schedule is corrupt

  dmThrs[blk].dynpar                         = 0x0;
  dmThrs[blk].TSAddr                         = 0x0;
  dmThrs[blk].StartAddr                      = 0x0;

  return COMMON_STATUS_OK;
} // dmClearThr


// prepare data to start a thread in the Data Master
uint32_t dmPrepThrStart(uint32_t blk, uint64_t startTS) 
{
  uint32_t originAddr;                                         // address of thread origin at CPU
  uint32_t extBaseAddr;                                        // base address of CPU
  
  uint32_t startTSAddr;                                        // address of start timestamp (external view)
  uint32_t startTSHi;                                          // time when thread shall start, high32 bit
  uint32_t startTSLo;                                          // time when thread shall start, low32 bit

  uint32_t startCtlAddr;                                       // address of thread control register for thread start
  uint32_t startCtlData;                                       // bit field for starting a thread
    
  int      i;
  uint32_t status;

  originAddr               = dmThrs[blk].dynpar;
  extBaseAddr              = dmExt2BaseAddr(originAddr);
  DBPRINT3("dm-unipz: prep thread start for origin address 0x%08x, extBaseAddr 0x%08x\n", originAddr, extBaseAddr);

  // addresses for thread start
  startTSAddr              = extBaseAddr + SHARED_OFFS + ( SHCTL_THR_STA + dmThrs[blk].thrIdx * _T_TS_SIZE_ + T_TS_STARTTIME);
  startCtlAddr             = extBaseAddr + SHARED_OFFS + (SHCTL_THR_CTL + T_TC_START); 
  DBPRINT3("dm-unipz: prep thread start TS address 0x%08x, thread start ctrl address 0x%08x\n", startTSAddr, startCtlAddr);

  // timestamp when thread shall start
  startTSHi         = (uint32_t)(startTS >> 32);
  startTSLo         = (uint32_t)(startTS & 0xffffffff);
  // start bit required for thread start
  startCtlData      = 1 << dmThrs[blk].thrIdx;
  DBPRINT3("dm-unipz: prep thread startTSHi 0x%08x\n", startTSHi);
  DBPRINT3("dm-unipz: prep thread startTSLo 0x%08x\n", startTSLo);
  DBPRINT3("dm-unipz: prep thread ctlData   0x%08x\n", startCtlData);

  // assign prepared values for later use;
  dmThrs[blk].TSAddr    = startTSAddr;
  dmThrs[blk].TSData[0] = startTSHi;
  dmThrs[blk].TSData[1] = startTSLo;
  dmThrs[blk].StartAddr = startCtlAddr;
  dmThrs[blk].StartData = startCtlData;
   
  return COMMON_STATUS_OK;
} //dmPrepThrStart


// start a thread of the Data Master on-the fly
void dmStartThread(uint32_t blk)
{
  uint64_t TS;
  uint64_t evtId;
  uint64_t param;
  
  fwlib_ebmWriteN(dmThrs[blk].TSAddr, dmThrs[blk].TSData, 2);  
  fwlib_ebmWriteN(dmThrs[blk].StartAddr, &dmThrs[blk].StartData, 1);             
  DBPRINT2("dm-unipz: dmStartThread %d, TSAddr 0x%08x, TSHi 0x%08x, TSLo 0x%08x\n", blk, dmThrs[blk].TSAddr, dmThrs[blk].TSData[0], dmThrs[blk].TSData[1]);
  DBPRINT2("dm-unipz: dmStartThread %d, StartAddr 0x%08x, StartData 0x%08x\n", blk, dmThrs[blk].StartAddr, dmThrs[blk].StartData);

  // if debugging is enabled, write data for Data Master to our own ECA input
  if (flagDebug) {
    // TS for thread start
    TS    = (uint64_t)(dmThrs[blk].TSData[0]) << 32;
    TS   |= (uint64_t)(dmThrs[blk].TSData[1]);
    evtId = 0xcafe000000000000;
    evtId = evtId | ((uint64_t)0xfa0 << 36);
    evtId = evtId | dmThrs[blk].TSAddr;
    param = 0x0;
    fwlib_ecaWriteTM(TS, evtId, param, 0x0, 1);

    // write start bit to global control register
    TS    = TS + 8;
    evtId = 0xcafe000000000000;
    evtId = evtId | ((uint64_t)0xfa1 << 36);
    evtId = evtId | dmThrs[blk].StartAddr;
    param = dmThrs[blk].StartData;
    fwlib_ecaWriteTM(TS, evtId, param, 0x0, 1);
  } // if flagDebug
} // dmStartThread


// check command
uint32_t dmCheckCmd(uint32_t blk)    
{
  // two checks are run on the data of the commands, which we intend to send to the Data Master later
  // A. --> verify, the addresses of the blocks are non-zero


  // exclude non-zero block addresses (don't test dynpar1 as it is not always used)
  if (!(dmCmds[blk].dynpar))                    return DMUNIPZ_STATUS_INVALIDBLKADDR;

  // exclude non-zero command addresses
  if (!(dmCmds[blk].cmdAddr))                   return DMUNIPZ_STATUS_INVALIDBLKADDR;
  
  return COMMON_STATUS_OK;
} // dmCheckCmd


// clear command data
uint32_t dmClearCmd(uint32_t blk)
{
  // - command data is received with every CMD_UNI_TCREQ event from the Data Master
  // - this data is only valid for one transfer
  // - a transfer is terminated via a CMD_UNI_TRREL event
  // - from then on, the command data are no longer valid
  // ==> the command data should be cleared with every CMD_UNI_TCREL command
  // - this prevents that commands are sent to the Data Master in case the schedule
  //   is corrupt

  dmCmds[blk].dynpar                         = 0x0;
  dmCmds[blk].cmdAddr                        = 0x0;

  return COMMON_STATUS_OK;
} // dmClearCmd


// prepare data common to all commands
uint32_t dmPrepCmdCommon(uint32_t blk, uint32_t prio, uint32_t checkEmptyQ, uint64_t cmdValidTime) 
{
  // simplified memory layout at DM
  //
  // blockAddr -> |...      |
  //              |IL       |
  //              |HI       |
  //              |Lo-------|--buffListAddr--> |buf0  |
  //              |wrIdx    |                  |buf1--|--cmdListAddr-->|cmd0  |                           
  //              |rdIdx    |                                          |cmd1--|--cmdAddr-->|TS valid Hi  |                           
  //              |...      |                                                              |TS valid Lo  |                           
  //                                                                                       |action(type) |
  //                                                                                       |type specific|
  //                                                                           
  //                                                                           
  //                                                   

  uint32_t blockAddr;                                          // address of begin of control block
  uint32_t blockData[(_MEM_BLOCK_SIZE >> 2)];                  // buffer for reading the info of an entire block
  
  uint32_t wrIdxs;                                             // write indices for all prios (8 bit N/A, 8 bit IL, 8 bit Hi, 8 bit Lo)
  uint8_t  wrIdx;                                              // write index for relevant priority
  uint32_t rdIdxs;                                             // read indices for all prios (8 bit N/A, 8 bit IL, 8 bit Hi, 8 bit Lo)
  uint8_t  rdIdx;                                              // read index for relevant priority

  uint32_t buffListAddrIL;                                     // address of buffer list (of interlock priority Q)
  uint32_t buffListAddrHi;                                     // address of buffer list (of high priority Q)
  uint32_t buffListAddrLo;                                     // address of buffer list (of low priority Q)
  
  uint32_t buffListAddr;                                       // address of  buffer list (of relevant priority)
  uint32_t buffListAddrOffs;                                   // where to find the relevant command buffer within the buffer list
  uint32_t buffAddr;                                           // address of relevant command buffer; buffListAdd + buffListAddOffs
  
  uint32_t cmdListAddr;                                        // address of command list 
  uint32_t cmdListAddrOffs;                                    // where to find the relevant command  within the command list
  uint32_t cmdAddr;                                            // address of relevant command; cmdListAddr + cmdListAddrOffs
  
  uint32_t cmdValidTSHi;                                       // time when command becomes valid, high32 bit
  uint32_t cmdValidTSLo;                                       // time when command becomes valid, low32 bit
  
  uint32_t extBaseAddr;                                        // external base address of dm; seen from 'world' perspective

  int      i;
  uint32_t status;

  if (prio > 2) {
    DBPRINT1("dm-unipz: prep cmd error: illegal value for priority: %u\n", (unsigned int)prio);    
    return COMMON_STATUS_OUTOFRANGE;
  } // if prio illegal
  
  // set Data Master (of relevant lm32) base address from external perspective
  //intBaseAddr      = INT_BASE_ADR;       
  blockAddr      = dmCmds[blk].dynpar;
  extBaseAddr    = dmExt2BaseAddr(blockAddr);
  DBPRINT3("dm-unipz: prep cmd for block address0x%08x, extBaseAddr 0x%08x, size %d\n", blockAddr, extBaseAddr, (_MEM_BLOCK_SIZE >> 2 ));
  
  // get data of block from DM
  if ((status = fwlib_ebmReadN(2000, blockAddr, blockData, _MEM_BLOCK_SIZE >> 2)) != COMMON_STATUS_OK) return status;

  // assign to local variables 
  buffListAddrLo = blockData[BLOCK_CMDQ_LO_PTR >> 2];      // address of buffer list of low prio Q
  buffListAddrHi = blockData[BLOCK_CMDQ_HI_PTR >> 2];      // address of buffer list of high prio Q
  buffListAddrIL = blockData[BLOCK_CMDQ_IL_PTR >> 2];      // address of buffer list of interlock prio Q
  wrIdxs         = blockData[BLOCK_CMDQ_WR_IDXS >> 2];     // write indices for all prios
  rdIdxs         = blockData[BLOCK_CMDQ_RD_IDXS >> 2];     // read indices for all prios

  // write and read index bytes
  wrIdx        = (uint8_t)(wrIdxs >> (prio * 8));
  rdIdx        = (uint8_t)(rdIdxs >> (prio * 8));

  //mprintf("debug: blk %d, blkaddr 0x%x, wrIdx %d, rdIdx %d %d\n", blk, blockAddr, wrIdx, rdIdx, prio);

  // check if Q is empty
  if (checkEmptyQ) {
    if (wrIdx != rdIdx) return DMUNIPZ_STATUS_DMQNOTEMPTY;
  } // if checkEmptyQ

  // don't mess up DM: verify queue of relevant prio is _not_ full. In that case we are not allowed to write to queue and we have to give up
  if (((wrIdx & Q_IDX_MAX_OVF_MSK) != (rdIdx & Q_IDX_MAX_OVF_MSK)) && ((wrIdx & Q_IDX_MAX_MSK) == (rdIdx & Q_IDX_MAX_MSK))) {
    DBPRINT1("dm-unipz: prep cmd error: queue for priority %u full\n", (unsigned int)prio);
    return COMMON_STATUS_OUTOFRANGE;
  } // if prio q full
    
  // offset in buffer list and command list
  buffListAddrOffs = (wrIdx & Q_IDX_MAX_MSK) / (_MEM_BLOCK_SIZE / _T_CMD_SIZE_ ) * _PTR_SIZE_;
  cmdListAddrOffs  = (wrIdx & Q_IDX_MAX_MSK) % (_MEM_BLOCK_SIZE / _T_CMD_SIZE_ ) * _T_CMD_SIZE_; 
  
  // buffer list according to prio, convert to external perspective, add offset
  switch (prio) {
  case 2 :
    buffListAddr   = buffListAddrIL;
    break;
  case 1 :
    buffListAddr   = buffListAddrHi;
    break;
  default:
    buffListAddr   = buffListAddrLo;
  }
  buffListAddr     = dmInt2ExtAddr(buffListAddr, extBaseAddr);
  buffAddr         = buffListAddr + buffListAddrOffs;
  DBPRINT2("dm-unipz: prep cmd buffListAddr 0x%08x, buffAddr  0x%08x\n", buffListAddr, buffAddr);
  
  // read address of command list and calculate address of relevant command
  if ((status = fwlib_ebmReadN(2000, buffAddr, &cmdListAddr, 1)) != COMMON_STATUS_OK) return status;
  cmdListAddr      = dmInt2ExtAddr(cmdListAddr, extBaseAddr);
  cmdAddr          = cmdListAddr + cmdListAddrOffs;

  // timestamp when command shall become valid
  cmdValidTSHi     = (uint32_t)(cmdValidTime >> 32);
  cmdValidTSLo     = (uint32_t)(cmdValidTime & 0xffffffff); 

  // update value for write index
  wrIdxs            = wrIdxs & ~(0xff << (prio * 8));                                 // clear current value of write index for relevant priority
  wrIdxs            = wrIdxs | (((wrIdx + 1) & Q_IDX_MAX_OVF_MSK) << (prio * 8));     // update value of write index for relevant priority

  DBPRINT3("dm-unipz: prep cmd validTSHi 0x%08x\n", cmdValidTSHi);
  DBPRINT3("dm-unipz: prep cmd validTSLo 0x%08x\n", cmdValidTSLo);
  
  // assign prepared values for later use;
  for (i=0; i<_T_CMD_SIZE_; i++) dmCmds[blk].cmdData[i] = 0x0;                        // init command data  
  dmCmds[blk].cmdAddr                        = cmdAddr;
  dmCmds[blk].cmdData[(T_CMD_TIME >> 2) + 0] = cmdValidTSHi;  
  dmCmds[blk].cmdData[(T_CMD_TIME >> 2) + 1] = cmdValidTSLo;  
  dmCmds[blk].blockWrIdxs                    = wrIdxs;
  dmCmds[blk].blockWrIdxsAddr                = blockAddr + BLOCK_CMDQ_WR_IDXS;  
  DBPRINT2("dm-unipz: prep cmd wrIdxAddr 0x%08x, wrIdxs 0x%08x\n", dmCmds[blk].blockWrIdxsAddr, wrIdxs);
  
  return COMMON_STATUS_OK;
} //dmPrepCmdCommon


// set valid time for DM command - need to call dmPrepCmdCommon first
uint32_t dmSetTValidCmdCommon(uint32_t blk, uint64_t cmdValidTime) 
{
  // simplified memory layout at DM
  //
  // blockAddr -> |...      |
  //              |IL       |
  //              |HI       |
  //              |Lo-------|--buffListAddr--> |buf0  |
  //              |wrIdx    |                  |buf1--|--cmdListAddr-->|cmd0  |                           
  //              |rdIdx    |                                          |cmd1--|--cmdAddr-->|TS valid Hi  |                           
  //              |...      |                                                              |TS valid Lo  |                           
  //                                                                                       | ... |
  //                                                   

  uint32_t cmdValidTSHi;                                       // time when command becomes valid, high32 bit
  uint32_t cmdValidTSLo;                                       // time when command becomes valid, low32 bit
  
  // timestamp when command shall become valid
  cmdValidTSHi     = (uint32_t)(cmdValidTime >> 32);
  cmdValidTSLo     = (uint32_t)(cmdValidTime & 0xffffffff); 

  DBPRINT3("dm-unipz: set valid time cmd validTSHi 0x%08x\n", cmdValidTSHi);
  DBPRINT3("dm-unipz: set valid time cmd validTSLo 0x%08x\n", cmdValidTSLo);
  
  dmCmds[blk].cmdData[(T_CMD_TIME >> 2) + 0] = cmdValidTSHi;  
  dmCmds[blk].cmdData[(T_CMD_TIME >> 2) + 1] = cmdValidTSLo;  

  return COMMON_STATUS_OK;
} //dmSetTValidCmdCommon


// prepare flow CMD for DM - need to call dmPrepCmdCommon first
// code for treatment of a 'flexwait' block; presently (sept 2021) no longer required but we keep the code
uint32_t dmPrepCmdFlow(uint32_t blk) 
{
  // simplified memory layout of flow command
  //
  // dmCmdAddr-->|TS valid Hi|
  //             |TS valid Lo|
  //             |action     |
  //             |flow dest. |
  //             |res        | 
  //             |...        |               

  uint32_t cmdAction;                                          // action flags of command
  uint32_t cmdFlowDestAddr;                                    // address of flow destination
  
  // set command action type to flow
  cmdAction        = (ACT_TYPE_FLOW & ACT_TYPE_MSK) << ACT_TYPE_POS;  // set type to "flow"
  cmdAction       |= (            1 & ACT_QTY_MSK)  << ACT_QTY_POS;   // set quantity to "1"
  cmdAction       |= (      PRIO_LO & ACT_PRIO_MSK) << ACT_PRIO_POS;  // set prio to "Low"

  // set address of flow destination
  cmdFlowDestAddr  = dmExt2IntAddr(dmCmds[blk].dynpar);

  DBPRINT3("dm-unipz: prep  dmPrepFLowCmd for blk %d\n", blk);
  DBPRINT3("dm-unipz: prep  cmdAction 0x%08x, index %d\n", cmdAction, T_CMD_ACT >> 2);
  DBPRINT3("dm-unipz: prep  cmdFlowDestAddr 0x%08x, index %d\n", cmdFlowDestAddr, T_CMD_FLOW_DEST >> 2);
  DBPRINT3("dm-unipz: prep  cmdFlowReserved 0x%08x, index %d\n", 0x0, T_CMD_RES >> 2);
  
  // assign prepared values for later use;
  dmCmds[blk].cmdData[T_CMD_ACT >> 2]        = cmdAction;
  dmCmds[blk].cmdData[T_CMD_FLOW_DEST >> 2]  = cmdFlowDestAddr; 
  dmCmds[blk].cmdData[T_CMD_RES >> 2]        = 0x0;

  return COMMON_STATUS_OK;
} //dmPrepFlowCmd


// prepare flush CMD for DM - need to call dmPrepCmdCommon first
uint32_t dmPrepCmdFlush(uint32_t blk) 
{
  // simplified memory layout of flush command
  //
  // dmCmdAddr-->|TS valid Hi  |
  //             |TS valid Lo  |
  //             |action       |
  //             |...          | 


  uint32_t cmdAction;                                                             // action flags of command

  // set command action type to flush
  cmdAction        = (      ACT_TYPE_FLUSH & ACT_TYPE_MSK) << ACT_TYPE_POS;       // set type to "flush"
  cmdAction       |= (                    1 & ACT_QTY_MSK) << ACT_QTY_POS;        // set quantity to "1"
  cmdAction       |= (             PRIO_HI & ACT_PRIO_MSK) << ACT_PRIO_POS;       // set prio to "1"
  cmdAction       |= ((1 << PRIO_LO) & ACT_FLUSH_PRIO_MSK) << ACT_FLUSH_PRIO_POS; // flush lo prio q

  dmCmds[blk].cmdData[T_CMD_ACT >> 2]            = cmdAction;
  dmCmds[blk].cmdData[T_CMD_FLUSH_OVR >> 2]      = 0x0;
  
  return COMMON_STATUS_OK;  
} //cmdPrepCmdFlush


// alter a block within the Data Master on-the fly
void dmChangeBlock(uint32_t blk)
{
  uint64_t TS;
  uint64_t evtId;
  uint64_t param;
  
  fwlib_ebmWriteN(dmCmds[blk].cmdAddr, dmCmds[blk].cmdData, (_T_CMD_SIZE_ >> 2));  
  fwlib_ebmWriteN(dmCmds[blk].blockWrIdxsAddr, &dmCmds[blk].blockWrIdxs, 1);             
  DBPRINT2("dm-unipz: dmChangeBlock blk %d, cmdAddr 0x%08x, cmdData[0] 0x%08x, cmdData[1] 0x%08x\n", blk, dmCmds[blk].cmdAddr, dmCmds[blk].cmdData[0], dmCmds[blk].cmdData[1]);

  // if debugging is enabled, write data for Data Master to our own ECA input
  if (flagDebug) {
    // command address and data
    TS    = (uint64_t)(dmCmds[blk].cmdData[(T_CMD_TIME >> 2) + 0]) << 32;
    TS   |= (uint64_t)(dmCmds[blk].cmdData[(T_CMD_TIME >> 2) + 1]);

    evtId = 0xcafe000000000000;
    evtId = evtId | ((uint64_t)0xfa2 << 36);
    evtId = evtId | dmCmds[blk].cmdAddr;
    param = dmCmds[blk].cmdData[0];
    fwlib_ecaWriteTM(TS, evtId, param, 0x0, 1);

    // blockWrIdxs address and idxs
    TS    = TS + 8;
    evtId = 0xcafe000000000000;
    evtId = evtId | ((uint64_t)0xfa3 << 36);
    evtId = evtId | dmCmds[blk].blockWrIdxsAddr;
    param = dmCmds[blk].blockWrIdxs;
    fwlib_ecaWriteTM(TS, evtId, param, 0x0, 1);
  } // if flagDebug
} // dmChangeBlock


// typical init for lm32
void init()
{
  discoverPeriphery();        // mini-sdb ...
  uart_init_hw();             // needed by WR console   
  cpuId = getCpuIdx();
} // init


// determine address and clear shared mem
void initSharedMem(uint32_t *reqState, uint32_t *sharedSize)
{
  uint32_t idx;
  uint32_t *pSharedTemp;
  int      i;  
  const uint32_t c_Max_Rams = 10;
  sdb_location found_sdb[c_Max_Rams];
  sdb_location found_clu;

  // chk: cpuRamExternal as parameter 
  
  // get pointer to shared memory
  pShared             = (uint32_t *)_startshared;

  // get address to data
  pSharedNIterMain    = (uint32_t *)(pShared + (DMUNIPZ_SHARED_NITERMAIN >> 2));
  pSharedVirtAcc      = (uint32_t *)(pShared + (DMUNIPZ_SHARED_TRANSVIRTACC >> 2));
  pSharedNoBeam       = (uint32_t *)(pShared + (DMUNIPZ_SHARED_TRANSNOBEAM >> 2));
  pSharedDtStart      = (uint32_t *)(pShared + (DMUNIPZ_SHARED_DTSTART >> 2));
  pSharedDtSync1      = (uint32_t *)(pShared + (DMUNIPZ_SHARED_DTSYNC1 >> 2));
  pSharedDtSync2      = (uint32_t *)(pShared + (DMUNIPZ_SHARED_DTSYNC2 >> 2));  
  pSharedDtInject     = (uint32_t *)(pShared + (DMUNIPZ_SHARED_DTINJECT >> 2));
  pSharedDtTransfer   = (uint32_t *)(pShared + (DMUNIPZ_SHARED_DTTRANSFER >> 2));
  pSharedDtTkreq      = (uint32_t *)(pShared + (DMUNIPZ_SHARED_DTTKREQ >> 2));
  pSharedDtBreq       = (uint32_t *)(pShared + (DMUNIPZ_SHARED_DTBREQ >> 2));
  pSharedDtBprep      = (uint32_t *)(pShared + (DMUNIPZ_SHARED_DTBPREP >> 2));
  pSharedDtReady2Sis  = (uint32_t *)(pShared + (DMUNIPZ_SHARED_DTREADY2SIS >> 2));
  pSharedNR2sTransfer = (uint32_t *)(pShared + (DMUNIPZ_SHARED_NR2STRANSFER >> 2));
  pSharedNR2sCycle    = (uint32_t *)(pShared + (DMUNIPZ_SHARED_NR2SCYCLE >> 2));
  pSharedNBooster     = (uint32_t *)(pShared + (DMUNIPZ_SHARED_NBOOSTER >> 2));
  pSharedVirtAccRec   = (uint32_t *)(pShared + (DMUNIPZ_SHARED_RECVIRTACC >> 2));
  pSharedDstMacHi     = (uint32_t *)(pShared + (DMUNIPZ_SHARED_DSTMACHI >> 2));
  pSharedDstMacLo     = (uint32_t *)(pShared + (DMUNIPZ_SHARED_DSTMACLO >> 2));
  pSharedDstIP        = (uint32_t *)(pShared + (DMUNIPZ_SHARED_DSTIP >> 2));
  pSharedThrdOffset   = (uint32_t *)(pShared + (DMUNIPZ_SHARED_OFFSETTHRD >> 2));
  pSharedUniTimeout   = (uint32_t *)(pShared + (DMUNIPZ_SHARED_UNITIMEOUT >> 2));
  pSharedTkTimeout    = (uint32_t *)(pShared + (DMUNIPZ_SHARED_TKTIMEOUT >> 2));
  
  // find address of CPU from external perspective
  cpuRamExternal = 0x0;
  idx = 0;
  find_device_multi(&found_clu, &idx, 1, GSI, LM32_CB_CLUSTER);
  if (idx == 0) {
    *reqState = COMMON_STATE_FATAL;
    DBPRINT1("dm-unipz: fatal error - did not find LM32-CB-CLUSTER!\n");
  } // if idx
  idx = 0;
  find_device_multi_in_subtree(&found_clu, &found_sdb[0], &idx, c_Max_Rams, GSI, LM32_RAM_USER);
  if (idx == 0) {
    *reqState = COMMON_STATE_FATAL;
    DBPRINT1("dm-unipz: fatal error - did not find THIS CPU!\n");
  } // if idx
  else cpuRamExternal = (uint32_t *)(getSdbAdr(&found_sdb[cpuId]) & 0x7FFFFFFF); // CPU sees the 'world' under 0x8..., remove that bit to get host bridge perspective

  DBPRINT2("dm-unipz: CPU RAM external 0x%8x, shared offset 0x%08x\n", cpuRamExternal, SHARED_OFFS);
  DBPRINT2("dm-unipz: fw common shared begin   0x%08x\n", pShared);
  DBPRINT2("dm-unipz: fw common shared end     0x%08x\n", pShared + (COMMON_SHARED_END >> 2));

  // clear shared mem
  i = 0;
  pSharedTemp        = (uint32_t *)(pShared + (COMMON_SHARED_END >> 2) + 1);
  DBPRINT2("dm-unipz: fw specific shared begin 0x%08x\n", pSharedTemp);
  while (pSharedTemp < (uint32_t *)(pShared + (DMUNIPZ_SHARED_END >> 2))) {
    *pSharedTemp = 0x0;
    pSharedTemp++;
    i++;
  } // while pSharedTemp
  DBPRINT2("dm-unipz: fw specific shared end   0x%08x\n", pSharedTemp);

  *sharedSize        = (uint32_t)(pSharedTemp - pShared) << 2;

  // basic info to wr console
  DBPRINT1("\n");
  DBPRINT1("dm-unipz: initSharedMem, shared size [bytes]: %d\n", *sharedSize);
  DBPRINT1("\n");

  // set initial values;
  *pSharedThrdOffset = DMUNIPZ_OFFSETTHRD; // initialize with default value
  *pSharedUniTimeout = DMUNIPZ_UNITIMEOUT; // initialize with default value
  *pSharedTkTimeout  = DMUNIPZ_TKTIMEOUT;  // initialize with default value
} // initSharedMem 


// write bit field to module bus output (linked to UNI PZ)
int16_t writeToPZU(uint16_t ifbAddr, uint16_t modAddr, uint16_t data)
{
  uint16_t wData     = 0x0;     // data to write
  int16_t  busStatus = 0;       // status of bus operation
  volatile uint32_t *pMilPiggy;

  pMilPiggy = fwlib_getMilPiggy();
  
  // select module
  wData     = (modAddr << 8) | C_IO32_KANAL_0;
  if ((busStatus = writeDevMil(pMilPiggy, ifbAddr, IFB_ADR_BUS_W, wData)) != MIL_STAT_OK) {
    DBPRINT1("dm-unipz: writeToPZU failed (address), MIL error code %d\n", busStatus);
    return busStatus;
  } // if busStatus not ok

  // write data word
  wData     = data;
  busStatus = writeDevMil(pMilPiggy, ifbAddr, IFB_DATA_BUS_W, wData);
  if (busStatus != MIL_STAT_OK) DBPRINT1("dm-unipz: writeToPZU failed (data), MIL error code %d\n", busStatus);
  
  return (busStatus);
} // writeToPZU


// read bit field from module bus input (linked to UNI PZ)
int16_t readFromPZU(uint16_t ifbAddr, uint16_t modAddr, uint16_t *data) 
{
  uint16_t wData      = 0x0;    // data to write
  uint16_t rData      = 0x0;    // data to read
  int16_t  busStatus  = 0;      // status of bus operation
  volatile uint32_t *pMilPiggy;

  pMilPiggy = fwlib_getMilPiggy();
    
  // select module
  wData     = (modAddr << 8) | C_IO32_KANAL_0;
  if ((busStatus = writeDevMil(pMilPiggy, ifbAddr, IFB_ADR_BUS_W, wData))  != MIL_STAT_OK) {
    DBPRINT1("dm-unipz: readFromPZU failed (address), MIL error code %d\n", busStatus);
    return busStatus;
  } // if busStatus not ok

  // read data
  if ((busStatus = readDevMil(pMilPiggy, ifbAddr, IFB_DATA_BUS_R, &rData)) == MIL_STAT_OK) *data = rData;
  if (busStatus != MIL_STAT_OK) DBPRINT1("dm-unipz: readFromPZU failed (data), MIL error code %d\n", busStatus);
  
  return(busStatus);
} // readFromPZU 


// check for 'Req not OK' flag from UNILAC. If the flag is set, try to clear it
uint32_t checkClearReqNotOk(uint32_t msTimeout)
{
  ReadFromPZU_Type readPZUData;  // Modulbus SIS, I/O-Modul 3, Bits 0..15
  int16_t          status;       // status MIL device bus operation
  uint64_t         timeoutT;     // when to time out

  timeoutT = getSysTime() + (uint64_t)msTimeout * (uint64_t)1000000;

  if ((status = readFromPZU(IFB_ADDRESS_SIS, IO_MODULE_3, &(readPZUData.uword))) != MIL_STAT_OK) return DMUNIPZ_STATUS_DEVBUSERROR;    
  if (readPZUData.bits.Req_not_ok) {                                                                                                         // check for 'req not ok'

    writePZUData.uword               = 0x0;
    writePZUData.bits.Req_not_ok_Ack = 0x1;
    if ((status = writeToPZU(IFB_ADDRESS_SIS, IO_MODULE_1, writePZUData.uword)) != MIL_STAT_OK) return DMUNIPZ_STATUS_DEVBUSERROR;           // request to clear not_ok flag

    while (getSysTime() < timeoutT) {                                                                                                        // check for timeout
      if ((status = readFromPZU(IFB_ADDRESS_SIS, IO_MODULE_3, &(readPZUData.uword))) != MIL_STAT_OK) return DMUNIPZ_STATUS_DEVBUSERROR; 
      if (readPZUData.bits.Req_not_ok == 0x0) {                                                                                              // remove acknowledgement for 'req not ok'
        writePZUData.bits.Req_not_ok_Ack = 0x0;                     
        writeToPZU(IFB_ADDRESS_SIS, IO_MODULE_1, writePZUData.uword); 
        return DMUNIPZ_STATUS_REQNOTOK;
      } // if UNILAC cleared 'req not ok' flag
    } // while not timed out
  
    return DMUNIPZ_STATUS_REQNOTOK;
  } // if 'req_no_ok'

  return COMMON_STATUS_OK;
} // checkClearReqNotOk


// request transfer channel
uint32_t requestTK(uint32_t msTimeout, uint32_t virtAcc, uint32_t dryRunFlag)
{
  ReadFromPZU_Type readPZUData;  // Modulbus SIS, I/O-Modul 3, Bits 0..15
  int16_t          status;       // status MIL device bus operation
  uint64_t         timeoutT;     // when to time out

  if (virtAcc > 0xf) {
    DBPRINT3("dm-unipz: illegal value for virtual accelerator %d\n", virtAcc);
    return COMMON_STATUS_OUTOFRANGE;
  } // if number of virtual accelerator illegal

  timeoutT = getSysTime() + (uint64_t)msTimeout * (uint64_t)1000000;

  // send request to modulbus I/O (UNIPZ)
  writePZUData.uword               = 0x0;
  writePZUData.bits.TK_Request     = 0x1;
  writePZUData.bits.SIS_Acc_Select = virtAcc;
  writePZUData.bits.ReqNoBeam      = dryRunFlag;
  if ((status = writeToPZU(IFB_ADDRESS_SIS, IO_MODULE_1, writePZUData.uword)) != MIL_STAT_OK) return DMUNIPZ_STATUS_DEVBUSERROR;

  // check for acknowledgement, 'request not ok' or timeout
  while (getSysTime() < timeoutT) {                                                                                                   // check for timeout
    if ((status = readFromPZU(IFB_ADDRESS_SIS, IO_MODULE_3, &(readPZUData.uword))) != MIL_STAT_OK) return DMUNIPZ_STATUS_DEVBUSERROR; // read from modulbus I/O (UNIPZ)
    if (readPZUData.bits.TK_Req_Ack == 0x1) return COMMON_STATUS_OK;                                                                  // check for acknowledgement
    if (readPZUData.bits.Req_not_ok == 0x1) return DMUNIPZ_STATUS_REQTKFAILED;                                                        // check for 'request not ok'
  } // while not timed out

  return DMUNIPZ_STATUS_REQTKTIMEOUT;
} // requestTK


// release transfer channel
uint32_t releaseTK()
{
  int16_t          status;       // status MIL device bus operation

  // send request to modulbus I/O (UNIPZ)
  writePZUData.bits.TK_Request     = 0x0;
  if ((status = writeToPZU(IFB_ADDRESS_SIS, IO_MODULE_1, writePZUData.uword)) != MIL_STAT_OK) return DMUNIPZ_STATUS_DEVBUSERROR;
  
  return COMMON_STATUS_OK;
} // releaseTK


// request beam
uint32_t requestBeam(uint32_t msTimeout, uint32_t dryRunFlag)
{
  int16_t          status;       // status MIL device bus operation
  ReadFromPZU_Type readPZUData;  // Modulbus SIS, I/O-Modul 3, Bits 0..15
  uint64_t         timeoutT;     // when to time out

  // send request to modulbus I/O (UNIPZ)
  writePZUData.bits.SIS_Request  = 0x1;
  writePZUData.bits.ReqNoBeam    = dryRunFlag; 
  if ((status = writeToPZU(IFB_ADDRESS_SIS, IO_MODULE_1, writePZUData.uword)) != MIL_STAT_OK) return DMUNIPZ_STATUS_DEVBUSERROR;
  
  // query UNIPZ for 'req Ack'
  
  timeoutT = getSysTime() + (uint64_t)msTimeout * (uint64_t)1000000;

  while (getSysTime() < timeoutT) {                                                                                                    // check for timeout
    if ((status = readFromPZU(IFB_ADDRESS_SIS, IO_MODULE_3, &(readPZUData.uword))) != MIL_STAT_OK) return DMUNIPZ_STATUS_DEVBUSERROR;   
    if (readPZUData.bits.SIS_Req_Ack == 0x1)                                                       return COMMON_STATUS_OK;           
    if (readPZUData.bits.Req_not_ok == 0x1)                                                        return DMUNIPZ_STATUS_REQBEAMFAILED; 
  } // while not timed out

  return DMUNIPZ_STATUS_REQBEAMTIMEDOUT;
} // requestBeam


// release beam
uint32_t releaseBeam(uint32_t msTimeout)
{
  int16_t          status;       // status MIL device bus operation
  ReadFromPZU_Type readPZUData;  // Modulbus SIS, I/O-Modul 3, Bits 0..15
  uint64_t         timeoutT;     // when to time out

  // send request to modulbus I/O (UNIPZ)
  writePZUData.bits.SIS_Request  = 0x0;
  writePZUData.bits.ReqNoBeam    = 0x0;
  if ((status = writeToPZU(IFB_ADDRESS_SIS, IO_MODULE_1, writePZUData.uword)) != MIL_STAT_OK) return DMUNIPZ_STATUS_DEVBUSERROR;

  timeoutT = getSysTime() + (uint64_t)msTimeout * (uint64_t)1000000;

  while (getSysTime() < timeoutT) {                                                                                                    // check for timeout
    if ((status = readFromPZU(IFB_ADDRESS_SIS, IO_MODULE_3, &(readPZUData.uword))) != MIL_STAT_OK) return DMUNIPZ_STATUS_DEVBUSERROR;   
    if (readPZUData.bits.SIS_Req_Ack == 0x0)                                                       return COMMON_STATUS_OK;           
  } // while not timed out
  
  return DMUNIPZ_STATUS_RELBEAMFAILED;
} // releaseBeam


// prepare beam; must be sent to UNIPZ ~100ms prior to beam delivery; required for reservation of Alvarez 4
uint32_t prepareBeam()
{
  int16_t          status;       // status MIL device bus operation

  // send request to modulbus I/O (UNIPZ)
  writePZUData.bits.SIS_PrepReq = 0x1;
  if ((status = writeToPZU(IFB_ADDRESS_SIS, IO_MODULE_1, writePZUData.uword)) != MIL_STAT_OK) return DMUNIPZ_STATUS_DEVBUSERROR;
  else                                                                                        return COMMON_STATUS_OK;
} // prepareBeam


// unprepare beam; un-reserve Alvarez 4
uint32_t unprepareBeam()
{
  int16_t          status;       // status MIL device bus operation

  // send request to modulbus I/O (UNIPZ)
  writePZUData.bits.SIS_PrepReq  = 0x0;
  if ((status = writeToPZU(IFB_ADDRESS_SIS, IO_MODULE_1, writePZUData.uword)) != MIL_STAT_OK) return DMUNIPZ_STATUS_DEVBUSERROR;
  else                                                                                        return COMMON_STATUS_OK;
} // unprepareBeam


// configure SoC to receive events via MIL bus
uint32_t configMILEvent(uint16_t evtCode)
{
  uint32_t i;
  volatile uint32_t *pMilPiggy;

  pMilPiggy = fwlib_getMilPiggy();


  // initialize status and command register with initial values; disable event filtering; clear filter RAM
  if (writeCtrlStatRegEvtMil(pMilPiggy, MIL_CTRL_STAT_ENDECODER_FPGA | MIL_CTRL_STAT_INTR_DEB_ON) != MIL_STAT_OK) return COMMON_STATUS_ERROR;

  // clean up 
  if (disableLemoEvtMil(pMilPiggy, 1) != MIL_STAT_OK) return COMMON_STATUS_ERROR;
  if (disableLemoEvtMil(pMilPiggy, 2) != MIL_STAT_OK) return COMMON_STATUS_ERROR;
  if (disableFilterEvtMil(pMilPiggy)  != MIL_STAT_OK) return COMMON_STATUS_ERROR; 
  if (clearFilterEvtMil(pMilPiggy)    != MIL_STAT_OK) return COMMON_STATUS_ERROR; 

  for (i=0; i < (0xf+1); i++) {
    // set filter (FIFO and LEMO1 pulsing) for all possible virtual accelerators
    if (setFilterEvtMil(pMilPiggy,  evtCode, i, MIL_FILTER_EV_TO_FIFO | MIL_FILTER_EV_PULS1_S) != MIL_STAT_OK) return COMMON_STATUS_ERROR;
  }

  // configure LEMO1 for pulse generation
  if (configLemoPulseEvtMil(pMilPiggy, 1) != MIL_STAT_OK) return COMMON_STATUS_ERROR;

  return COMMON_STATUS_OK;
} // configMILEvent


// print stuff to OLED display
void updateOLED(uint32_t statusTransfer, uint32_t virtAcc, uint32_t nTransfer, uint64_t statusArray, uint32_t actState)
{
  char     c[32];
  volatile uint32_t *pOLED;

  pOLED = fwlib_getOLED();
  if (!pOLED) return;                         // no OLED: just return

  fwlib_clearOLED();

  pp_sprintf(c, "state: %u\n", (unsigned int)actState);
  fwlib_printOLED(c);

  pp_sprintf(c, "OK?  : %d\n", (int)((statusArray >> COMMON_STATUS_OK) & 0x1));
  fwlib_printOLED(c);

  pp_sprintf(c, "vA %7u\n", (unsigned int)virtAcc);
  fwlib_printOLED(c);
  
  pp_sprintf(c, "nT %7u\n", (unsigned int)nTransfer);
  fwlib_printOLED(c);

  pp_sprintf(c, "sT  %d%d%d%d%d%d%d%d\n",
             ((statusTransfer & (0x1 << DMUNIPZ_TRANS_REQTK)     ) > 0),  
             ((statusTransfer & (0x1 << DMUNIPZ_TRANS_REQTKOK)   ) > 0), 
             ((statusTransfer & (0x1 << DMUNIPZ_TRANS_RELTK)     ) > 0),
             ((statusTransfer & (0x1 << DMUNIPZ_TRANS_PREPBEAM)  ) > 0),
             ((statusTransfer & (0x1 << DMUNIPZ_TRANS_UNPREPBEAM)) > 0),
             ((statusTransfer & (0x1 << DMUNIPZ_TRANS_REQBEAM)   ) > 0),
             ((statusTransfer & (0x1 << DMUNIPZ_TRANS_REQBEAMOK) ) > 0),
             ((statusTransfer & (0x1 << DMUNIPZ_TRANS_RELBEAM)   ) > 0)
             );
  fwlib_printOLED(c);
} // updateOLED


// entry action of state configured
uint32_t extern_entryActionConfigured()
{
  uint32_t status = COMMON_STATUS_OK;
  uint32_t i;
  uint32_t dDummy;
  uint64_t tDummy;
  uint64_t eDummy;
  uint64_t pDummy;
  uint32_t fDummy;
  uint32_t flagDummy1, flagDummy2, flagDummy3, flagDummy4;
  uint64_t dstMac;
  volatile uint32_t *pMilPiggy;

  pMilPiggy = fwlib_getMilPiggy();
 
  dstMac = ((uint64_t)(*pSharedDstMacHi) << 32) + (uint64_t)(*pSharedDstMacLo);

  
  // configure EB master (SRC and DST MAC/IP are set from host)
  DBPRINT1("dm-unipz: use Data Master MAC hi 0x%08x, lo 0x%08x, IP 0x%08x\n", *pSharedDstMacHi, *pSharedDstMacLo, *pSharedDstIP);
  if ((status = fwlib_ebmInit(2000, dstMac, *pSharedDstIP, 0xebd0)) != COMMON_STATUS_OK) {
    DBPRINT1("dm-unipz: ERROR - init of EB master failed! %u\n", (unsigned int)status);
    return status;
  } 

  // dropped test if DM is reachable by reading from ECA input: no ECA at DM

  // reset MIL piggy and wait
  if ((status = resetPiggyDevMil(pMilPiggy))  != MIL_STAT_OK) {
    DBPRINT1("dm-unipz: ERROR - can't reset MIL Piggy\n");
    return DMUNIPZ_STATUS_DEVBUSERROR;
  } 
  
  // check if modulbus I/O is ok
  if ((status = echoTestDevMil(pMilPiggy, IFB_ADDRESS_SIS, 0xbabe)) != MIL_STAT_OK) {
    DBPRINT1("dm-unipz: ERROR - modulbus SIS IFK not available at (ext) base address 0x%08x! Error code is %u\n", (unsigned int)((uint32_t)pMilPiggy & 0x7FFFFFFF), (unsigned int)status);
    return DMUNIPZ_STATUS_DEVBUSERROR;
  }
  
  DBPRINT1("dm-unipz: connection to UNIPZ (devicebus) ok\n");  

  // configure MIL piggy for timing events for all 16 virtual accelerators
  if ((status = configMILEvent(DMUNIPZ_EVT_READY2SIS)) != COMMON_STATUS_OK) {
    DBPRINT1("dm-unipz: ERROR - failed to configure MIL piggy for receiving timing events! %u\n", (unsigned int)status);
    return status;
  } 

  DBPRINT1("dm-unipz: MIL piggy configured for receving events (eventbus)\n");

  configLemoOutputEvtMil(pMilPiggy, 2);    // used to see a blinking LED (and optionally connect a scope) for debugging
  checkClearReqNotOk(uniTimeout);          // in case a 'req_not_ok' flag has been set at UNIPZ, try to clear it

  // clear bits for modulbus I/O to UNILAC
  writePZUData.uword = 0x0;
  writeToPZU(IFB_ADDRESS_SIS, IO_MODULE_1, writePZUData.uword);

  // flush ECA queue for lm32
  i = 0;
  while (fwlib_wait4ECAEvent(1 * 1000, &tDummy, &eDummy, &pDummy, &fDummy, &flagDummy1, &flagDummy2, &flagDummy3, &flagDummy4) !=  DMUNIPZ_ECADO_TIMEOUT) {i++;}
  DBPRINT1("dm-unipz: ECA queue flushed - removed %u pending entries from ECA queue\n", (unsigned int)i);

  thrdOffset  = *pSharedThrdOffset;
  uniTimeout  = *pSharedUniTimeout;
  tkTimeout   = *pSharedTkTimeout;

  return status;
} // extern_entryActionConfigured


// entry action of state operation
uint32_t extern_entryActionOperation()
{
  fwlib_clearDiag();                                                        // clear common diagnostic data
  
  return COMMON_STATUS_OK;
} // extern_entryActionOperation


// exit action of state operation
uint32_t extern_exitActionOperation()
{
volatile uint32_t *pMilPiggy;

  pMilPiggy = fwlib_getMilPiggy();
  
  if (disableFilterEvtMil(pMilPiggy) != MIL_STAT_OK) return COMMON_STATUS_ERROR;

  // always disable debugging when entering state 'operation'
  flagDebug = 0;
  
  return COMMON_STATUS_OK;
} // extern_exitActionOperation


// clear diagnostic data
void extern_clearDiag()
{
  statusArray     = 0x0; 
  statusTransfer  = 0x0;
  nTransfer       = 0x0;
  nMulti          = 0x0;
  nBoost          = 0x0;
  nLate           = 0x0;
  maxComLatency   = 0x0;
  maxOffsDone     = 0x0;
} // extern_clearDiag


// handle commands from the outside world
void cmdHandler(uint32_t *reqState, uint32_t cmd, uint32_t *statusTransfer)
{
  // check, if the command is valid and request state change
  if (cmd) {
    switch (cmd) {
      case DMUNIPZ_CMD_RELEASETK :
        releaseTK();   // force release of TK request independently of state or status
        *statusTransfer = *statusTransfer |  (0x1 << DMUNIPZ_TRANS_RELTK);
        DBPRINT1("dm-unipz: received cmd %u, forcing release of TK request\n", (unsigned int)cmd);
        break;
      case DMUNIPZ_CMD_RELEASEBEAM :
        releaseBeam(uniTimeout); // force release of beam request indpendently of state or status
        *statusTransfer = *statusTransfer |  (0x1 << DMUNIPZ_TRANS_RELBEAM);
        unprepareBeam();
        *statusTransfer = *statusTransfer |  (0x1 << DMUNIPZ_TRANS_UNPREPBEAM);
        DBPRINT1("dm-unipz: received cmd %u, forcing release of beam request\n", (unsigned int)cmd);
        break;
      case DMUNIPZ_CMD_DEBUGON :
        flagDebug = 1;
        DBPRINT1("dm-unipz: received cmd %u, enable debug option\n", (unsigned int)cmd);
        break;
      case DMUNIPZ_CMD_DEBUGOFF :
        flagDebug = 0;
        DBPRINT1("dm-unipz: received cmd %u, disable debug option\n", (unsigned int)cmd);
        break;
      default:
        DBPRINT3("dm-unipz: received unknown command '0x%08x'\n", cmd);
    } // switch 
  } // if command 
} // cmdHandler


// do action of state operation
uint32_t doActionOperation(uint32_t *statusTransfer,          // status bits indicating status of transfer
                           uint32_t *virtAccReq,              // virtual accelerator requested from Data Master
                           uint32_t *virtAccRec,              // virtual accelerator received from UNIPZ
                           uint32_t *noBeam,                  // 'no beam' flag from Data Master: UNILAC requested but without beam
                           uint64_t *dtStart,                 // remaining time budget for DM after 'start thread command' has been sent, minimum value is 1ms
                           uint64_t *dtSync1,                 // time difference between EVT_READY_2_SIS and EVT_MB_TRIGGER, should be 10ms exactly
                           uint64_t *dtSync2,                 // time difference between EVT_READY_2_SIS and CMD_UNI_TCREL, should be ~17 ms
                           uint64_t *dtInject,                // time difference between CMD_UNI_BREQ and EVT_MB_TRIGGER, must be larger than 10ms
                           uint64_t *dtTransfer,              // time difference between CMD_UNI_TKREQ and EVT_MB_TRIGGER, for diagnostics only
                           uint64_t *dtTkreq,                 // time difference between CMD_UNI_TKREQ and reply from UNIPZ
                           uint64_t *dtBreq,                  // time difference between CMD_UNI_BREQ and reply from UNIPZ
                           uint64_t *dtBprep,                 // time difference between CMD_UNI_BREQ and begin of request to UNIPZ
                           uint64_t *dtReady2Sis,             // time difference between CMD_UNI_BREQ and EVT_READY_TO_SIS
                           uint32_t *nTransfer,               // total number of transfers since start of firmware
                           uint32_t *nMulti,                  // number of multi-multi-injections within ongoing transfer
                           uint32_t *nBoost,                  // number of booster cycles within ongoing transfer
                           uint32_t actStatus)                // actual status of firmware
{
  uint32_t milStatus;                                                              // status returned by MIL lib
  uint32_t status, dmStatus;                                                       // status returned by routines
  uint32_t flagEBTimeout;                                                          // flag indicating EB communication with DM timed out
  uint32_t flagMilEvtValid;                                                        // flag indicating that we recevied a valid MIL event
  uint32_t flagLate;                                                               // flag indicating that a 'late event' was received from data master
  uint32_t flagEarly;                                                              // flag indicating that a 'early event' was received from data master
  uint32_t flagConflict;                                                           // flag indicating that a 'conflict event' was received from data master
  uint32_t flagDelayed;                                                            // flag indicating that a 'delayed event' was received from data master
  uint32_t flagNoCmd;                                                              // flag indicating we should not send a command to DM
  uint32_t flagBooster;                                                            // flag indicating we are in booster mode (and not multi-multi mode)
  uint32_t nextAction;                                                             // action triggered by event received from ECA
  uint32_t ecaVirtAcc;                                                             // # of virtual accelerator in event received from ECA
  uint32_t ecaFlagDryRun;                                                          // flag indicating that UNILAC is requested but without beam, received from ECA
  uint64_t ecaDeadline;                                                            // deadline of event received via ECA
  uint64_t ecaEvtId;                                                               // event ID received via ECA
  uint64_t ecaParam;                                                               // parameter received via ECA
  uint32_t ecaTef;                                                                 // TEF received via ECA
  uint32_t dmCpuIdx;                                                               // data master CPU Idxs
  uint32_t dmThrIdx;                                                               // data master thread Idxs
  uint64_t tDmTimeout;                                                             // time, when beam request at DM will timeout
  uint64_t tCmdThrd;                                                               // time, when DM is requested to start a dedicated 'injection-thread'
  uint64_t tCmdValid;                                                              // time, when commands sent to DM shall become valid
  uint32_t ecaInjAction;                                                           // action received by ECA during injection

  uint32_t milEvts[] = {DMUNIPZ_EVT_READY2SIS};                                    // list of MIL events we like to listen to
  uint32_t nMilEvts  = sizeof(milEvts)/sizeof(uint32_t);                           // sizeof list of MIL events
  uint32_t milDummyCode;                                                           // MIL event: code
  uint32_t milDummyData;                                                           // MIL event: data

  uint64_t ecaDummyId;                                                             // ECA event: ID
  uint64_t ecaDummyParam;                                                          // ECA event: param
  uint32_t ecaDummyTef;

  volatile uint32_t *pMilPiggy;

  pMilPiggy = fwlib_getMilPiggy();

  status = actStatus; 

  nextAction = fwlib_wait4ECAEvent(COMMON_DEFAULT_TIMEOUT * 1000, &ecaDeadline, &ecaEvtId, &ecaParam, &ecaTef, &flagLate, &flagEarly, &flagConflict, &flagDelayed);  // 'do action' is driven by actions issued by the ECA
  if (flagLate) nLate++;

  switch (nextAction) {
    case DMUNIPZ_ECADO_REQTK :                                                     // received command "REQTK" from data master
      comLatency = (int32_t)(getSysTime() - ecaDeadline);
      if (flagLate) return DMUNIPZ_STATUS_LATEEVENT;                               // never request TK in case of a late event

      (*nTransfer)++;                                                              // diagnostics: increment number of transfers

      //---- copy tag specific data from ECA
      ecaVirtAcc                = ecaEvtId & 0xf;  
      ecaFlagDryRun             = (ecaEvtId & 0x10) != 0;
      dmCmds[REQTK].dynpar      = ecaParam & 0xffffffff;                           // address of block ('slow wait with timeout')

      //---- init values
      *virtAccReq     = ecaVirtAcc;                                                // number of virtual accelerator is set when DM requests TK
      *virtAccRec     = 42;
      *noBeam         = ecaFlagDryRun;                                             // UNILAC requested without beam
      *statusTransfer = 0x1 << DMUNIPZ_TRANS_REQTK;                                // update status of transfer
      *nMulti         = 0;                                                         // number of multi-multi-injections is reset when DM requests TK
      *nBoost         = 0;                                                         // number of booster cycles is reset when DM requests TK
      *dtSync1        = 0xffffffffffffffff;                                        // time difference between EVT_READY_TO_SIS and EVT_MB_TRIGGER
      *dtSync2        = 0xffffffffffffffff;                                        // time difference between EVT_READY_TO_SIS and CMD_UNI_TCREL
      *dtTransfer     = 0xffffffffffffffff;                                        // time difference between CMD_UNI_TKREQ and EVT_MB_TRIGGER
      *dtInject       = 0xffffffffffffffff;                                        // time difference between CMD_UNI_BREQ and EVT_MB_TRIGGER
      *dtTkreq        = 0xffffffffffffffff;                                        // time difference between CMD_UNI_TKREQ and reply from UNIPZ
      *dtBreq         = 0xffffffffffffffff;                                        // time difference between CMD_UNI_BREQ and reply from UNIPZ
      *dtBprep        = 0xffffffffffffffff;                                        // time difference between CMD_UNI_BREQ and begin to request at UNIPZ
      *dtReady2Sis    = 0xffffffffffffffff;                                        // time difference between CMD_UNI_BREQ and EVT_READY_TO_SIS
      *dtStart        = 0xffffffffffffffff;                                        // remaining time budget for DM after the injection thread has started, minimum value is 1ms
      flagTkReq       = 1;                                                         // used to diagnose number of EVT_READY_TO_SIS events
      tTkreq          = ecaDeadline;
      nR2sTransfer    = 0;

      //---- reserve TK
      status   = requestTK(tkTimeout, ecaVirtAcc, ecaFlagDryRun);                  // request TK from UNIPZ
      checkClearReqNotOk(uniTimeout);                                              // check and possibly clear 'req not ok' flag at UNIPZ

      *dtTkreq = getSysTime() - ecaDeadline;                                       // diagnostics: time difference between CMD_UNI_TKREQ and reply from UNIPZ

      if (status == COMMON_STATUS_OK)
        *statusTransfer = *statusTransfer | (0x1 << DMUNIPZ_TRANS_REQTKOK);        // update status of transfer

      break;

    case DMUNIPZ_ECADO_PREPBEAM :                                                  // received command "PREPBEAM" from data master
      comLatency = (int32_t)(getSysTime() - ecaDeadline);
      if (flagLate) return DMUNIPZ_STATUS_LATEEVENT;                               // never perform PREPBEAM in case of a late event

      //---- prepare beam 
      status   = prepareBeam();                                                    // prepare beam at UNIPZ

      if (status == COMMON_STATUS_OK)
        *statusTransfer = *statusTransfer | (0x1 << DMUNIPZ_TRANS_PREPBEAM);       // update status of transfer

      break;

    case DMUNIPZ_ECADO_REQBEAM   :                                                 // received command "CMD_UNI_BREQ" from data master
                                                                                   // this is an OR, no 'break' on purpose
    case DMUNIPZ_ECADO_REQBEAMNW :                                                 // received command "CMD_UNI_BREQ_NOWAIT" from data master
      comLatency = (int32_t)(getSysTime() - ecaDeadline);
      if (flagLate) return DMUNIPZ_STATUS_LATEEVENT;                               // error: never request beam in case of a 'late event'

      // this is ugly, but ...
      if (nextAction == DMUNIPZ_ECADO_REQBEAMNW) flagBooster = 1;
      else                                       flagBooster = 0;

      if (flagBooster) {
        (*nBoost)++;
      } // if flagbooster
      else {
        (*nMulti)++;
      } // else flagbooster

      // existing thread data is invalid and must be cleared
      dmClearThr(REQBEAM);
      if (flagDelayed && flagBooster) return DMUNIPZ_STATUS_DELAYEDEVENT;          // this is a bit rude, but the likelyhood of messing up things can not be accepted

      //---- copy tag specific data from ECA
      /* ecaVirtAcc             = ecaEvtId & 0xf; chk not used, delete? */
      ecaFlagDryRun          = (ecaEvtId & 0x10) != 0;
      dmThrs[REQBEAM].dynpar = (ecaParam >> 32) & 0xffffffff;
      dmThrs[REQBEAM].cpuIdx = (ecaParam >>  8) & 0xff;
      dmThrs[REQBEAM].thrIdx = ecaParam & 0xff;
        
      //---- init values
      flagEBTimeout   = 0;                                                         // this is a 'warning flag'
      tCmdValid       = getSysTime();                                              // time when commands for DM shall become valid
      tDmTimeout      = ecaDeadline + (uint64_t)DMUNIPZ_DMTIMEOUT * (uint64_t)1000000; // absoulute time until we have to reply to DM
      tBreq           = ecaDeadline;                                               // time, when CMD_UNI_BREQ event was received
      flagMilEvtValid = 0;                                                         // flag: valid MIL event from UNIPZ received
      tReady2Sis      = 0;                                                         // init value for timestamp of EVT_READY_TO_SIS
      flagNoCmd       = 0;                                                         // always send the commands to DM unless something goes terribly wrong

      // this is either mode 'multi-multi' XOR the 1st normal injection of 'booster mode'
      if (!flagBooster) {
        dmStatus = dmPrepCmdCommon(REQTK, 1, 1, tCmdValid);                        // try "Schnitzeljagd" in Data Master. Here: "slow" waiting block
        if (dmStatus ==  COMMON_STATUS_EBREADTIMEDOUT) {                           // in case of timeout, we probably lost a UDP packet; plan B: try a 2nd time
          flagEBTimeout = 1;
          dmStatus = dmPrepCmdCommon(REQTK, 1, 1, tCmdValid);
        } // if EB timeout
        if (dmStatus != COMMON_STATUS_OK) return dmStatus;                         // error: communication with DM failed even after two attemps; no plan C, give up! 
        dmPrepCmdFlush(REQTK);                                                     // prepare flush command for first "timeout" waiting block for later use
        dmStatus = dmCheckCmd(REQTK);                                              // check cmd for valid addresses
        if (dmStatus != COMMON_STATUS_OK) return dmStatus;                         // error: invalid address fields; no plan B:  give up!
      } // if !flagBooster

      //---- arm MIL Piggy 
      enableFilterEvtMil(pMilPiggy);                                               // enable filter @ MIL piggy
      clearFifoEvtMil(pMilPiggy);                                                  // get rid of junk in FIFO @ MIL piggy

      *dtBprep = getSysTime() - ecaDeadline;                                       // diagnostics: time difference between CMD_UNI_BREQ and begine to request at UNIPZ
      *statusTransfer = *statusTransfer | (0x1 << DMUNIPZ_TRANS_REQBEAM);          // diagnostics: update status of transfer

      //---- request beam from UNIPZ and wait for EVT_READY_TO_SIS
      if ((status = requestBeam(uniTimeout, ecaFlagDryRun)) == COMMON_STATUS_OK) { // request beam from UNIPZ
        *dtBreq = getSysTime() - ecaDeadline;                                      // diagnostics: time difference between CMD_UNI_BREQ and reply from UNIPZ
        if ((milStatus = fwlib_wait4MILEvent(uniTimeout * 1000, &milDummyData, &milDummyCode, virtAccRec, milEvts, nMilEvts)) == COMMON_STATUS_OK) {   // wait for event in MIL FIFO
          ecaInjAction = fwlib_wait4ECAEvent(DMUNIPZ_QUERYTIMEOUT * 1000, &tReady2Sis, &ecaDummyId, &ecaDummyParam, &ecaDummyTef, &flagLate, &flagEarly, &flagConflict, &flagDelayed); // wait for event from ECA (hoping this is MIL Event -> TLU)
          switch (ecaInjAction)                                                    // switch required to detect messages that are not expected at this part of the schedule
            {                                                                      
              case DMUNIPZ_ECADO_READY2SIS :                                       // no error:  received EVT_READY_TO_SIS via TLU -> ECA
                if ((getSysTime() - tReady2Sis) < DMUNIPZ_MATCHWINDOW) {           // check timestamp from TLU: only accept reasonably recent timestamp
                  flagMilEvtValid = 1;                                             // everything ok: set flag for successful event reception
                  status       = COMMON_STATUS_OK;
                } // if matchwindow
                else  status = DMUNIPZ_STATUS_BADTIMESTAMP;                        // error: timestamp too old
                nR2sTransfer++;                                                    // diagnostics: increment # of EVT_READY_TO_SIS events in between CMD_UNI_TKREQ and CMD_UNI_TKREL
                nR2sTotal++;                                                       // diagnostics: increment total # of EVT_READY_TO_SIS
                break;
              case DMUNIPZ_ECADO_TIMEOUT :                                         // error: timeout, no timestamp via TLU -> ECA
                status = DMUNIPZ_STATUS_NOTIMESTAMP;                                 
                break;
              default :                                                            // error: an unexpected event was received while waiting for EVT_READY_TO_SIS.
                status = DMUNIPZ_STATUS_BADSCHEDULEB;
                flagNoCmd = 1;                                                     // wrong LSA schedule or Data Master messed up: Don't increase the chaos by sending commands to DM
            } // switch (ecaInjAction)
        } // if wait4MILEvt
        else {                                                                     // error: timeout, EVT_READY_TO_SIS was not received in MIL FIFO                                          
          status = milStatus;
          if (status == COMMON_STATUS_TIMEDOUT) status = DMUNIPZ_STATUS_WAIT4UNIEVENT; 
        } // else wait4MilEvent
      } // if request beam
      else *dtBreq = getSysTime() - ecaDeadline;                                   // error: beam request at UNIPZ failed; diagnostics: time difference between CMD_UNI_BREQ and reply from UNIPZ

      //---- analyse the situation 
      if (flagMilEvtValid) {                                                                  
        tCmdThrd     = tReady2Sis   + (uint64_t)thrdOffset;                        // everything is fine: add offset to obtain deadline for starting the injection thread at Data Master
        *dtReady2Sis = tReady2Sis - ecaDeadline;                                   // diagnostics: time difference between CMD_UNI_BREQ and reply from UNIPZ
        fwlib_milPulseLemo(2);                                                     // diagnostics: blink LED and TTL out of MIL piggy for hardware debugging with scope
      } // if MIL event was received
      else {                                                                       // error: did not receive MIL event; 
        tCmdThrd      = getSysTime() + (uint64_t)thrdOffset;                       // plan B is to scacrifice the beam and continue with actual time plus offset
      } // else MIL event was received
      
      if (tCmdThrd < (getSysTime() + (uint64_t)(COMMON_AHEADT * 2))) {             // error: not enough time is left for Data Master - risk of 'late events'
        tCmdThrd  = getSysTime()   + (uint64_t)thrdOffset;                         // plan B is to scacrifice the beam and continue with actual time plus offset
        status = DMUNIPZ_STATUS_SAFETYMARGIN;
      } // if tCmdThrd

      if (getSysTime() > tDmTimeout){                                              // error: Data Master is no longer waiting on us - risk of messung up the schedule and 'late events' 
        flagNoCmd = 1;                                                             // plang B is to sacrifice the beam and continue with actual time plus offset
        status = DMUNIPZ_STATUS_DMTIMEOUT;
      }

      // prepare command starting a thread at the Data Master
      dmStatus = dmPrepThrStart(REQBEAM, tCmdThrd);                                // prepare command for thread start
      if (dmStatus != COMMON_STATUS_OK) return dmStatus;                           // prepare command failed: give up
      dmStatus = dmCheckThr(REQBEAM);
      if (dmStatus != COMMON_STATUS_OK) return dmStatus;                           // check command failed: give up

      //---- send data to Data Master ----
      if (!flagNoCmd) {                                                            // after all this error checking we finally arrived at the point when we may send commands to the Data Master
        if (status == COMMON_STATUS_OK) dmStartThread(REQBEAM);                    // start thread within DM; only start thread in case everything went fine
        if (!flagBooster) {
          dmSetTValidCmdCommon(REQTK, tCmdThrd - 1000000);                         // set time that shall be used for terminating "slow" waiting block within DM
          dmChangeBlock(REQTK);                                                    // modify "slow" waiting block within DM
        } // if !flagBooster
      } // if !flagNoCmd

      *dtStart     = tCmdThrd - getSysTime();                                      // diagnostics: we want to know how much of the thread-offset for Data Masteris left (just to avoid the discussion), its a nice feature too

      //---- release beam and un-arm MIL piggy
      releaseBeam(uniTimeout);                                                     // release beam request at UNIPZ
      unprepareBeam();                                                             // release beam preparation at UNIPZ
      checkClearReqNotOk(uniTimeout);                                              // check and possibly clear 'req not ok' flag at UNIPZ
      disableFilterEvtMil(pMilPiggy);                                              // disable filter @ MIL piggy to avoid accumulation of junk

      //---- conclude the setting status of transfer and status of gateway
      *statusTransfer = *statusTransfer | (0x1 << DMUNIPZ_TRANS_RELBEAM);          // diagnostics: update status of transfer
      *statusTransfer = *statusTransfer | (0x1 << DMUNIPZ_TRANS_UNPREPBEAM);       // diagnostics: update status of transfer
      if (status == COMMON_STATUS_OK)
        *statusTransfer = *statusTransfer | (0x1 << DMUNIPZ_TRANS_REQBEAMOK);

      if ((status == COMMON_STATUS_OK) && flagEBTimeout)                           // handle warning in case we needed two attempts for our "Schnitzeljagd" within Data Master
        status = COMMON_STATUS_EBREADTIMEDOUT;                                           
       
      break;

    case DMUNIPZ_ECADO_RELTK :                                                     // received command "REL_TK" from data master
      comLatency = (int32_t)(getSysTime() - ecaDeadline);
      
      //---- copy tag specific data from ECA
      // calculate time difference between EVT_READY_TO_SIS and CMD_UNI_TCREL
      if (tReady2Sis == 0) *dtSync2 = 0xffffffffffffffff;                          // no valid timestamp for EVT_READY_TO_SIS
      else                 *dtSync2 = ecaDeadline - tReady2Sis;                    // we got a valid timestamp

      //---- clear data, release TK, update status
      dmClearCmd(REQTK);                                                           // with TK release, command data becomes invalid and must not be used any more
      releaseTK();                                                                 // release TK
      checkClearReqNotOk(uniTimeout);                                              // check and possibly clear 'req not ok' flag at UNIPZ
      *statusTransfer = *statusTransfer | (0x1 << DMUNIPZ_TRANS_RELTK);            // update status of transfer

      //---- diagnostics
      flagTkReq = 0;                                                               
      nR2sCycle     = nR2sTotal - nR2sLastTkrel;
      nR2sLastTkrel = nR2sTotal;

      break;

    case DMUNIPZ_ECADO_MBTRIGGER :                                                 // received MBTRIGGER: convenience feature triggering all kind of diagnostics

      // calculate time difference between EVT_READY_TO_SIS and EVT_MB_TRIGGER
      if (tReady2Sis == 0) *dtSync1 = 0xffffffffffffffff;                          // no valid timestamp for EVT_READY_TO_SIS
      else                 *dtSync1 = ecaDeadline - tReady2Sis;                    // we got a valid timestamp

      // calculate time difference between CMD_UNI_BREQ and EVT_MB_TRIGGER
      if (tBreq == 0)      *dtInject = 0xfffffffffffffff;                          // no valid timestamp for EVT_READY_TO_SIS
      else                 *dtInject = ecaDeadline - tBreq;                        // we got a valid timestamp

      // calculate time difference between CMD_UNI_TKREQ and EVT_MB_TRIGGER
      if (tTkreq == 0)     *dtTransfer = 0xfffffffffffffff;                        // no valid timestamp for EVT_READY_TO_SIS
      else                 *dtTransfer = ecaDeadline - tTkreq;                     // we got a valid timestamp

      if (status == COMMON_STATUS_OK) {                                            // we don't want to overwrite an already existing bad status
        if (flagTkReq) {                                                           // only do this test, if TK is reserved (if TK is not reserved, synchronization with UNILAC is not included in the schedule)
          // check if time difference is not reasonable. It must be within a small window around the value DMUNIPZ_OFFSETINJECT.
          if ((*dtSync1 < (uint64_t)(DMUNIPZ_OFFSETINJECT - DMUNIPZ_MATCHWINDOW)) || (*dtSync1 > (uint64_t)(DMUNIPZ_OFFSETINJECT + DMUNIPZ_MATCHWINDOW))) status = DMUNIPZ_STATUS_BADSYNC;
        } // if flagTKReq
      } // if status

      if (status == COMMON_STATUS_OK) {                                            // we don't want to overwrite an already existing bad status
        // check if time difference is not reasonable. It must be larger than 10ms. A shorter difference indicates failure/missing '10s waiting block' at DM
        if (*dtInject < (uint64_t)(DMUNIPZ_OFFSETINJECT + DMUNIPZ_MATCHWINDOW)) status = DMUNIPZ_STATUS_BADSCHEDULEA;
      } // if status
      
      break;
      
    case DMUNIPZ_ECADO_READY2SIS :                                                 // diagnostics: received EVT_READY_TO_SIS via TLU 
      if (flagTkReq) nR2sTransfer++;                                               // receiving EVT_READY_TO_SIS during ongoing transfer within transfer but outside injection (injection handled by case 'DMUNIPZ_ECADO_REQBEAM')
      nR2sTotal++;                                                                 // receiving EVT_READY_TO_SIS outside ongoing transfer indicates a periodic "virtual accelerator" from UNILAC to TK

      break;
    
    default:
      return fwlib_wrCheckSyncState();
    } // switch nextAction

    offsDone = (int32_t)(getSysTime() - ecaDeadline);
  

  return status;
} // doActionOperation


int main(void) {
  uint32_t i;                                   // counter for iterations of main loop
  uint32_t status;                              // (error) status
  uint32_t actState;                            // actual FSM state
  uint32_t pubState;                            // value of published state
  uint32_t reqState;                            // requested FSM state
  uint32_t cmd;                                 // cmd received via DP RAM
  uint32_t sharedSize;                          // size of shared memory
  /*uint32_t flagRecover;                         // flag indicating auto-recovery from error state; */

  uint32_t virtAccReq;                          // number of virtual accelerator requested by Data Master
  uint32_t virtAccRec;                          // number of virtual accelerator received from UNIPZ
  uint32_t noBeam;                              // no beam flag requested by Data Master
  uint64_t dtStart;                             // remaining time budget for DM after the injection-thread as been started, minimum value is 1ms
  uint64_t dtSync1;                             // time difference between EVT_READY_TO_SIS and EVT_MB_TRIGGER
  uint64_t dtSync2;                             // time difference between EVT_READY_TO_SIS and CMD_UNI_TCREL
  uint64_t dtInject;                            // time difference between CMD_UNI_BREQ and EVT_MB_TRIGGER, must be larger than 10ms
  uint64_t dtTransfer;                          // time difference between CMD_UNI_TKREQ and EVT_MB_TRIGGER
  uint64_t dtTkreq;                             // time difference between CMD_UNI_TKREQ and reply from UNIPZ
  uint64_t dtBreq;                              // time difference between CMD_UNI_BREQ and reply from UNIPZ
  uint64_t dtBprep;                             // time difference between CMD_UNI_BREQ and begin to request at UNIPZ
  uint64_t dtReady2Sis;                         // time difference between CMD_UNI_BREQ and EVT_READY_TO_SIS
  uint32_t *buildID;

  // init local variables
  i              = 0;
  buildID        = (uint32_t *)(INT_BASE_ADR + BUILDID_OFFS);
  
  noBeam         = 0xffffffff;
  dtStart        = 0xffffffffffffffff;
  dtSync1        = 0xffffffffffffffff;
  dtSync2        = 0xffffffffffffffff; 
  dtInject       = 0xffffffffffffffff;
  dtTransfer     = 0xffffffffffffffff;
  dtTkreq        = 0xffffffffffffffff;
  dtBreq         = 0xffffffffffffffff;
  dtBprep        = 0xffffffffffffffff;
  dtReady2Sis    = 0xffffffffffffffff;               
  nR2sTransfer   = 0;
  nR2sTotal      = 0;
  nR2sLastTkrel  = 0;
  nR2sCycle      = 0;
  virtAccReq     = 42;
  virtAccRec     = 42;
  reqState       = COMMON_STATE_S0;
  actState       = COMMON_STATE_UNKNOWN;
  pubState       = COMMON_STATE_UNKNOWN;
  status         = COMMON_STATUS_OK;
  flagTkReq      = 0;
  tBreq          = 0;
  tReady2Sis     = 0;
  nTransfer      = 0;
  nMulti         = 0;
  statusTransfer = 0;

  init();                                                                   // initialize stuff for lm32
  initSharedMem(&reqState, &sharedSize);                                    // initialize shared memory THIS MUST BE CALLED FIRST
  fwlib_init((uint32_t *)_startshared, cpuRamExternal, SHARED_OFFS, sharedSize, "dm-unipz", DMUNIPZ_FW_VERSION); // init common stuff
  fwlib_clearDiag();                                                        // clear common diagnostic data
  
  while (1) {
    check_stack_fwid(buildID);                                              // check for stack corruption
    fwlib_cmdHandler(&reqState, &cmd);                                      // check for common commands and possibly request state changes
    cmdHandler(&reqState, cmd, &statusTransfer);                            // check for commands and possibly request state changes
    status = COMMON_STATUS_OK;

    // state machine
    status = fwlib_changeState(&actState, &reqState, status);               // handle requested state changes
    switch(actState) {                                                      // state specific do actions
      case COMMON_STATE_OPREADY :
        status = doActionOperation(&statusTransfer, &virtAccReq, &virtAccRec, &noBeam, &dtStart, &dtSync1, &dtSync2, &dtInject, &dtTransfer, &dtTkreq, &dtBreq, &dtBprep, &dtReady2Sis, &nTransfer, &nMulti, &nBoost,status);
        //pp_printf("mainstatus %x\n", status);
        if (status == COMMON_STATUS_WRBADSYNC)     reqState = COMMON_STATE_ERROR;
        if (status == DMUNIPZ_STATUS_DEVBUSERROR)  reqState = COMMON_STATE_ERROR; 
        if (status == COMMON_STATUS_ERROR)         reqState = COMMON_STATE_ERROR;
        break;
      default :                                                             // avoid flooding WB bus with unnecessary activity
        status = fwlib_doActionState(&reqState, actState, status);          // handle do actions states
        break;
      } // switch

    switch (status) {
      case COMMON_STATUS_OK :                                                         // status OK
        if ((statusTransfer & (0x1 << DMUNIPZ_TRANS_REQBEAM)) == 0)  statusArray = 0; // reset when starting a new transfer
        statusArray = statusArray |  (0x1 << COMMON_STATUS_OK);                       // set OK bit
        
        break;
      default :                                                                       // status not OK
        if ((statusArray >> COMMON_STATUS_OK) & 0x1) fwlib_incBadStatusCnt();         // changing status from OK to 'not OK': increase 'bad status count'
        statusArray = statusArray & ~((uint64_t)0x1 << COMMON_STATUS_OK);             // clear OK bit
        statusArray = statusArray |  ((uint64_t)0x1 << status);                       // set status bit and remember other bits set
      break;
    } // switch status

    
    if ((pubState == COMMON_STATE_OPREADY) && (actState  != COMMON_STATE_OPREADY)) fwlib_incBadStateCnt();
    fwlib_publishStatusArray(statusArray);
    pubState             = actState;
    fwlib_publishState(pubState);

    if (comLatency > maxComLatency) maxComLatency = comLatency;
    if (offsDone   > maxOffsDone)   maxOffsDone   = offsDone;
    fwlib_publishTransferStatus(0, 0, 0, nLate, maxOffsDone, maxComLatency);


    /* publish info on mode (multi-multi/booster) and booster cycles (if applicable) */
    
    i++;
    *pSharedNIterMain    = i;
    *pSharedVirtAcc      = virtAccReq;
    *pSharedVirtAccRec   = virtAccRec;
    *pSharedNoBeam       = noBeam;
    
    if (dtStart          == 0xffffffffffffffff) *pSharedDtStart      = 0xffffffff;
    else                                        *pSharedDtStart      = (uint32_t)((float)dtStart / 1000.0);
    if (dtSync1          == 0xffffffffffffffff) *pSharedDtSync1      = 0xffffffff;
    else                                        *pSharedDtSync1      = (uint32_t)((float)dtSync1 / 1000.0);
    if (dtSync2          == 0xffffffffffffffff) *pSharedDtSync2      = 0xffffffff;
    else                                        *pSharedDtSync2      = (uint32_t)((float)dtSync2 / 1000.0);
    if (dtTransfer       == 0xffffffffffffffff) *pSharedDtTransfer   = 0xffffffff;
    else                                        *pSharedDtTransfer   = (uint32_t)((float)dtTransfer / 1000.0);
    if (dtInject         == 0xffffffffffffffff) *pSharedDtInject     = 0xffffffff;
    else                                        *pSharedDtInject     = (uint32_t)((float)dtInject / 1000.0);
    if (dtTkreq          == 0xffffffffffffffff) *pSharedDtTkreq      = 0xffffffff;
    else                                        *pSharedDtTkreq      = (uint32_t)((float)dtTkreq / 1000.0);
    if (dtBreq           == 0xffffffffffffffff) *pSharedDtBreq       = 0xffffffff;
    else                                        *pSharedDtBreq       = (uint32_t)((float)dtBreq / 1000.0);
    if (dtBprep          == 0xffffffffffffffff) *pSharedDtBprep      = 0xffffffff;
    else                                        *pSharedDtBprep      = (uint32_t)((float)dtBprep / 1000.0);
    if (dtReady2Sis      == 0xffffffffffffffff) *pSharedDtReady2Sis  = 0xffffffff;
    else                                        *pSharedDtReady2Sis  = (uint32_t)((float)dtReady2Sis / 1000.0);

    *pSharedNR2sTransfer = nR2sTransfer;
    *pSharedNR2sCycle    = nR2sCycle;
    *pSharedNBooster     = nBoost;

    // update OLED display
    updateOLED(statusTransfer, virtAccReq, nTransfer, statusArray, actState);
  } // while

  return (1);
} // main
