/********************************************************************************************
 *  b2b-cbu.c
 *
 *  created : 2019
 *  author  : Dietrich Beck, GSI-Darmstadt
 *  version : 10-December-2020
 *
 *  firmware implementing the CBU (Central Buncht-To-Bucket Unit)
 *  
 * -------------------------------------------------------------------------------------------
 * License Agreement for this software:
 *
 * Copyright (C) 2018  Dietrich Beck
 * GSI Helmholtzzentrum fuer Schwerionenforschung GmbH
 * Planckstrasse 1
 * D-64291 Darmstadt
 * Germany
 *
 * Contact: d.beck@gsi.de
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 3 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *  
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library. If not, see <http://www.gnu.org/licenses/>.
 *
 * For all questions and ideas contact: d.beck@gsi.de
 * Last update: 23-April-2019
 ********************************************************************************************/
#define B2BCBU_FW_VERSION 0x000209                                      // make this consistent with makefile

/* standard includes */
#include <stdio.h>
#include <string.h>
#include <inttypes.h>
#include <stdint.h>

/* includes specific for bel_projects */
#include "dbg.h"
#include <stack.h>                                                      // stack check
#include "ebm.h"
#include "pp-printf.h"                                                  // print stuff
#include "mini_sdb.h"                                                   // sdb stuff
#include "aux.h"                                                        // cpu and IRQ
#include "uart.h"                                                       // WR console

/* includes for this project */
#include <common-defs.h>                                                // common defs
#include <common-fwlib.h>                                               // fw lib
#include <b2b.h>                                                        // defs for b2b
#include <b2bcbu_shared_mmap.h>                                         // autogenerated upon building firmware

// stuff required for environment
extern uint32_t* _startshared[];
unsigned int     cpuId, cpuQty;
#define  SHARED  __attribute__((section(".shared")))
uint64_t SHARED  dummy = 0;
volatile uint32_t *pShared;             // pointer to begin of shared memory region

// public variables
// set values for a single commit
volatile uint32_t *pSharedSetGid;       // pointer to a "user defined" u32 register; here: group ID of extraction machine
volatile uint32_t *pSharedSetSid;       // pointer to a "user defined" u32 register; here: sequence ID of extraction machine
volatile uint32_t *pSharedSetMode;      // pointer to a "user defined" u32 register; here: mode of B2B transfer
volatile uint32_t *pSharedSetTH1ExtHi;  // pointer to a "user defined" u32 register; here: period of h=1 extraction, high bits
volatile uint32_t *pSharedSetTH1ExtLo;  // pointer to a "user defined" u32 register; here: period of h=1 extraction, low bits
volatile uint32_t *pSharedSetNHExt;     // pointer to a "user defined" u32 register; here: harmonic number extraction
volatile uint32_t *pSharedSetTH1InjHi;  // pointer to a "user defined" u32 register; here: period of h=1 injection, high bits
volatile uint32_t *pSharedSetTH1InjLo;  // pointer to a "user defined" u32 register; here: period of h=1 injecion, low bits
volatile uint32_t *pSharedSetNHInj;     // pointer to a "user defined" u32 register; here: harmonic number injection
volatile int32_t  *pSharedSetCPhase;    // pointer to a "user defined" u32 register; here: correction for phase matching ('phase knob') [ns]
volatile int32_t  *pSharedSetCTrigExt;  // pointer to a "user defined" u32 register; here: correction for trigger extraction ('extraction kicker knob') [ns]
volatile int32_t  *pSharedSetCTrigInj;  // pointer to a "user defined" u32 register; here: correction for trigger injection ('injction kicker knob') [ns]

// set values for all SIDs; the index equals the SID
uint32_t setFlagValid[B2B_NSID];            
uint32_t setGid[B2B_NSID];
uint32_t setMode[B2B_NSID];
uint64_t setTH1Ext[B2B_NSID];
uint32_t setNHExt[B2B_NSID];
uint64_t setTH1Inj[B2B_NSID];
uint32_t setNHInj[B2B_NSID];
uint32_t setCPhase[B2B_NSID];
uint32_t setCTrigExt[B2B_NSID];
uint32_t setCTrigInj[B2B_NSID];

// get values
volatile uint32_t *pSharedGetGid;          // pointer to a "user defined" u32 register; here: group ID of extraction machine
volatile uint32_t *pSharedGetSid;          // pointer to a "user defined" u32 register; here: sequence ID of extraction machine
volatile uint32_t *pSharedGetMode;         // pointer to a "user defined" u32 register; here: mode of B2B transfer
volatile uint32_t *pSharedGetTH1ExtHi;     // pointer to a "user defined" u32 register; here: period of h=1 extraction, high bits
volatile uint32_t *pSharedGetTH1ExtLo;     // pointer to a "user defined" u32 register; here: period of h=1 extraction, low bits
volatile uint32_t *pSharedGetNHExt;        // pointer to a "user defined" u32 register; here: harmonic number extraction
volatile uint32_t *pSharedGetTH1InjHi;     // pointer to a "user defined" u32 register; here: period of h=1 injection, high bits
volatile uint32_t *pSharedGetTH1InjLo;     // pointer to a "user defined" u32 register; here: period of h=1 injecion, low bits
volatile uint32_t *pSharedGetNHInj;        // pointer to a "user defined" u32 register; here: harmonic number injection
volatile uint32_t *pSharedGetTBeatHi;      // pointer to a "user defined" u32 register; here: period of beating, high bits
volatile uint32_t *pSharedGetTBeatLo;      // pointer to a "user defined" u32 register; here: period of beating, low bits
volatile int32_t  *pSharedGetCPhase;       // pointer to a "user defined" u32 register; here: correction for phase matching ('phase knob') [ns]
volatile int32_t  *pSharedGetCTrigExt;     // pointer to a "user defined" u32 register; here: correction for trigger extraction ('extraction kicker knob') [ns]
volatile int32_t  *pSharedGetCTrigInj;     // pointer to a "user defined" u32 register; here: correction for trigger injection ('injction kicker knob') [ns]
volatile int32_t  *pSharedGetComLatency;   // pointer to a "user defined" u32 register; here: latency for messages received via ECA

uint32_t gid;                           // GID used for transfer
uint32_t sid;                           // SID user for transfer
uint32_t mode;                          // mode for transfer
uint64_t TH1Ext;                        // h=1 period [as] of extraction machine
uint32_t nHExt;                         // harmonic number of extraction machine 0..15
uint64_t TH1Inj;                        // h=1 period [as] of injection machine
uint32_t nHInj;                         // harmonic number of injection machine 0..15
uint64_t TBeat;                         // beating frquency
int32_t  cPhase;                        // correction for phase matching [ns]
int32_t  cTrigExt;                      // correction for extraction trigger
int32_t  cTrigInj;                      // correction for injection trigger

uint64_t tH1Ext;                        // h=1 phase  [ns] of extraction machine
uint64_t tH1Inj;                        // h=1 phase  [ns] of injection machine

uint64_t statusArray;                   // all status infos are ORed bit-wise into statusArray, statusArray is then published
uint32_t nTransfer;                     // # of transfers
uint32_t transStat;                     // status of ongoing transfer
int32_t  comLatency;                    // latency for messages received via ECA
uint32_t mState;                        // state of 'miniFSM' 

// flags
uint32_t flagClearAllSid;               // data for all SIDs shall be cleared

uint32_t *cpuRamExternal;               // external address (seen from host bridge) of this CPU's RAM            

void init() // typical init for lm32
{
  discoverPeriphery();        // mini-sdb ...
  uart_init_hw();             // needed by WR console   
  cpuId = getCpuIdx();
} // init


void initSharedMem() // determine address and clear shared mem
{
  uint32_t idx;
  uint32_t *pSharedTemp;
  int      i; 
  const uint32_t c_Max_Rams = 10;
  sdb_location found_sdb[c_Max_Rams];
  sdb_location found_clu;
  
  // get pointer to shared memory
  pShared                 = (uint32_t *)_startshared;
  pSharedSetGid           = (uint32_t *)(pShared + (B2B_SHARED_SET_GID        >> 2));
  pSharedSetSid           = (uint32_t *)(pShared + (B2B_SHARED_SET_SID        >> 2));
  pSharedSetMode          = (uint32_t *)(pShared + (B2B_SHARED_SET_MODE       >> 2));
  pSharedSetTH1ExtHi      = (uint32_t *)(pShared + (B2B_SHARED_SET_TH1EXTHI   >> 2));
  pSharedSetTH1ExtLo      = (uint32_t *)(pShared + (B2B_SHARED_SET_TH1EXTLO   >> 2));
  pSharedSetNHExt         = (uint32_t *)(pShared + (B2B_SHARED_SET_NHEXT      >> 2));
  pSharedSetTH1InjHi      = (uint32_t *)(pShared + (B2B_SHARED_SET_TH1INJHI   >> 2));
  pSharedSetTH1InjLo      = (uint32_t *)(pShared + (B2B_SHARED_SET_TH1INJLO   >> 2));
  pSharedSetNHInj         = (uint32_t *)(pShared + (B2B_SHARED_SET_NHINJ      >> 2));
  pSharedSetCPhase        =  (int32_t *)(pShared + (B2B_SHARED_SET_CPHASE     >> 2));
  pSharedSetCTrigExt      =  (int32_t *)(pShared + (B2B_SHARED_SET_CTRIGEXT   >> 2));
  pSharedSetCTrigInj      =  (int32_t *)(pShared + (B2B_SHARED_SET_CTRIGINJ   >> 2));
  pSharedGetGid           = (uint32_t *)(pShared + (B2B_SHARED_GET_GID        >> 2));
  pSharedGetSid           = (uint32_t *)(pShared + (B2B_SHARED_GET_SID        >> 2));
  pSharedGetMode          = (uint32_t *)(pShared + (B2B_SHARED_GET_MODE       >> 2));
  pSharedGetTH1ExtHi      = (uint32_t *)(pShared + (B2B_SHARED_GET_TH1EXTHI   >> 2));
  pSharedGetTH1ExtLo      = (uint32_t *)(pShared + (B2B_SHARED_GET_TH1EXTLO   >> 2));
  pSharedGetNHExt         = (uint32_t *)(pShared + (B2B_SHARED_GET_NHEXT      >> 2));
  pSharedGetTH1InjHi      = (uint32_t *)(pShared + (B2B_SHARED_GET_TH1INJHI   >> 2));
  pSharedGetTH1InjLo      = (uint32_t *)(pShared + (B2B_SHARED_GET_TH1INJLO   >> 2));
  pSharedGetNHInj         = (uint32_t *)(pShared + (B2B_SHARED_GET_NHINJ      >> 2));
  pSharedGetCPhase        =  (int32_t *)(pShared + (B2B_SHARED_GET_CPHASE     >> 2));
  pSharedGetCTrigExt      =  (int32_t *)(pShared + (B2B_SHARED_GET_CTRIGEXT   >> 2));
  pSharedGetCTrigInj      =  (int32_t *)(pShared + (B2B_SHARED_GET_CTRIGINJ   >> 2));
  pSharedGetTBeatHi       = (uint32_t *)(pShared + (B2B_SHARED_GET_TBEATHI    >> 2));
  pSharedGetTBeatLo       = (uint32_t *)(pShared + (B2B_SHARED_GET_TBEATLO    >> 2));
  pSharedGetComLatency    =  (int32_t *)(pShared + (B2B_SHARED_GET_COMLATENCY >> 2));
  
  // find address of CPU from external perspective
  idx = 0;
  find_device_multi(&found_clu, &idx, 1, GSI, LM32_CB_CLUSTER);	
  idx = 0;
  find_device_multi_in_subtree(&found_clu, &found_sdb[0], &idx, c_Max_Rams, GSI, LM32_RAM_USER);
  if(idx >= cpuId) {
    cpuRamExternal           = (uint32_t *)(getSdbAdr(&found_sdb[cpuId]) & 0x7FFFFFFF); // CPU sees the 'world' under 0x8..., remove that bit to get host bridge perspective
  }

  DBPRINT2("b2b-cbu: CPU RAM External 0x%8x, begin shared 0x%08x\n", (unsigned int)cpuRamExternal, SHARED_OFFS);

  // clear shared mem
  i = 0;
  pSharedTemp        = (uint32_t *)(pShared + (COMMON_SHARED_END >> 2 ) + 1);
  while (pSharedTemp < (uint32_t *)(pShared + (B2B_SHARED_END >> 2 ))) {
    *pSharedTemp = 0x0;
    pSharedTemp++;
    i++;
  } // while pSharedTemp
  DBPRINT2("b2b-cbu: used size of shared mem is %d words, begin %x, end %x\n", i, (unsigned int)pShared, (unsigned int)pSharedTemp);
  fwlib_publishSharedSize((uint32_t)(pSharedTemp - pShared) << 2);
} // initSharedMem


void extern_clearDiag() // clears all statistics
{
  statusArray = 0x0;
  nTransfer   = 0x0;
  transStat   = 0x0;
  comLatency  = 0x0;
} // extern_clearDiag 


void clearAllSid()
{
  int i;
  for (i=0; i<B2B_NSID; i++) {
    setFlagValid[i] = 0;            
    setGid[i]       = 0;
    setMode[i]      = 0;
    setTH1Ext[i]    = 0;
    setNHExt[i]     = 0;
    setTH1Inj[i]    = 0;
    setNHInj[i]     = 0;
    setCPhase[i]    = 0;
    setCTrigExt[i]  = 0;
    setCTrigInj[i]  = 0;
  } // for i
} // clearAllSid


uint32_t setSubmit()
{
  int sid;
  if (*pSharedSetSid > 15)  return COMMON_STATUS_OUTOFRANGE;
  else                      sid = *pSharedSetSid;
  /* more checking required chk */
  setFlagValid[sid]    = 0;

  setGid[sid]          = *pSharedSetGid;     
  setMode[sid]         = *pSharedSetMode;    
  setTH1Ext[sid]       = (uint64_t)(*pSharedSetTH1ExtHi) << 32;
  setTH1Ext[sid]       = (uint64_t)(*pSharedSetTH1ExtLo) | setTH1Ext[sid];
  setNHExt[sid]        = *pSharedSetNHExt;   
  setTH1Inj[sid]       = (uint64_t)(*pSharedSetTH1InjHi) << 32;
  setTH1Inj[sid]       = (uint64_t)(*pSharedSetTH1InjLo) | setTH1Inj[sid];
  setNHInj[sid]        = *pSharedSetNHInj;   
  setCPhase[sid]       = *pSharedSetCPhase;  
  setCTrigExt[sid]     = *pSharedSetCTrigExt;
  setCTrigInj[sid]     = *pSharedSetCTrigInj;

  setFlagValid[sid]    = 1;
  pp_printf("submit %u\n", sid);
  return COMMON_STATUS_OK;
} // setSubmit


uint32_t extern_entryActionConfigured()
{
  uint32_t status = COMMON_STATUS_OK;

  fwlib_clearDiag();
  clearAllSid();

  flagClearAllSid = 0;

  // configure EB master (SRC and DST MAC/IP are set from host)
  if ((status = fwlib_ebmInit(2000, 0xffffffffffff, 0xffffffff, EBM_NOREPLY)) != COMMON_STATUS_OK) {
    DBPRINT1("b2b-cbu: ERROR - init of EB master failed! %u\n", (unsigned int)status);
    return status;
  } 

  // get and publish NIC data
  fwlib_publishNICData();

  return status;
} // extern_entryActionConfigured


uint32_t extern_entryActionOperation()
{
  int      i;
  uint64_t tDummy;
  uint64_t eDummy;
  uint64_t pDummy;
  uint32_t fDummy;
  uint32_t flagDummy;

  // clear diagnostics
  fwlib_clearDiag();             

  // flush ECA queue for lm32
  i = 0;
  while (fwlib_wait4ECAEvent(1, &tDummy, &eDummy, &pDummy, &fDummy, &flagDummy) !=  COMMON_ECADO_TIMEOUT) {i++;}
  DBPRINT1("b2b-cbu: ECA queue flushed - removed %d pending entries from ECA queue\n", i);

  // init set values
  *pSharedSetGid         = 0x0;     
  *pSharedSetSid         = 0x0;     
  *pSharedSetMode        = 0x0;    
  *pSharedSetTH1ExtHi    = 0x0;
  *pSharedSetTH1ExtLo    = 0x0;
  *pSharedSetNHExt       = 0x0;   
  *pSharedSetTH1InjHi    = 0x0;
  *pSharedSetTH1InjLo    = 0x0;
  *pSharedSetNHInj       = 0x0;   
  *pSharedSetCPhase      = 0x0;  
  *pSharedSetCTrigExt    = 0x0;  
  *pSharedSetCTrigInj    = 0x0;
    
  // init get values
  *pSharedGetGid         = 0x0;
  *pSharedGetSid         = 0x0;
  *pSharedGetMode        = 0x0;
  *pSharedGetTH1ExtHi    = 0x0; 
  *pSharedGetTH1ExtLo    = 0x0;
  *pSharedGetNHExt       = 0x0;
  *pSharedGetTH1InjHi    = 0x0;
  *pSharedGetTH1InjLo    = 0x0;
  *pSharedGetNHInj       = 0x0;
  *pSharedGetCPhase      = 0x0;
  *pSharedGetCTrigExt    = 0x0;
  *pSharedGetCTrigInj    = 0x0;
  *pSharedGetTBeatHi     = 0x0;
  *pSharedGetTBeatLo     = 0x0;
  *pSharedGetComLatency  = 0x0;

  return COMMON_STATUS_OK;
} // extern_entryActionOperation


uint32_t extern_exitActionOperation()
{
  return COMMON_STATUS_OK;
} // extern_exitActionOperation


uint32_t getTrigGid(uint32_t extFlag)
{
  uint32_t trigGid;

  switch (gid) {
    case SIS18_B2B_EXTRACT :
      if (extFlag) trigGid = SIS18_RING;
      else         trigGid = GID_INVALID;
      break;
    case SIS18_B2B_ESR :
      if (extFlag) trigGid = SIS18_RING;
      else         trigGid = ESR_RING;
      break;
    case ESR_B2B_EXTRACT :
      if (extFlag) trigGid = ESR_RING;
      else         trigGid = GID_INVALID;
      break;
    case ESR_B2B_CRYRING :
      if (extFlag) trigGid = ESR_RING;
      else         trigGid = CRYRING_RING;
      break;
    default :
      trigGid = GID_INVALID;
  } // switch gid

  return trigGid;
} // getTrigGid


uint32_t calcExtTime(uint64_t *tExtract, uint64_t tWant)
{
  uint32_t period;
  
  // check for unreasonable values
  if (TH1Ext == 0)                   return COMMON_STATUS_OUTOFRANGE;          // no value for period
  if (nHExt  == 0)                   return COMMON_STATUS_OUTOFRANGE;          // no value for harmonic number
  if ((tH1Ext + (1 << 30)) < tWant)  return COMMON_STATUS_OUTOFRANGE;          // value older than approximately 1s
  
  *tExtract = fwlib_advanceTime(tH1Ext, tWant, TH1Ext);
  if (*tExtract == 0)                return COMMON_STATUS_OUTOFRANGE;

  return COMMON_STATUS_OK;
} // calcExtTime


uint32_t calcPhaseMatch(uint64_t *tPhaseMatch, uint64_t *TBeat)  // calculates when extraction and injection machines are synchronized
{
  uint64_t TSlow;                                   // period of 'slow' frequency     [as] // sic! atoseconds
  uint64_t TFast;                                   // period of 'fast' frequency     [as]
  uint64_t tSlow;                                   // phase of 'slow' frequency      [as]
  uint64_t tFast;                                   // phase of 'fast' frequency      [as]
  uint64_t nHSlow;                                  // harmonic number of 'slow' frequency
  uint64_t nHFast;                                  // harmonic number of 'fast' frequency
  uint64_t TMatch;                                  // 'period' till next match       [as]
  uint64_t tMatch;                                  // phase of best match            [as]
  uint64_t Tdiff;                                   // difference between periods     [as]
  uint64_t TFastTmp;                                // temporary variable             [as]
  uint64_t epoch;                                   // temporary epoch                [>>n<<s]
  uint64_t tNow;                                    // current time                   [ns]
  uint64_t nineO = 1000000000;                      // nine orders of magnitude, needed for conversion
  
  // define temporary epoch [ns]
  tNow    = getSysTime();
  epoch   = tNow - nineO * 1;                                                     // subtracting one second should be safe

  DBPRINT3("b2b-cbu: tNow - tH1Ext %u ns, tNow - tH1inj %u ns, nHExt %u, nHInj %u\n", (unsigned int)(tNow - tH1Ext), (unsigned int)(tNow - tH1Inj), nHExt, nHInj);

  // check for unreasonable values
  if (TH1Ext * nHInj == TH1Inj * nHExt) return COMMON_STATUS_OUTOFRANGE;           // no beating
  if (TH1Ext == 0)                      return COMMON_STATUS_OUTOFRANGE;           // no value for period
  if (TH1Inj == 0)                      return COMMON_STATUS_OUTOFRANGE;           // no value for period
  if (nHExt  == 0)                      return COMMON_STATUS_OUTOFRANGE;           // no value for harmonic number
  if (nHInj  == 0)                      return COMMON_STATUS_OUTOFRANGE;           // no value for harmonic number
  if (TH1Inj == 0)                      return COMMON_STATUS_OUTOFRANGE;           // no value for period
  if ((tH1Ext + nineO * 0.1) < tNow)    return COMMON_STATUS_OUTOFRANGE;           // value older than 100ms
  if ((tH1Inj + nineO * 0.1) < tNow)    return COMMON_STATUS_OUTOFRANGE;           // value older than 100ms

  // assign local values and convert times 't' to [as], periods 'T' are already in [as])
  //if (TH1Ext * nHInj > TH1Inj * nHExt) {
  if (TH1Ext * nHInj > TH1Inj * nHExt) {
    DBPRINT3("b2b-cbu: extraction is fast\n");
    TSlow  = TH1Ext;
    tSlow  = (tH1Ext - epoch) * nineO;
    nHSlow = nHExt;

    TFast  = TH1Inj;
    tFast  = (tH1Inj - epoch) * nineO;
    nHFast = nHInj;
  }
  else {
    DBPRINT3("b2b-cbu: injection is fast\n");
    TSlow  = TH1Inj;
    tSlow  = (tH1Inj - epoch) * nineO;
    nHSlow = nHInj;

    TFast  = TH1Ext;
    tFast  = (tH1Ext - epoch) * nineO;
    nHFast = nHExt;
  }

  // period of frequency beats [as], required if next match is too close
  *TBeat = (uint64_t)((double)TFast / (double)(TSlow * nHFast - TFast * nHSlow) * (double)TSlow);  // period of beating [as]

  // make sure tSlow is earlier than tFast; this is a must for the formula below
  // if not, subtract period
  while (tSlow > tFast)                      tFast = tFast + TFast;

  // make sure spacing between tSlow and tFast is not too large; otherwise we need to wait for too long
  while ((tFast - tSlow) > TFast           ) tFast = tFast - TFast;

  // make sure there is sufficient spacing between tSlow and tFast; this is a fudge thing
  //while ((tFast - tSlow) < (TFast / nHFast)) tFast = tFast + TFast;
  if ((tFast - tSlow) < nineO) tMatch = tSlow;   // we are closer than 1ns ==> done!
  else {
    DBPRINT3("b2b-cbu: tSlow %llu as, tFast %llu as, diff %llu as\n", tSlow, tFast, tFast - tSlow);
    
    // now, tSlow is earlier than tFast and both values are at most one period apart
    // we can now start our calculation
    Tdiff = TSlow * nHFast - TFast * nHSlow;
    DBPRINT3("b2b-cbu: TSlow * nHFast %llu as, TFast * nHSlow  %llu as, difference  %llu as\n", TSlow * nHFast, TFast * nHSlow, Tdiff);
    DBPRINT3("b2b-cbu: TSlow          %llu as, TFast           %llu as, difference  %llu as\n", TSlow, TFast, TSlow - TFast);
    DBPRINT3("b2b-cbu: tSlow          %llu as, tFast           %llu as, difference  %llu as\n", tSlow, tFast, tFast - tSlow);
    
    /*
    // brute force; keep this for explaining the algorithm
    uint64_t i;
    uint64_t tFastTmp;                                // temporary variable             [as]
    uint64_t tSlowTmp;                                // temporary variable             [as]
    uint64_t TSlowTmp;                                // temporary variable             [as] 
    
    tSlowTmp = tSlow;
    TSlowTmp = TSlow * nHFast;
    tFastTmp = tFast;
    TFastTmp = TFast * nHSlow; 
    i        = 0;
    DBPRINT3("b2b-cbu: TSlowTmp %llu as, TFastTmp %llu as \n", TSlowTmp, TFastTmp);
    while (tFastTmp > tSlowTmp) {
    tFastTmp += TFastTmp;
    tSlowTmp += TSlowTmp;
    i++;
    } //
    tMatch = tFastTmp;
    TMatch = tMatch - tSlow;
    DBPRINT3("b2b-cbu: TBeat %llu as, TMatch %llu as, i %llu\n", *TBeat, TMatch, i);
    DBPRINT3("b2b-cbu: tMatch %llu, TMatch %llu\n", tMatch, TMatch);
    */
    
    // calculate when phases will match
    TFastTmp = TFast * nHSlow; 
    TMatch = ((tFast - tSlow) / Tdiff) * TFastTmp + tFast - tSlow;
    tMatch = TMatch + tSlow;
    DBPRINT3("b2b-cbu: tMatch %llu, TMatch %llu, TBeat %llu\n", tMatch, TMatch, *TBeat);
  } // values are further apart than 1ns
  // check, that tMatch is further in the future than COMMON_AHEADT; if not, add one beating period
  if((tSlow + (uint64_t)COMMON_AHEADT * nineO) > tMatch) {
    tMatch += *TBeat;
    DBPRINT2("b2b-cbu: tMatch %llu, TMatch %llu, TBeat %llu (+ TBeat)\n", tMatch, TMatch, *TBeat);
    DBPRINT2("b2b-cbu: tSlow          %llu as, tFast           %llu as, difference  %llu as\n", tSlow, tFast, tFast - tSlow);
  }
 
  // convert back to [ns] and get rid of temporary epoch
  *tPhaseMatch = (uint64_t)((double)tMatch / (double)nineO) + epoch;
  /* chk  if we have enough time COMMON_AHEADT */
  if (*tPhaseMatch < tNow) DBPRINT3("b2b-cbu: err -- now - match %u ns\n", (unsigned int)(tNow - *tPhaseMatch));
  else                     DBPRINT3("b2b-cbu: ok  -- match - now %u ns\n", (unsigned int)(*tPhaseMatch - tNow));

  return COMMON_STATUS_OK;
    
} // calcPhaseMatch


// command handler, handles commands specific for this project
void cmdHandler(uint32_t *reqState, uint32_t cmd)
{
  // check, if the command is valid and request state change
  if (cmd) {                             // check, if cmd is valid
    switch (cmd) {                       // do action according to command
      case B2B_CMD_CONFSUBMIT :
        DBPRINT3("b2b: received cmd %d\n", cmd);
        if (setSubmit() != COMMON_STATUS_OK) DBPRINT1("b2b: submission of config data failed\n");
        break;
      case B2B_CMD_CONFCLEAR :
        DBPRINT3("b2b: received cmd %d\n", cmd);
        flagClearAllSid = 1;
        break;
      default:
        DBPRINT3("b2b: received unknown command '0x%08x'\n", cmd);
        break;
    } // switch 
  } // if command 
} // cmdHandler


uint32_t getNextMState(uint32_t mode, uint32_t actMState) {
  uint32_t nextMState = B2B_MFSM_NOTHING;

  switch (mode) {
    case B2B_MODE_KSE :  // extraction beam now!
      switch (actMState) {
        case B2B_MFSM_S0 :
          nextMState =  B2B_MFSM_EXTKST;
          break;
        case B2B_MFSM_EXTKST :
          nextMState =  B2B_MFSM_EXTTRIG;
          break;
        case B2B_MFSM_EXTTRIG :
          nextMState = B2B_MFSM_NOTHING;
          break;
        default:
          nextMState = B2B_MFSM_NOTHING;
      } // switch actMState mode KSE
      break;
    case B2B_MODE_B2E : // extract beam in bunch gap
      switch (actMState) {
        case B2B_MFSM_S0 :
          nextMState = B2B_MFSM_EXTPS;
          break;
        case  B2B_MFSM_EXTPS :
          nextMState = B2B_MFSM_EXTPR;
          break;
        case B2B_MFSM_EXTPR :
          nextMState = B2B_MFSM_EXTBGT;
          break;
        case B2B_MFSM_EXTBGT :
          nextMState = B2B_MFSM_EXTTRIG;
          break;
        case B2B_MFSM_EXTTRIG :
          nextMState = B2B_MFSM_NOTHING;
          break;
        default :
          nextMState = B2B_MFSM_NOTHING;
      } // switch actMState mode B2E
      break;
    case B2B_MODE_B2C : // bunch to coasting beam
      switch (actMState) {
        case B2B_MFSM_S0 :
          nextMState = B2B_MFSM_EXTPS;
          break;
        case  B2B_MFSM_EXTPS :
          nextMState = B2B_MFSM_EXTPR;
          break;
        case B2B_MFSM_EXTPR :
          nextMState = B2B_MFSM_EXTBGT;
          break;
        case B2B_MFSM_EXTBGT :
          nextMState = B2B_MFSM_EXTTRIG;
          break;
        case B2B_MFSM_EXTTRIG :
          nextMState = B2B_MFSM_INJTRIG ;
          break;
        case B2B_MFSM_INJTRIG :
          nextMState = B2B_MFSM_NOTHING;
          break;
        default :
          nextMState = B2B_MFSM_NOTHING;
      } // switch actMState mode B2C
      break;
    default :
      nextMState = B2B_MFSM_NOTHING;
  } // switch mode

  //if (!nextMState) pp_printf("mode %x, actMState %x\n", mode, actMState);

  return nextMState;
} // getNextMState


uint32_t doActionOperation(uint32_t actStatus)                // actual status of firmware
{
  uint32_t status;                                            // status returned by routines
  uint32_t flagIsLate;                                        // flag indicating that we received a 'late' event from ECA
  uint32_t ecaAction;                                         // action triggered by event received from ECA
  uint64_t sendDeadline;                                      // deadline to send
  uint64_t sendEvtId;                                         // evtID to send
  uint64_t sendParam;                                         // param to send
  uint32_t sendGid;                                           // GID to send
  uint64_t recDeadline;                                       // deadline received
  uint64_t reqDeadline;                                       // deadline requested by sender
  uint64_t recId;                                             // evt ID received
  uint64_t recParam;                                          // param received
  uint32_t recTEF;                                            // TEF received
  uint32_t recGid;                                            // GID received
  uint32_t recSid;                                            // SID received
  uint64_t tMatch;                                            // time when phases of injecion and extraction match
  uint64_t tWantExt;                                          // approximate time of extraction
  uint64_t tTrig;                                             // time when kickers shall be triggered
  uint64_t tTrigExt;                                          // time when extraction kicker shall be triggered; tTrigExt = tTrig + cTrigExt;
  uint64_t tTrigInj;                                          // time when injection kicker shall be triggered;  tTrigInj = tTrig + cTrigInj;
  uint64_t TBeat;                                             // period of beating

  status = actStatus;

  ecaAction = fwlib_wait4ECAEvent(COMMON_ECATIMEOUT, &recDeadline, &recId, &recParam, &recTEF, &flagIsLate);
    
  switch (ecaAction) {

    case B2B_ECADO_KICKSTART :                                // received: EVT_KICK_START1/2 from DM; B2B transfer starts
      reqDeadline = recDeadline + (uint64_t)COMMON_AHEADT;    // ECA is configured to pre-trigger ahead of time!!!
      comLatency  = (int32_t)(getSysTime() - recDeadline);

      sid      = (uint32_t)(recId >> 20) & 0xfff;
      //pp_printf("b2b: sid %u \n", sid);
      if (sid > 15)  {sid = 0; mState = B2B_MFSM_NOTHING; return status;}
      if (!setFlagValid[sid]) {mState = B2B_MFSM_NOTHING; return status;}
      gid      = setGid[sid];
      mode     = setMode[sid];
      TH1Ext   = setTH1Ext[sid];
      nHExt    = setNHExt[sid];
      TH1Inj   = setTH1Inj[sid];
      nHInj    = setNHInj[sid];
      cPhase   = setCPhase[sid];
      cTrigExt = setCTrigExt[sid];
      cTrigInj = setCTrigInj[sid];
      //pp_printf("b2b: gid %u, mode %u, nHExt %u\n", gid, mode, nHExt);

      nTransfer++;
      transStat   = 0x0;
      mState    = getNextMState(mode, B2B_MFSM_S0);
      break;

    case B2B_ECADO_B2B_PREXT :                                // received: measured phase from extraction machine
      reqDeadline   = recDeadline + (uint64_t)COMMON_AHEADT;  // ECA is configured to pre-trigger ahead of time!!!
      comLatency    = (int32_t)(getSysTime() - recDeadline);
      recGid        = (uint32_t)((recId >> 48) & 0xfff     );
      recSid        = (uint32_t)((recId >> 20) & 0xfff     );

      // check, if received evtID is valid
      if (recGid != gid)            return COMMON_STATUS_OUTOFRANGE;   
      if (recSid != sid)            return COMMON_STATUS_OUTOFRANGE;
      if (mState != B2B_MFSM_EXTPR) return COMMON_STATUS_OUTOFRANGE;
      
      tH1Ext        = recParam; 

      /*
      // do some math
      sendDeadline  = tH1Ext + ((uint64_t)100000 * TH1Ext) / (uint64_t)1000000000; // project 100000 periods into the future

      // send DIAGEXT to extraction machine
      sendEvtId     = 0x1000000000000000;                                   // FID
      sendEvtId     = sendEvtId | ((uint64_t)gidTrans << 48);               // GID chk hackish 
      sendEvtId     = sendEvtId | ((uint64_t)B2B_ECADO_B2B_DIAGEXT << 36);  // EVTNO
      sendEvtId    =  sendEvtId | ((uint64_t)sidTrans << 20);               // SID
      sendParam     = 0x0;
      fwlib_ebmWriteTM(sendDeadline, sendEvtId, sendParam);
      */
      transStat |= mState;
      mState   = getNextMState(mode, mState);
      //pp_printf("b2b: PREXT %u\n", mState);
      break;

      /*case B2B_ECADO_B2B_PRINJ :
      // received: measured phase from injection machine
      // do some math
      tH1Inj        = recParam + pcFixInj + pcVarInj;
      sendDeadline  = tH1Inj + ((uint64_t)100000 * TH1Inj) / (uint64_t)1000000000; // project 100000 periods into the future
      
      // send DIAGEXT to injection machine
      sendEvtId     = 0x1000000000000000;                                       // FID
      sendEvtId    = sendEvtId | ((uint64_t)B2B_GID << 48);                 // GID chk hackish 
      sendEvtId     = sendEvtId | ((uint64_t)B2B_ECADO_B2B_DIAGINJ << 36);  // EVTNO
      sendParam     = 0x0;
      fwlib_ebmWriteTM(sendDeadline, sendEvtId, sendParam);
      
      transStat     = transStat | B2B_FLAG_TRANSPINJ;
      break;
      */

    default :
      return status;                                                          // the miniFSM is driven by ECA Events; don't continue if timeout
  } // switch ecaAction
      
  // trigger at time of EVT_KICK_START1/2 of extraction machine
  if (mState == B2B_MFSM_EXTKST) {
    tTrig      = reqDeadline;                
    transStat |= mState;
    mState   = getNextMState(mode, mState);
  } // B2B_MFSM_EXTTC

  // request phase measurement of extraction 
  if (mState == B2B_MFSM_EXTPS) {
    //TH1Ext       = (uint64_t)(*pSharedTH1ExtHi) << 32;
    //TH1Ext       = (uint64_t)(*pSharedTH1ExtLo) | TH1Ext;
    //nHExt        = *pSharedNHExt;
    tH1Ext       = 0x0;
    
    // send command: phase measurement at extraction machine
    sendEvtId    = 0x1000000000000000;                                        // FID
    sendEvtId    = sendEvtId | ((uint64_t)gid << 48);                         // GID
    sendEvtId    = sendEvtId | ((uint64_t)B2B_ECADO_B2B_PMEXT << 36);         // EVTNO
    sendEvtId    = sendEvtId | ((uint64_t)sid << 20);                         // SID
    sendEvtId    = sendEvtId | (uint64_t)(nHExt & 0xf);                       // RESERVED, use only four bits
    sendParam    = TH1Ext;
    sendDeadline = reqDeadline + 1;                                           // add 1ns to avoid collisions with EVT_KICK_START
    fwlib_ebmWriteTM(sendDeadline, sendEvtId, sendParam);
    transStat   |= mState;
    mState     = getNextMState(mode, mState);
  } // B2B_MFSM_EXTPS

  // trigger in bunch gap of extraction machine: calculate trigger time
  if (mState == B2B_MFSM_EXTBGT) {
    tWantExt     = reqDeadline + (uint64_t)COMMON_AHEADT;
    if (calcExtTime(&tTrig, tWantExt) == COMMON_STATUS_OK) {
      transStat |= mState;
      mState   = getNextMState(mode, mState);
    } // if OK
    else {
      transStat = 0x0;
      mState  = B2B_MFSM_NOTHING;
    } // if not ok    
    //pp_printf("b2b: EXTBGT %u\n", mState);
  } // B2B_MFSM_EXTTC

  // trigger extraction kicker
  if (mState == B2B_MFSM_EXTTRIG ) {
    sendGid      =  getTrigGid(1);
    if (!sendGid) return COMMON_STATUS_OUTOFRANGE;
    sendEvtId    = 0x1000000000000000;                                        // FID
    sendEvtId    = sendEvtId | ((uint64_t)sendGid << 48);                     // GID 
    sendEvtId    = sendEvtId | ((uint64_t)B2B_ECADO_B2B_TRIGGEREXT << 36);    // EVTNO
    sendEvtId    = sendEvtId | ((uint64_t)sid << 20);                         // SID
    sendParam    = 0x0;
    tTrigExt     = tTrig + cTrigExt;                                          // trigger correction
    fwlib_ebmWriteTM(tTrigExt, sendEvtId, sendParam);
    //pp_printf("todo2 %u, extTime - now %d\n", mState, (uint32_t)(sendDeadline - getSysTime()));
    transStat |= mState;
    mState   = getNextMState(mode, mState);
  } // B2B_MFSM_EXTTRIG

  // trigger injection kicker
  if (mState == B2B_MFSM_INJTRIG ) {
    sendGid      =  getTrigGid(0);
    if (!sendGid) return COMMON_STATUS_OUTOFRANGE;
    sendEvtId    = 0x1000000000000000;                                        // FID
    sendEvtId    = sendEvtId | ((uint64_t)sendGid << 48);                     // GID 
    sendEvtId    = sendEvtId | ((uint64_t)B2B_ECADO_B2B_TRIGGERINJ << 36);    // EVTNO
    sendEvtId    = sendEvtId | ((uint64_t)sid << 20);                         // SID
    sendParam    = 0x0;
    tTrigInj     = tTrig + cTrigInj;                                          // trigger correction
    fwlib_ebmWriteTM(tTrigInj, sendEvtId, sendParam);
    //pp_printf("todo2 %u, extTime - now %d\n", mState, (uint32_t)(sendDeadline - getSysTime()));
    transStat   |= mState;
    mState       = getNextMState(mode, mState);
  } // B2B_MFSM_TRIGINJ
  
      /*      
      TH1Inj          = (uint64_t)(*pSharedTH1InjHi) << 32;
      TH1Inj          = (uint64_t)(*pSharedTH1InjLo) | TH1Inj;
      nHInj           = *pSharedNHInj;
      tH1Inj          = 0x0;
      *pSharedTBeatHi = 0x0;
      *pSharedTBeatLo = 0x0;
      // pcFixExt        = *pSharedPcFixExt; chk maybes sth similar with CPHASE 

      
      // send command: phase measurement at injection machine
      sendEvtId    = 0x1000000000000000;                                        // FID
      sendEvtId    = sendEvtId | ((uint64_t)B2B_GID << 48);                 // GID chk hackish 
      sendEvtId    = sendEvtId | ((uint64_t)B2B_ECADO_B2B_PMINJ << 36);     // EVTNO
      sendEvtId    = sendEvtId | (uint64_t)(nHInj & 0xf);                       // RESERVED, use only four bits
      sendParam    = TH1Inj;
      sendDeadline = getSysTime() + (uint64_t)COMMON_AHEADT;
      fwlib_ebmWriteTM(sendDeadline, sendEvtId, sendParam);
      
      DBPRINT3("b2b-cbu: got B2B_START\n");
      
      nTransfer++;
      transStat    = B2B_FLAG_TRANSACTIVE;
      */
  
    
  /*if (transStat == (B2B_FLAG_TRANSACTIVE | B2B_FLAG_TRANSPEXTR | B2B_FLAG_TRANSPINJR)) {
    /*
    DBPRINT2("b2b: we have everything we need\n");
    
    if ((status = calcPhaseMatch(&tMatch, &TBeat)) != COMMON_STATUS_OK) {
      transStat = 0x0;
      return status;
    } // if status

    // DIAGMATCH
    sendDeadline = tMatch;                                                    // deadline
    sendEvtId    = 0x1000000000000000;                                        // FID
    sendEvtId    = sendEvtId | ((uint64_t)B2B_GID << 48);                 // GID chk hackish     
    sendEvtId    = sendEvtId | ((uint64_t)B2B_ECADO_B2B_DIAGMATCH << 36); // EVTNO
    sendParam    = 0x0;
    fwlib_ebmWriteTM(sendDeadline, sendEvtId, sendParam);

    // KICKEXT
    sendDeadline = tMatch + kcFixExt;                                         // deadline
    sendEvtId    = 0x1000000000000000;                                        // FID
    sendEvtId    = sendEvtId | ((uint64_t)B2B_GID << 48);                 // GID chk hackish     
    sendEvtId    = sendEvtId | ((uint64_t)B2B_ECADO_B2B_KICKEXT << 36);   // EVTNO
    sendParam    = 0x0;
    fwlib_ebmWriteTM(sendDeadline, sendEvtId, sendParam);

    // KICKINJ
    sendDeadline = tMatch + kcFixInj;                                         // deadline
    sendEvtId    = 0x1000000000000000;                                        // FID
    sendEvtId    = sendEvtId | ((uint64_t)B2B_GID << 48);                 // GID chk hackish     
    sendEvtId    = sendEvtId | ((uint64_t)B2B_ECADO_B2B_KICKINJ << 36);   // EVTNO
    sendParam    = 0x0;
    fwlib_ebmWriteTM(sendDeadline, sendEvtId, sendParam);

    *pSharedTBeatHi = (uint32_t)(TBeat >> 32);
    *pSharedTBeatLo = (uint32_t)(TBeat && 0xffffffff); */

  if (flagClearAllSid) {clearAllSid(); flagClearAllSid = 0;}

  return status;
} // doActionOperation


int main(void) {
  uint32_t status;                              // (error) status
  uint32_t cmd;                                 // command via shared memory
  uint32_t actState;                            // actual FSM state
  uint32_t pubState;                            // published state value
  uint32_t reqState;                            // requested FSM state
  //uint32_t dummy1;                              // dummy parameter
  uint32_t *buildID;                            // WB address of build ID

  // init local variables
  buildID        = (uint32_t *)(INT_BASE_ADR + BUILDID_OFFS);                 // required for 'stack check'

  reqState       = COMMON_STATE_S0;
  actState       = COMMON_STATE_UNKNOWN;
  pubState       = COMMON_STATE_UNKNOWN;
  status         = COMMON_STATUS_OK;
  nTransfer      = 0x0;

  init();                                                                     // initialize stuff for lm32
  fwlib_init((uint32_t *)_startshared, cpuRamExternal, SHARED_OFFS, "b2b-cbu", B2BCBU_FW_VERSION); // init common stuff
  initSharedMem();                                                            // initialize shared memory
  fwlib_clearDiag();                                                          // clear common diagnostic data

  while (1) {
    check_stack_fwid(buildID);
    fwlib_cmdHandler(&reqState, &cmd);                                        // check for commands and possibly request state changes
    cmdHandler(&reqState, cmd);                                               // check for project relevant commands
    status = COMMON_STATUS_OK;                                                // reset status for each iteration

    // state machine
    status = fwlib_changeState(&actState, &reqState, status);                 // handle requested state changes
    switch(actState) {                                                        // state specific do actions
      case COMMON_STATE_OPREADY :
        status = doActionOperation(status);
        if (status == COMMON_STATUS_WRBADSYNC)      reqState = COMMON_STATE_ERROR;
        if (status == COMMON_STATUS_ERROR)          reqState = COMMON_STATE_ERROR;
        break;
      default :                                                               // avoid flooding WB bus with unnecessary activity
        status = fwlib_doActionState(&reqState, actState, status);
        break;
    } // switch
    
    // update shared memory
    switch (status) {
      case COMMON_STATUS_OK :                                                 // status OK
        statusArray = statusArray |  (0x1 << COMMON_STATUS_OK);               // set OK bit
        break;
      default :                                                               // status not OK
        if ((statusArray >> COMMON_STATUS_OK) & 0x1) fwlib_incBadStatusCnt(); // changing status from OK to 'not OK': increase 'bad status count'
        statusArray = statusArray & ~((uint64_t)0x1 << COMMON_STATUS_OK);     // clear OK bit
        statusArray = statusArray |  ((uint64_t)0x1 << status);               // set status bit and remember other bits set
        break;
    } // switch status
    
    if ((pubState == COMMON_STATE_OPREADY) && (actState  != COMMON_STATE_OPREADY)) fwlib_incBadStateCnt();
    fwlib_publishStatusArray(statusArray);
    pubState          = actState;
    fwlib_publishState(pubState);
    fwlib_publishTransferStatus(nTransfer, 0x0, transStat);

    // update get values
    *pSharedGetGid        = gid;
    *pSharedGetSid        = sid;
    *pSharedGetMode       = mode;
    *pSharedGetTH1ExtHi   = (uint32_t)((TH1Ext >> 32) & 0xffffffff); 
    *pSharedGetTH1ExtLo   = (uint32_t)( TH1Ext        & 0xffffffff);
    *pSharedGetNHExt      = nHExt;
    *pSharedGetTH1InjHi   = (uint32_t)((TH1Inj >> 32) & 0xffffffff); 
    *pSharedGetTH1InjLo   = (uint32_t)( TH1Inj        & 0xffffffff);
    *pSharedGetNHInj      = nHInj;
    *pSharedGetCPhase     = cPhase;
    *pSharedGetCTrigExt   = cTrigExt;
    *pSharedGetCTrigInj   = cTrigInj;
    *pSharedGetTBeatHi    = (uint32_t)((TBeat >> 32) & 0xffffffff); 
    *pSharedGetTBeatLo    = (uint32_t)( TBeat        & 0xffffffff);
    *pSharedGetComLatency = comLatency;
  } // while

  return (1); // this should never happen ...
} // main
