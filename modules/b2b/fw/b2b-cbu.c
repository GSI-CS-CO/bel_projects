/********************************************************************************************
 *  b2b-cbu.c
 *
 *  created : 2019
 *  author  : Dietrich Beck, GSI-Darmstadt
 *  version : 29-Jun-2021
 *
 *  firmware implementing the CBU (Central Buncht-To-Bucket Unit)
 *  
 * -------------------------------------------------------------------------------------------
 * License Agreement for this software:
 *
 * Copyright (C) 2018  Dietrich Beck
 * GSI Helmholtzzentrum fuer Schwerionenforschung GmbH
 * Planckstrasse 1
 * D-64291 Darmstadt
 * Germany
 *
 * Contact: d.beck@gsi.de
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 3 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *  
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library. If not, see <http://www.gnu.org/licenses/>.
 *
 * For all questions and ideas contact: d.beck@gsi.de
 * Last update: 23-April-2019
 ********************************************************************************************/
#define B2BCBU_FW_VERSION 0x000300                                      // make this consistent with makefile

/* standard includes */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>
#include <stdint.h>
#include <math.h>

/* includes specific for bel_projects */
#include "dbg.h"
#include <stack.h>                                                      // stack check
#include "ebm.h"
#include "pp-printf.h"                                                  // print stuff
#include "mini_sdb.h"                                                   // sdb stuff
#include "aux.h"                                                        // cpu and IRQ
#include "uart.h"                                                       // WR console

/* includes for this project */
#include <common-defs.h>                                                // common defs
#include <common-fwlib.h>                                               // fw lib
#include <b2b.h>                                                        // defs for b2b
#include <b2bcbu_shared_mmap.h>                                         // autogenerated upon building firmware

// stuff required for environment
extern uint32_t* _startshared[];
unsigned int     cpuId, cpuQty;
#define  SHARED  __attribute__((section(".shared")))
uint64_t SHARED  dummy = 0;
volatile uint32_t *pShared;             // pointer to begin of shared memory region

// public variables; set-values are split into two parts due to a LSA requirement
// set values for a single commit, extraction 
volatile uint32_t *pSharedSetSidEExt;   // pointer to a "user defined" u32 register; here: sequence ID of extraction machine
volatile uint32_t *pSharedSetGidExt;    // pointer to a "user defined" u32 register; here: b2b group ID of extraction ring
volatile uint32_t *pSharedSetMode;      // pointer to a "user defined" u32 register; here: mode of b2b transfer
volatile uint32_t *pSharedSetTH1ExtHi;  // pointer to a "user defined" u32 register; here: period of h=1 extraction, high bits
volatile uint32_t *pSharedSetTH1ExtLo;  // pointer to a "user defined" u32 register; here: period of h=1 extraction, low bits
volatile uint32_t *pSharedSetNHExt;     // pointer to a "user defined" u32 register; here: harmonic number extraction
volatile int32_t  *pSharedSetCTrigExt;  // pointer to a "user defined" u32 register; here: correction for trigger extraction ('extraction kicker knob') [ns]
volatile int32_t  *pSharedSetNBuckExt;  // pointer to a "user defined" u32 register; here: bucket numer of extraction
volatile int32_t  *pSharedSetCPhase;    // pointer to a "user defined" u32 register; here: correction for phase matching ('phase knob') [ns]
volatile uint32_t *pSharedSetFFinTune;  // pointer to a "user defined" u32 register; here: flag: use fine tune
volatile uint32_t *pSharedSetFMBTune;   // pointer to a "user defined" u32 register; here: use multi-beat tune

// set values for a single commit, injection
volatile uint32_t *pSharedSetSidEInj;   // pointer to a "user defined" u32 register; here: sequence ID of injection machine
volatile uint32_t *pSharedSetGidInj;    // pointer to a "user defined" u32 register; here: b2b GID offset of injection ring
volatile uint32_t *pSharedSetTH1InjHi;  // pointer to a "user defined" u32 register; here: period of h=1 injection, high bits
volatile uint32_t *pSharedSetTH1InjLo;  // pointer to a "user defined" u32 register; here: period of h=1 injecion, low bits
volatile uint32_t *pSharedSetNHInj;     // pointer to a "user defined" u32 register; here: harmonic number injection
volatile int32_t  *pSharedSetCTrigInj;  // pointer to a "user defined" u32 register; here: correction for trigger injection ('injction kicker knob') [ns]
volatile int32_t  *pSharedSetNBuckInj;  // pointer to a "user defined" u32 register; here: bucket numer of injection

// set values for all SIDs; the index equals the SID
uint32_t setFlagValid[B2B_NSID];            
uint32_t setGid[B2B_NSID];
uint32_t setMode[B2B_NSID];
uint64_t setTH1Ext[B2B_NSID];
uint32_t setNHExt[B2B_NSID];
uint64_t setTH1Inj[B2B_NSID];
uint32_t setNHInj[B2B_NSID];
int32_t  setCPhase[B2B_NSID];
int32_t  setCTrigExt[B2B_NSID];
int32_t  setCTrigInj[B2B_NSID];
int32_t  setNBuckExt[B2B_NSID];
int32_t  setNBuckInj[B2B_NSID];
uint32_t setFFinTune[B2B_NSID];
uint32_t setFMBTune[B2B_NSID];

// get values
volatile uint32_t *pSharedGetSid;       // pointer to a "user defined" u32 register; here: sequence ID of extraction machine
volatile uint32_t *pSharedGetGid;       // pointer to a "user defined" u32 register; here: b2b group ID of extraction machine
volatile uint32_t *pSharedGetMode;      // pointer to a "user defined" u32 register; here: mode of b2b transfer
volatile uint32_t *pSharedGetTH1ExtHi;  // pointer to a "user defined" u32 register; here: period of h=1 extraction, high bits
volatile uint32_t *pSharedGetTH1ExtLo;  // pointer to a "user defined" u32 register; here: period of h=1 extraction, low bits
volatile uint32_t *pSharedGetNHExt;     // pointer to a "user defined" u32 register; here: harmonic number extraction
volatile uint32_t *pSharedGetTH1InjHi;  // pointer to a "user defined" u32 register; here: period of h=1 injection, high bits
volatile uint32_t *pSharedGetTH1InjLo;  // pointer to a "user defined" u32 register; here: period of h=1 injecion, low bits
volatile uint32_t *pSharedGetNHInj;     // pointer to a "user defined" u32 register; here: harmonic number injection
volatile int32_t  *pSharedGetCPhase;    // pointer to a "user defined" u32 register; here: correction for phase matching ('phase knob') [ns]
volatile int32_t  *pSharedGetCTrigExt;  // pointer to a "user defined" u32 register; here: correction for trigger extraction ('extraction kicker knob') [ns]
volatile int32_t  *pSharedGetCTrigInj;  // pointer to a "user defined" u32 register; here: correction for trigger injection ('injction kicker knob') [ns]
volatile uint32_t *pSharedGetTBeatHi;   // pointer to a "user defined" u32 register; here: period of beating, high bits
volatile uint32_t *pSharedGetTBeatLo;   // pointer to a "user defined" u32 register; here: period of beating, low bits
volatile int32_t  *pSharedGetComLatency;// pointer to a "user defined" u32 register; here: latency for messages received via ECA

uint32_t gid;                           // GID used for transfer
uint32_t sid;                           // SID user for transfer
uint32_t bpid;                          // BPID used for transfer
uint32_t mode;                          // mode for transfer
uint64_t TH1Ext;                        // h=1 period [as] of extraction machine
uint32_t nHExt;                         // harmonic number of extraction machine 0..15
uint64_t TH1Inj;                        // h=1 period [as] of injection machine
uint32_t nHInj;                         // harmonic number of injection machine 0..15
uint64_t TBeat;                         // beating frquency
int32_t  cPhase;                        // correction for phase matching [ns]
int32_t  cTrigExt;                      // correction for extraction trigger
int32_t  cTrigInj;                      // correction for injection trigger
int32_t  nBucketExt;                    // number of bucket for extraction
int32_t  nBucketInj;                    // number of bucket for injection
int      fFineTune;                     // flag: use fine tuning
int      fMBTune;                       // flag: use multi-beat tuning
uint64_t tEKS;                          // deadline of EVT_KICK_START

uint64_t tH1Ext;                        // h=1 phase  [ns] of extraction machine
uint64_t tH1Inj;                        // h=1 phase  [ns] of injection machine
int32_t  nPhaseResult;                  // number of received phase result, required to resolve diamond structure in mini FSM

uint64_t statusArray;                   // all status infos are ORed bit-wise into statusArray, statusArray is then published
uint32_t nTransfer;                     // # of transfers
uint32_t transStat;                     // status of ongoing transfer
int32_t  comLatency;                    // latency for messages received via ECA
uint32_t mState;                        // state of 'miniFSM' 

// flags
uint32_t flagClearAllSid;               // data for all SIDs shall be cleared
uint32_t errorFlags;                    // error flags, bit 0: PM Ext, bit 1: KD Ext, bit 2: PM INJ, bit 3: KD INJ, bit 4: CBU

uint32_t *cpuRamExternal;               // external address (seen from host bridge) of this CPU's RAM            

void init() // typical init for lm32
{
  discoverPeriphery();        // mini-sdb ...
  uart_init_hw();             // needed by WR console   
  cpuId = getCpuIdx();
} // init


void initSharedMem() // determine address and clear shared mem
{
  uint32_t idx;
  uint32_t *pSharedTemp;
  int      i; 
  const uint32_t c_Max_Rams = 10;
  sdb_location found_sdb[c_Max_Rams];
  sdb_location found_clu;
  
  // get pointer to shared memory
  pShared                 = (uint32_t *)_startshared;
  pSharedSetSidEExt       = (uint32_t *)(pShared + (B2B_SHARED_SET_SIDEEXT    >> 2));
  pSharedSetGidExt        = (uint32_t *)(pShared + (B2B_SHARED_SET_GIDEXT     >> 2));
  pSharedSetMode          = (uint32_t *)(pShared + (B2B_SHARED_SET_MODE       >> 2));
  pSharedSetTH1ExtHi      = (uint32_t *)(pShared + (B2B_SHARED_SET_TH1EXTHI   >> 2));
  pSharedSetTH1ExtLo      = (uint32_t *)(pShared + (B2B_SHARED_SET_TH1EXTLO   >> 2));
  pSharedSetNHExt         = (uint32_t *)(pShared + (B2B_SHARED_SET_NHEXT      >> 2));
  pSharedSetCTrigExt      =  (int32_t *)(pShared + (B2B_SHARED_SET_CTRIGEXT   >> 2));
  pSharedSetNBuckExt      = (uint32_t *)(pShared + (B2B_SHARED_SET_NBUCKEXT   >> 2));
  pSharedSetCPhase        =  (int32_t *)(pShared + (B2B_SHARED_SET_CPHASE     >> 2));
  pSharedSetFFinTune      = (uint32_t *)(pShared + (B2B_SHARED_SET_FFINTUNE   >> 2));
  pSharedSetFMBTune       = (uint32_t *)(pShared + (B2B_SHARED_SET_FMBTUNE    >> 2));
  
  pSharedSetSidEInj       = (uint32_t *)(pShared + (B2B_SHARED_SET_SIDEINJ    >> 2));
  pSharedSetGidInj        = (uint32_t *)(pShared + (B2B_SHARED_SET_GIDINJ     >> 2));
  pSharedSetTH1InjHi      = (uint32_t *)(pShared + (B2B_SHARED_SET_TH1INJHI   >> 2));
  pSharedSetTH1InjLo      = (uint32_t *)(pShared + (B2B_SHARED_SET_TH1INJLO   >> 2));
  pSharedSetNHInj         = (uint32_t *)(pShared + (B2B_SHARED_SET_NHINJ      >> 2));
  pSharedSetCTrigInj      =  (int32_t *)(pShared + (B2B_SHARED_SET_CTRIGINJ   >> 2));
  pSharedSetNBuckInj      = (uint32_t *)(pShared + (B2B_SHARED_SET_CTRIGINJ   >> 2));
  
  pSharedGetGid           = (uint32_t *)(pShared + (B2B_SHARED_GET_GID        >> 2));
  pSharedGetSid           = (uint32_t *)(pShared + (B2B_SHARED_GET_SID        >> 2));
  pSharedGetMode          = (uint32_t *)(pShared + (B2B_SHARED_GET_MODE       >> 2));
  pSharedGetTH1ExtHi      = (uint32_t *)(pShared + (B2B_SHARED_GET_TH1EXTHI   >> 2));
  pSharedGetTH1ExtLo      = (uint32_t *)(pShared + (B2B_SHARED_GET_TH1EXTLO   >> 2));
  pSharedGetNHExt         = (uint32_t *)(pShared + (B2B_SHARED_GET_NHEXT      >> 2));
  pSharedGetTH1InjHi      = (uint32_t *)(pShared + (B2B_SHARED_GET_TH1INJHI   >> 2));
  pSharedGetTH1InjLo      = (uint32_t *)(pShared + (B2B_SHARED_GET_TH1INJLO   >> 2));
  pSharedGetNHInj         = (uint32_t *)(pShared + (B2B_SHARED_GET_NHINJ      >> 2));
  pSharedGetCPhase        =  (int32_t *)(pShared + (B2B_SHARED_GET_CPHASE     >> 2));
  pSharedGetCTrigExt      =  (int32_t *)(pShared + (B2B_SHARED_GET_CTRIGEXT   >> 2));
  pSharedGetCTrigInj      =  (int32_t *)(pShared + (B2B_SHARED_GET_CTRIGINJ   >> 2));
  pSharedGetTBeatHi       = (uint32_t *)(pShared + (B2B_SHARED_GET_TBEATHI    >> 2));
  pSharedGetTBeatLo       = (uint32_t *)(pShared + (B2B_SHARED_GET_TBEATLO    >> 2));
  pSharedGetComLatency    =  (int32_t *)(pShared + (B2B_SHARED_GET_COMLATENCY >> 2));
  
  // find address of CPU from external perspective
  idx = 0;
  find_device_multi(&found_clu, &idx, 1, GSI, LM32_CB_CLUSTER);	
  idx = 0;
  find_device_multi_in_subtree(&found_clu, &found_sdb[0], &idx, c_Max_Rams, GSI, LM32_RAM_USER);
  if(idx >= cpuId) {
    cpuRamExternal           = (uint32_t *)(getSdbAdr(&found_sdb[cpuId]) & 0x7FFFFFFF); // CPU sees the 'world' under 0x8..., remove that bit to get host bridge perspective
  }

  DBPRINT2("b2b-cbu: CPU RAM External 0x%8x, begin shared 0x%08x\n", (unsigned int)cpuRamExternal, SHARED_OFFS);

  // clear shared mem
  i = 0;
  pSharedTemp        = (uint32_t *)(pShared + (COMMON_SHARED_END >> 2 ) + 1);
  while (pSharedTemp < (uint32_t *)(pShared + (B2B_SHARED_END >> 2 ))) {
    *pSharedTemp = 0x0;
    pSharedTemp++;
    i++;
  } // while pSharedTemp
  DBPRINT2("b2b-cbu: used size of shared mem is %d words, begin %x, end %x\n", i, (unsigned int)pShared, (unsigned int)pSharedTemp);
  fwlib_publishSharedSize((uint32_t)(pSharedTemp - pShared) << 2);
} // initSharedMem


void extern_clearDiag() // clears all statistics
{
  statusArray = 0x0;
  nTransfer   = 0x0;
  transStat   = 0x0;
  comLatency  = 0x0;
} // extern_clearDiag 


void clearAllSid()
{
  int i;
  for (i=0; i<B2B_NSID; i++) {
    setFlagValid[i]  = 0;            
    setGid[i]        = 0;
    setMode[i]       = 0;
    setTH1Ext[i]     = 0;
    setNHExt[i]      = 0;
    setTH1Inj[i]     = 0;
    setNHInj[i]      = 0;
    setCPhase[i]     = 0;
    setCTrigExt[i]   = 0;
    setCTrigInj[i]   = 0;
    setNBuckExt[i]   = 0;
    setNBuckInj[i]   = 0;
    setFFinTune[i]   = 0;
    setFMBTune[i]    = 0;
  } // for i
} // clearAllSid


uint32_t setSubmit()
{
  int sid;
  if (*pSharedSetSidEExt > 15)   return COMMON_STATUS_OUTOFRANGE;
  else sid = *pSharedSetSidEExt; 

  if (*pSharedSetSidEInj != sid) return COMMON_STATUS_ERROR;
  /* more checking required chk */

  setFlagValid[sid]    = 0;

  setGid[sid]          = *pSharedSetGidExt + *pSharedSetGidInj;
  setMode[sid]         = *pSharedSetMode;    
  setTH1Ext[sid]       = (uint64_t)(*pSharedSetTH1ExtHi) << 32;
  setTH1Ext[sid]       = (uint64_t)(*pSharedSetTH1ExtLo) | setTH1Ext[sid];
  setNHExt[sid]        = *pSharedSetNHExt;   
  setTH1Inj[sid]       = (uint64_t)(*pSharedSetTH1InjHi) << 32;
  setTH1Inj[sid]       = (uint64_t)(*pSharedSetTH1InjLo) | setTH1Inj[sid];
  setNHInj[sid]        = *pSharedSetNHInj;   
  setCPhase[sid]       = (int32_t)(*pSharedSetCPhase);  
  setCTrigExt[sid]     = (int32_t)(*pSharedSetCTrigExt);
  setCTrigInj[sid]     = (int32_t)(*pSharedSetCTrigInj);
  setNBuckExt[sid]     = (int32_t)(*pSharedSetNBuckExt);
  setNBuckInj[sid]     = (int32_t)(*pSharedSetNBuckInj);
  setFFinTune[sid]     = *pSharedSetFFinTune;
  setFMBTune[sid]      = *pSharedSetFMBTune;
  
  setFlagValid[sid]    = 1;
  
  pp_printf("submit %u\n", sid);
  return COMMON_STATUS_OK;
} // setSubmit


uint32_t extern_entryActionConfigured()
{
  uint32_t status = COMMON_STATUS_OK;

  fwlib_clearDiag();
  clearAllSid();

  flagClearAllSid = 0;

  // configure EB master (SRC and DST MAC/IP are set from host)
  if ((status = fwlib_ebmInit(2000, 0xffffffffffff, 0xffffffff, EBM_NOREPLY)) != COMMON_STATUS_OK) {
    DBPRINT1("b2b-cbu: ERROR - init of EB master failed! %u\n", (unsigned int)status);
    return status;
  } 

  // get and publish NIC data
  fwlib_publishNICData();

  return status;
} // extern_entryActionConfigured


uint32_t extern_entryActionOperation()
{
  int      i;
  uint64_t tDummy;
  uint64_t eDummy;
  uint64_t pDummy;
  uint32_t fDummy;
  uint32_t flagDummy;

  // clear diagnostics
  fwlib_clearDiag();             

  // flush ECA queue for lm32
  i = 0;
  while (fwlib_wait4ECAEvent(1000, &tDummy, &eDummy, &pDummy, &fDummy, &flagDummy) !=  COMMON_ECADO_TIMEOUT) {i++;}
  DBPRINT1("b2b-cbu: ECA queue flushed - removed %d pending entries from ECA queue\n", i);

  // init set values extraction
  *pSharedSetGidExt      = 0x0;     
  *pSharedSetSidEExt     = 0x0;     
  *pSharedSetMode        = 0x0;    
  *pSharedSetTH1ExtHi    = 0x0;
  *pSharedSetTH1ExtLo    = 0x0;
  *pSharedSetNHExt       = 0x0;   
  *pSharedSetCPhase      = 0x0;  
  *pSharedSetCTrigExt    = 0x0;  
  *pSharedSetCTrigInj    = 0x0;
  *pSharedSetNBuckExt    = 0x0;
  *pSharedSetFFinTune    = 0x0;
  *pSharedSetFMBTune     = 0x0;

  // init set values injection
  *pSharedSetGidInj      = 0x0;     
  *pSharedSetSidEInj     = 0x0;     
  *pSharedSetTH1InjHi    = 0x0;
  *pSharedSetTH1InjLo    = 0x0;
  *pSharedSetNHInj       = 0x0;
  *pSharedSetNBuckInj    = 0x0;
    
  // init get values
  *pSharedGetGid         = 0x0;
  *pSharedGetSid         = 0x0;
  *pSharedGetMode        = 0x0;
  *pSharedGetTH1ExtHi    = 0x0; 
  *pSharedGetTH1ExtLo    = 0x0;
  *pSharedGetNHExt       = 0x0;
  *pSharedGetTH1InjHi    = 0x0;
  *pSharedGetTH1InjLo    = 0x0;
  *pSharedGetNHInj       = 0x0;
  *pSharedGetCPhase      = 0x0;
  *pSharedGetCTrigExt    = 0x0;
  *pSharedGetCTrigInj    = 0x0;
  *pSharedGetTBeatHi     = 0x0;
  *pSharedGetTBeatLo     = 0x0;
  *pSharedGetComLatency  = 0x0;

  return COMMON_STATUS_OK;
} // extern_entryActionOperation


uint32_t extern_exitActionOperation()
{
  return COMMON_STATUS_OK;
} // extern_exitActionOperation


uint32_t getTrigGid(uint32_t extFlag)
{
  uint32_t trigGid;

  switch (gid) {
    case SIS18_B2B_EXTRACT :
      if (extFlag) trigGid = SIS18_RING;
      else         trigGid = GID_INVALID;
      break;
    case SIS18_B2B_ESR :
      if (extFlag) trigGid = SIS18_RING;
      else         trigGid = ESR_RING;
      break;
    case ESR_B2B_EXTRACT :
      if (extFlag) trigGid = ESR_RING;
      else         trigGid = GID_INVALID;
      break;
    case ESR_B2B_CRYRING :
      if (extFlag) trigGid = ESR_RING;
      else         trigGid = CRYRING_RING;
      break;
    default :
      trigGid = GID_INVALID;
  } // switch gid

  return trigGid;
} // getTrigGid


uint32_t calcExtTime(uint64_t *tExtract, uint64_t tWant)
{
  uint32_t period;
  
  // check for unreasonable values
  if (TH1Ext == 0)                   return COMMON_STATUS_OUTOFRANGE;          // no value for period
  if (nHExt  == 0)                   return COMMON_STATUS_OUTOFRANGE;          // no value for harmonic number
  if ((tH1Ext + (1 << 30)) < tWant)  return COMMON_STATUS_OUTOFRANGE;          // value older than approximately 1s
  
  *tExtract = fwlib_advanceTime(tH1Ext, tWant, TH1Ext);
  if (*tExtract == 0)                return COMMON_STATUS_OUTOFRANGE;

  return COMMON_STATUS_OK;
} // calcExtTime


// send event for MIL busses; this is intended for the WR->MIL Gateways for the timing groups ESR_RING and SIS18_RING
void sendMilTrigger(uint64_t deadline, uint32_t gid, uint32_t sid)
{
#ifdef USEMIL
  uint64_t sendEvtId;                               // evtID to send
  uint32_t evtNo;                                   // evtNo to send

  switch (gid) {
    case SIS18_RING :
      evtNo = B2B_ECADO_B2B_TRIGGERSIS;
      break;
    case ESR_RING :
      evtNo = B2B_ECADO_B2B_TRIGGERESR;
      break;
    default :
      return;
  } // switch gid
      
  sendEvtId = fwlib_buildEvtidV1(gid, evtNo, 0, sid, 0, 0); 
  fwlib_ebmWriteTM(deadline, sendEvtId, 0, 0);
#endif
} // sendMilTrigger


// fine tune for individual h=1 cycles
void rfFineTune(uint64_t tH1ExtAs, uint64_t tH1InjAs, uint64_t *tMatch, uint64_t *dt)
{
  uint64_t half;                                    // helper variable
  uint64_t nDiff;                                   // # we need project Tdiff into the future
  
  uint64_t ftTExt;                                  // fine tune extraction period
  uint64_t ftTInj;                                  // fine tune injection period
  uint64_t ftMatchExt;                              // fine tune match for extraction
  uint64_t ftMatchInj;                              // fine tune match for injection
  int64_t  ftDt1;                                   // fine tune differences ...
  int64_t  ftDt2;
  int64_t  ftDt3;

  // fine tuning; align to 'common' multiple of TH1
  // algorithm: compare match for previous, actual and next iteration
  // calculate common multiples of h=1 for each ring
  ftTExt = TH1Ext * nHInj;
  ftTInj = TH1Inj * nHExt;

  // ftMatch extraction, use input value as reference
  half        = TH1Ext >> 1;
  nDiff       = (*tMatch - tH1ExtAs) / TH1Ext;
  if (((*tMatch - tH1ExtAs) % TH1Ext) > half) nDiff++;
  ftMatchExt  = tH1ExtAs + nDiff * TH1Ext;

  // ftMatch injection; use extraction match as reference
  half   = TH1Inj >> 1;
  nDiff  = (ftMatchExt - tH1InjAs) / TH1Inj;
  if (((ftMatchExt - tH1InjAs) % TH1Inj) > half) nDiff++;
  ftMatchInj  = tH1InjAs + nDiff * TH1Inj;

  //pp_printf("huhu tMatchExt %lu, tMatchInj %lu\n", (uint32_t)(ftMatchExt / 1000000000), (uint32_t)(ftMatchInj / 1000000000));
  
  // calc differences, alignment to extraction
  ftDt1 = (int64_t)(ftMatchExt - ftTExt) - (int64_t)(ftMatchInj - ftTInj);
  ftDt2 = (int64_t)(ftMatchExt)          - (int64_t)(ftMatchInj);
  ftDt3 = (int64_t)(ftMatchExt + ftTExt) - (int64_t)(ftMatchInj + ftTInj);

  // decide which is best
  *tMatch = ftMatchExt;
  *dt     = ftDt2;
  if (llabs(ftDt1) < llabs(ftDt2)) {*tMatch = ftMatchExt - ftTExt; *dt = ftDt1;}
  if (llabs(ftDt3) < llabs(ftDt2)) {*tMatch = ftMatchExt + ftTExt; *dt = ftDt3;}
  //pp_printf("fine tune dt1 %ld, dt2 %ld, dt3 %ld\n", (int32_t)(ftDt1/1000000), (int32_t)(ftDt2/1000000), (int32_t)(ftDt3/1000000));
} // rfFineTune


uint32_t calcPhaseMatch(uint64_t tMin, uint64_t *tPhaseMatch, uint64_t *TBeat)  // calculates when extraction and injection machines are synchronized
{
  uint64_t TSlow;                                   // period of 'slow' RF signal               [as] // sic! atoseconds
  uint64_t TFast;                                   // period of 'fast' signal                  [as]
  uint64_t TRfExt;                                  // period of RF signal extraction           [as]
  uint64_t TRfInj;                                  // period of RF signal injection            [as]
  uint64_t tSlow;                                   // 0 phase of 'slow' H=1 signal             [as]
  uint64_t tFast;                                   // 0 phase of 'fast' H=1 signal             [as]
  uint64_t tH1ExtAs;                                // 0 phase of H=1 signal extraction         [as]
  uint64_t tH1InjAs;                                // 0 phase of H=1 signal injection          [as]
  uint64_t Tdiff;                                   // difference of true RF periods            [as]
  uint64_t nDiff;                                   // # we need project Tdiff into the future  
  uint64_t tMatch;                                  // 0 phase of best match                    [as]
  uint64_t tD0;                                     // tFast - tSlow                            [as]
  uint64_t tMatchNs;                                // 'tMatch' in units of [ns]                [ns]
  uint64_t epoch;                                   // temporary epoch                          [ns] (!)
  uint64_t tNow;                                    // current time                             [ns] (!)
  uint64_t nineO = 1000000000;                      // nine orders of magnitude, needed for conversion
  uint64_t half;                                    // helper variable
  uint32_t nExtAdv;                                 // number of h=1 periods required to advance tH1Ext
  uint32_t nInjAdv;                                 // number of h=1 periods required to advance tH1Inj

  // parameters for 'best bunch probing'
#define LIMITFINETUNE  360                          // do fine tuning if number of h=1 periods within beating is below this number
#define LIMITMULTIBEAT 120                          // do tuning with multiple beats if number of h=1 periods within beating is below this number
  uint64_t nH1BeatExt;                              // number of h=1 periods within beating period extraction
  int      i;
  int      nProbes;                                 // number of probes
  int64_t  dt, dtTmp;                               // achieved precision, temporary variable
  uint64_t tMatch0, tMatchTmp;                      // temporary variables
  

  

  // define temporary epoch [ns]
  tNow    = getSysTime();
  epoch   = tNow - nineO * 1;                       // subtracting one second should be safe

  DBPRINT3("b2b-cbu: tNow - tH1Ext %u ns, tNow - tH1inj %u ns, nHExt %u, nHInj %u\n", (unsigned int)(tNow - tH1Ext), (unsigned int)(tNow - tH1Inj), nHExt, nHInj);

  // check for unreasonable values
  if (TH1Ext == 0)                      return COMMON_STATUS_OUTOFRANGE;           // no value for period
  if (TH1Inj == 0)                      return COMMON_STATUS_OUTOFRANGE;           // no value for period
  if (nHExt  == 0)                      return COMMON_STATUS_OUTOFRANGE;           // no value for harmonic number
  if (nHInj  == 0)                      return COMMON_STATUS_OUTOFRANGE;           // no value for harmonic number
  if (TH1Inj == 0)                      return COMMON_STATUS_OUTOFRANGE;           // no value for period
  if ((tH1Ext + nineO * 0.1) < tNow)    return COMMON_STATUS_OUTOFRANGE;           // value older than 100ms
  if ((tH1Inj + nineO * 0.1) < tNow)    return COMMON_STATUS_OUTOFRANGE;           // value older than 100ms

  TRfExt = TH1Ext / nHExt;
  TRfInj = TH1Inj / nHInj;

  if (TRfExt == TRfInj)                 return COMMON_STATUS_OUTOFRANGE;           // no beating

  tH1ExtAs  = (tH1Ext - epoch) * nineO;
  tH1InjAs  = (tH1Inj - epoch) * nineO;

  // advance measured phase to approximate time of kick
  // this should prevent adding additional beating times in case of short beating periods
  nExtAdv   = 1000000000.0 * (tMin - tH1Ext) / TH1Ext;
  nInjAdv   = 1000000000.0 * (tMin - tH1Inj) / TH1Inj;
  tH1ExtAs += nExtAdv * TH1Ext;
  tH1InjAs += nInjAdv * TH1Inj;

  // assign local values and convert times 't' to [as], periods 'T' are already in [as])
  if (TRfExt > TRfInj) {
    TSlow   = TRfExt;
    tSlow   = tH1ExtAs;

    TFast   = TRfInj;
    tFast   = tH1InjAs;
  } // if extraction has lower frequency
  else {
    TSlow   = TRfInj;
    tSlow   = tH1InjAs;

    TFast   = TRfExt;
    tFast   = tH1ExtAs;
  } // if etraction has higher frequency

  // make sure tSlow is earlier than tFast; this is a must for the formula below
  while (tSlow > tFast)           tFast = tFast + TFast;

  // make sure spacing between tSlow and tFast is not too large; otherwise we need to wait for too long
  while ((tFast - tSlow) > TFast) tFast = tFast - TFast;

  // now, tSlow is earlier than tFast and both values are at most one period apart; we can now start our calculation
  tD0      = tFast - tSlow;                             // difference between timestamps
  Tdiff    = TSlow - TFast;                             // difference between periods (higher harmonics RF)
  half     = Tdiff >> 1;                                // required for rounding
  nDiff    = tD0 / Tdiff;                               // this basically does a 'floor()'
  if ((tD0 % Tdiff) > half) nDiff++;                    // do a better job with rounding 
  tMatch   = nDiff * TSlow + tSlow;              

  *TBeat   = (TSlow / Tdiff);                           // beating period
  if ((*TBeat % Tdiff) > half) *TBeat++;
  *TBeat   = *TBeat * TSlow;
  
  //tmp = tFast; pp_printf("b2b: tmp %llu\n", tmp);
  //pp_printf("b2b-cbu: nProject %llu, tD0 %llu, Tdiff %llu\n", nProject, tD0, Tdiff);

  // check, that tMatch is far enough in the future; if not, add one -> chk --> sufficient beating periods
  while ((tMatch / nineO + epoch) < tMin) tMatch += *TBeat; 

  // if the injection ring is larger than the extraction ring
  // we need to align to the injection H=1 group DDS first
  if (nHInj > nHExt) {
    half   = TH1Inj >> 1;
    nDiff  = (tMatch - tH1InjAs) / TH1Inj;
    if (((tMatch - tH1InjAs) % TH1Inj) > half) nDiff++;
    tMatch  = tH1InjAs + nDiff * TH1Inj;
  } // if injection ring is larger
  //pp_printf("TH1Inj %llu, nPeriod %llu, nHInj %u, flagExtSlow %d\n", TH1Inj, nPeriod, nHInj, flagExtSlow);
  
  // fine tuning and multi-beat tuning; the following code and parameters are for SIS18->ESR 
  dt      = 999999999999;
  tMatch0 = tMatch;
  nH1BeatExt = *TBeat / TH1Ext;
  nProbes = 1;                                             // enable fine-tuning
  if (nH1BeatExt < LIMITFINETUNE)  nProbes = 2;            // enable multi-beat tuning for one ring revolution (chk: hackish h = 2)
  if (nH1BeatExt < LIMITMULTIBEAT) nProbes = nProbes * 3;  // enable multi-beat tuning (chk: hackish try 3 complete revolutions)

  for (i=0; i < nProbes; i++) {
    // advance to next bucket (unless in first iteration)
    tMatchTmp = tMatch0 + (uint64_t)i * *TBeat;

    // fine tune (and align to extraction ring) and check for improved value
    rfFineTune(tH1ExtAs, tH1InjAs, &tMatchTmp, &dtTmp);
    if (llabs(dtTmp) < llabs(dt)) {
      tMatch = tMatchTmp;
      dt     = dtTmp;
    } // if dtTmp
  } // for i
  
  // convert back to TAI [ns]
  tMatchNs     = (uint64_t)((double)tMatch / (double)nineO);
  *tPhaseMatch =  tMatchNs + epoch;

  return COMMON_STATUS_OK;    
} // calcPhaseMatch


// command handler, handles commands specific for this project
void cmdHandler(uint32_t *reqState, uint32_t cmd)
{
  // check, if the command is valid and request state change
  if (cmd) {                             // check, if cmd is valid
    switch (cmd) {                       // do action according to command
      case B2B_CMD_CONFSUBMIT :
        DBPRINT3("b2b: received cmd %d\n", cmd);
        if (setSubmit() != COMMON_STATUS_OK) DBPRINT1("b2b: submission of config data failed\n");
        break;
      case B2B_CMD_CONFCLEAR :
        DBPRINT3("b2b: received cmd %d\n", cmd);
        flagClearAllSid = 1;
        break;
      default:
        DBPRINT3("b2b: received unknown command '0x%08x'\n", cmd);
        break;
    } // switch 
  } // if command 
} // cmdHandler


uint32_t getNextMState(uint32_t mode, uint32_t actMState) {
  uint32_t nextMState = B2B_MFSM_NOTHING;

  switch (mode) {
    case B2B_MODE_KSE :  // extraction beam now!
      switch (actMState) {
        case B2B_MFSM_S0 :
          nextMState =  B2B_MFSM_EXTKST;
          break;
        case B2B_MFSM_EXTKST :
          nextMState =  B2B_MFSM_EXTTRIG;
          break;
        case B2B_MFSM_EXTTRIG :
          nextMState = B2B_MFSM_NOTHING;
          break;
        default:
          nextMState = B2B_MFSM_NOTHING;
      } // switch actMState mode KSE
      break;
    case B2B_MODE_B2E :  // bunch to extraction
      switch (actMState) {
        case B2B_MFSM_S0 :
          nextMState = B2B_MFSM_EXTPS;
          break;
        case  B2B_MFSM_EXTPS :
          nextMState = B2B_MFSM_EXTPR;
          break;
        case B2B_MFSM_EXTPR :
          nextMState = B2B_MFSM_EXTBGT;
          break;
        case B2B_MFSM_EXTBGT :
          nextMState = B2B_MFSM_EXTTRIG;
          break;
        case B2B_MFSM_EXTTRIG :
          nextMState = B2B_MFSM_NOTHING;
          break;
        default :
          nextMState = B2B_MFSM_NOTHING;
      } // switch actMState mode B2E
      break;
    case B2B_MODE_B2C :  // bunch to coasting beam
      switch (actMState) {
        case B2B_MFSM_S0 :
          nextMState = B2B_MFSM_EXTPS;
          break;
        case  B2B_MFSM_EXTPS :
          nextMState = B2B_MFSM_EXTPR;
          break;
        case B2B_MFSM_EXTPR :
          nextMState = B2B_MFSM_EXTBGT;
          break;
        case B2B_MFSM_EXTBGT :
          nextMState = B2B_MFSM_EXTTRIG;
          break;
        case B2B_MFSM_EXTTRIG :
          nextMState = B2B_MFSM_INJTRIG ;
          break;
        case B2B_MFSM_INJTRIG :
          nextMState = B2B_MFSM_NOTHING;
          break;
        default :
          nextMState = B2B_MFSM_NOTHING;
      } // switch actMState mode B2C
      break;
    case B2B_MODE_B2B :  // bunch to bucket
      switch (actMState) {
        case B2B_MFSM_S0 :
          nextMState = B2B_MFSM_EXTPS;
          break;
        case B2B_MFSM_EXTPS :
          nextMState = B2B_MFSM_INJPS;
          break;
        case B2B_MFSM_INJPS :
          nPhaseResult = 0;     
          nextMState = B2B_MFSM_BOTHPR;
          break;                           
        case B2B_MFSM_BOTHPR :                                      // we have a diamond structure: we request two phase measurements
          nPhaseResult++;                                           // but we don't know which result is received first; the simplest 
          if (nPhaseResult == 2) nextMState = B2B_MFSM_EXTMATCHT;   // solution is to use a counter and count to 2
          else                   nextMState = B2B_MFSM_BOTHPR;
          break;
        case B2B_MFSM_EXTMATCHT :
          nextMState = B2B_MFSM_EXTTRIG;
          break;
        case B2B_MFSM_EXTTRIG :
          nextMState = B2B_MFSM_INJTRIG ;
          break;
        case B2B_MFSM_INJTRIG :
          nextMState = B2B_MFSM_NOTHING;
          break;
        default :
          nextMState = B2B_MFSM_NOTHING;
      } // switch actMState mode B2C
      break;
      
    default :
      nextMState = B2B_MFSM_NOTHING;
  } // switch mode

  //if (!nextMState) pp_printf("mode %x, actMState %x\n", mode, actMState);

  return nextMState;
} // getNextMState


uint32_t doActionOperation(uint32_t actStatus)                // actual status of firmware
{
  uint32_t status;                                            // status returned by routines
  uint32_t flagIsLate;                                        // flag indicating that we received a 'late' event from ECA
  uint32_t ecaAction;                                         // action triggered by event received from ECA
  uint64_t sendDeadline;                                      // deadline to send
  uint64_t sendEvtId;                                         // evtID to send
  uint64_t sendParam;                                         // param to send
  uint32_t sendGid;                                           // GID to send
  uint64_t recDeadline;                                       // deadline received
  uint64_t reqDeadline;                                       // deadline requested by sender
  uint64_t recId;                                             // evt ID received
  uint64_t recParam;                                          // param received
  uint32_t recTEF;                                            // TEF received
  uint32_t recGid;                                            // GID received
  uint32_t recSid;                                            // SID received
  uint32_t recRes;                                            // reserved bits received
  uint64_t tMatch;                                            // time when phases of injecion and extraction match
  uint64_t tWantExt;                                          // approximate time of extraction
  uint64_t tTrig;                                             // time when kickers shall be triggered
  uint64_t tTrigExt;                                          // time when extraction kicker shall be triggered; tTrigExt = tTrig + cTrigExt;
  uint64_t tTrigInj;                                          // time when injection kicker shall be triggered;  tTrigInj = tTrig + cTrigInj;
  int32_t  offsetDone;                                        // offset from deadline EKS to time, when extraction trigger is sent

  status = actStatus;

  ecaAction = fwlib_wait4ECAEvent(COMMON_ECATIMEOUT*1000, &recDeadline, &recId, &recParam, &recTEF, &flagIsLate);
    
  switch (ecaAction) {

    case B2B_ECADO_KICKSTART :                                // received: EVT_KICK_START1/2 from DM; B2B transfer starts
      reqDeadline = recDeadline + (uint64_t)COMMON_AHEADT;    // ECA is configured to pre-trigger ahead of time!!!
      comLatency  = (int32_t)(getSysTime() - recDeadline);

      sid        = (uint32_t)(recId >> 20) & 0xfff;
      gid        = 0x0;
      bpid       = 0x0;
      mode       = 0x0;
      nHExt      = 0x0;
      nHInj      = 0x0;
      TH1Ext     = 0x0;
      TH1Inj     = 0x0;
      TBeat      = 0x0;
      cPhase     = 0x0;
      cTrigExt   = 0x0;
      cTrigInj   = 0x0;
      nBucketExt = 0x0;
      nBucketInj = 0x0;
      fFineTune  = 0x0;
      fMBTune    = 0x0;
      tEKS       = 0x0;

      transStat  = 0x0;

      
      if (sid > 15)  {sid = 0; mState = B2B_MFSM_NOTHING; return status;}
      if (!setFlagValid[sid]) {mState = B2B_MFSM_NOTHING; return status;}
      gid        = setGid[sid]; 
      /*bpid       = 0x2000;        chk                            // bit    13: indicate 'b2b' (bit 12: reserved)
      /bpid      |= (gid & 0xff) << 4;                         // bit 4..11: use relevant bits of GID
      bpid      |= nTransfer & 0xf;                       */    // bit 0..3 : 4 bit counter of transfers
      mode       = setMode[sid];
      TH1Ext     = setTH1Ext[sid];
      nHExt      = setNHExt[sid];
      TH1Inj     = setTH1Inj[sid];
      nHInj      = setNHInj[sid];
      cPhase     = setCPhase[sid];
      cTrigExt   = setCTrigExt[sid];
      cTrigInj   = setCTrigInj[sid];
      nBucketExt = setNBuckExt[sid];
      nBucketInj = setNBuckInj[sid];
      fFineTune  = setFFinTune[sid];
      fMBTune    = setFMBTune[sid];

      tEKS       = reqDeadline;
      nTransfer++;
      mState     = getNextMState(mode, B2B_MFSM_S0);
      errorFlags = 0x0;
      break;

    case B2B_ECADO_B2B_PREXT :                                // received: measured phase from extraction machine
      reqDeadline   = recDeadline + (uint64_t)COMMON_AHEADT;  // ECA is configured to pre-trigger ahead of time!!!
      comLatency    = (int32_t)(getSysTime() - recDeadline);
      recGid        = (uint32_t)((recId >> 48) & 0xfff     );
      recSid        = (uint32_t)((recId >> 20) & 0xfff     );
      recRes        = (uint32_t)(recId & 0x3f);               // lowest 6 bit of EvtId

      // check, if received evtID is valid
      if (recGid != gid)                                             return COMMON_STATUS_OUTOFRANGE;   
      if (recSid != sid)                                             return COMMON_STATUS_OUTOFRANGE;
      if ((mState != B2B_MFSM_EXTPR) && (mState != B2B_MFSM_BOTHPR)) return COMMON_STATUS_OUTOFRANGE;

      // handling error bits
      if (recRes & B2B_ERRFLAG_PMEXT) errorFlags |= B2B_ERRFLAG_PMEXT;
      
      tH1Ext        = recParam; 
      transStat    |= mState;
      mState        = getNextMState(mode, mState);
      //pp_printf("b2b: PREXT %u\n", mState);
      break;

    case B2B_ECADO_B2B_PRINJ :                                // received: measured phase from injection machine
      reqDeadline   = recDeadline + (uint64_t)COMMON_AHEADT;  // ECA is configured to pre-trigger ahead of time!!!
      comLatency    = (int32_t)(getSysTime() - recDeadline);
      recGid        = (uint32_t)((recId >> 48) & 0xfff     );
      recSid        = (uint32_t)((recId >> 20) & 0xfff     );
      recRes        = (uint32_t)(recId & 0x3f);               // lowest 6 bit of EvtId

      // check, if received evtID is valid
      if (recGid != gid)             return COMMON_STATUS_OUTOFRANGE;   
      if (recSid != sid)             return COMMON_STATUS_OUTOFRANGE;
      if (mState != B2B_MFSM_BOTHPR) return COMMON_STATUS_OUTOFRANGE;

      // handling error bits
      if (recRes & B2B_ERRFLAG_PMINJ) errorFlags |= B2B_ERRFLAG_PMINJ;
      
      tH1Inj        = recParam;
      tH1Inj       -= cPhase;
      transStat    |= mState;
      mState        = getNextMState(mode, mState);
      //pp_printf("b2b: PRINJ %u\n", mState);
      break;

    default :
      return status;                                          // the miniFSM is driven by ECA Events; don't continue if timeout
  } // switch ecaAction
      
  // trigger at time of EVT_KICK_START1/2 of extraction machine
  if (mState == B2B_MFSM_EXTKST) {
    tTrig      = reqDeadline;                
    transStat |= mState;
    mState   = getNextMState(mode, mState);
  } // B2B_MFSM_EXTTC

  // request phase measurement of extraction 
  if (mState == B2B_MFSM_EXTPS) {
    tH1Ext       = 0x0;
    
    // send command: phase measurement at extraction machine
    sendEvtId    = fwlib_buildEvtidV1(gid, B2B_ECADO_B2B_PMEXT, 0, sid, bpid, 0); 
    sendParam    = TH1Ext & 0x00ffffffffffffff;                               // use low 56 bit as period
    sendParam    = sendParam | ((uint64_t)(nHExt & 0xff) << 56);              // use upper 8 bit as harmonic number 
    sendDeadline = reqDeadline + 1;                                           // add 1ns to avoid collisions with EVT_KICK_START
    fwlib_ebmWriteTM(sendDeadline, sendEvtId, sendParam, 0);
    transStat   |= mState;
    mState       = getNextMState(mode, mState);
  } // B2B_MFSM_EXTPS

  // request phase measurement of injection
  if (mState == B2B_MFSM_INJPS) {
    tH1Ext       = 0x0;
    
    // send command: phase measurement at injection machine
    sendEvtId    = fwlib_buildEvtidV1(gid, B2B_ECADO_B2B_PMINJ, 0, sid, bpid, 0); 
    sendParam    = TH1Inj & 0x00ffffffffffffff;                               // use low 56 bit as period
    sendParam    = sendParam | ((uint64_t)(nHInj & 0xff) << 56);              // use upper 8 bit as harmonic number 
    sendDeadline = reqDeadline + 2;                                           // add 2ns to avoid collisions with EVT_KICK_START or CMD_B2B_PMEXT
    fwlib_ebmWriteTM(sendDeadline, sendEvtId, sendParam, 0);
    transStat   |= mState;
    mState     = getNextMState(mode, mState);
  } // B2B_MFSM_INJPS

  // prepare fast extraction in bunch gap: calculate trigger time
  if (mState == B2B_MFSM_EXTBGT) {
    tWantExt = reqDeadline + (uint64_t)COMMON_AHEADT;
    if (errorFlags) tTrig = tWantExt;                                         // plan B
    else if (calcExtTime(&tTrig, tWantExt) != COMMON_STATUS_OK) {
      tTrig       = tWantExt;                                                 // plan B
      errorFlags |= B2B_ERRFLAG_CBU;
    } // if NOT STATUS_OK
      
    transStat |= mState;
    mState     = getNextMState(mode, mState);
  } // B2B_MFSM_EXTBGT

  // prepare fast extraction with phase matching between both machines is achieved: calculate trigger time
  if (mState == B2B_MFSM_EXTMATCHT) {
    tWantExt = reqDeadline + (uint64_t)COMMON_AHEADT;    
    if (errorFlags) tTrig =  tWantExt;                                        // plan B
    else if ((status = calcPhaseMatch(tWantExt, &tTrig, &TBeat)) != COMMON_STATUS_OK) {
        tTrig       = tWantExt;                                               // plan B
        errorFlags |= B2B_ERRFLAG_CBU;
        /* pp_printf("b2b: error match algorithm, TBeat %lu\n", (uint32_t)(TBeat)); */
    } // if NOT STATUS_OK
    transStat |= mState;
    mState     = getNextMState(mode, mState);
  } // B2B_MFSM_EXTMATCHT

  // trigger extraction kicker
  if (mState == B2B_MFSM_EXTTRIG ) {
    sendGid      =  getTrigGid(1);
    if (!sendGid) return COMMON_STATUS_OUTOFRANGE;
    tTrigExt     = tTrig + cTrigExt;                                          // trigger correction
    if (tTrigExt < getSysTime() + (uint64_t)(COMMON_LATELIMIT)) errorFlags |= B2B_ERRFLAG_CBU;  // set error flag in case we are too late
    offsetDone   = (int32_t)(getSysTime() - tEKS);

    sendEvtId    = fwlib_buildEvtidV1(sendGid, B2B_ECADO_B2B_TRIGGEREXT, 0, sid, bpid, errorFlags);
    sendParam    = ((uint64_t)(offsetDone & 0xffffffff) << 32);               // param field, offset to EKS
    sendParam   |=    (uint64_t)(cTrigExt & 0xffffffff);                      // param field, cTrigExt as low word
    fwlib_ebmWriteTM(tTrigExt, sendEvtId, sendParam, 0);
    sendMilTrigger(tTrigExt+8, sendGid, sid);                                 // send trigger event to MIL Bus via WR->MIL Gateway
    transStat |= mState;
    mState   = getNextMState(mode, mState);
  } // B2B_MFSM_EXTTRIG

  // trigger injection kicker
  if (mState == B2B_MFSM_INJTRIG ) {
    sendGid      =  getTrigGid(0);
    if (!sendGid) return COMMON_STATUS_OUTOFRANGE;
    tTrigInj     = tTrig + cTrigInj;                                          // trigger correction
    if (tTrigExt < getSysTime() + (uint64_t)(COMMON_LATELIMIT)) errorFlags |= B2B_ERRFLAG_CBU;  // set error flag in case we are too late

    sendEvtId    = fwlib_buildEvtidV1(sendGid, B2B_ECADO_B2B_TRIGGERINJ, 0, sid, bpid, errorFlags);
    sendParam    = ((uint64_t)cPhase & 0xffffffff) << 32;                     // param field, cPhase as high word
    sendParam    = sendParam | ((uint64_t)cTrigInj & 0xffffffff);             // param field, cTrigInj as low word 
    fwlib_ebmWriteTM(tTrigInj, sendEvtId, sendParam, 0);
    sendMilTrigger(tTrigInj+8, sendGid, sid);                                 // send trigger event to MIL Bus via WR->MIL Gateway
    transStat   |= mState;
    mState       = getNextMState(mode, mState);
  } // B2B_MFSM_TRIGINJ
  
  if (flagClearAllSid) {clearAllSid(); flagClearAllSid = 0;}

  // check for late event
  if ((status == COMMON_STATUS_OK) && flagIsLate) status = B2B_STATUS_LATEMESSAGE;
  
  // check WR sync state; worst case, do this last
  if (fwlib_wrCheckSyncState() == COMMON_STATUS_WRBADSYNC) return COMMON_STATUS_WRBADSYNC;
  else                                                     return status;
} // doActionOperation


int main(void) {
  uint32_t status;                              // (error) status
  uint32_t cmd;                                 // command via shared memory
  uint32_t actState;                            // actual FSM state
  uint32_t pubState;                            // published state value
  uint32_t reqState;                            // requested FSM state
  //uint32_t dummy1;                              // dummy parameter
  uint32_t *buildID;                            // WB address of build ID

  // init local variables
  buildID        = (uint32_t *)(INT_BASE_ADR + BUILDID_OFFS);                 // required for 'stack check'

  reqState       = COMMON_STATE_S0;
  actState       = COMMON_STATE_UNKNOWN;
  pubState       = COMMON_STATE_UNKNOWN;
  status         = COMMON_STATUS_OK;
  nTransfer      = 0x0;

  init();                                                                     // initialize stuff for lm32
  fwlib_init((uint32_t *)_startshared, cpuRamExternal, SHARED_OFFS, "b2b-cbu", B2BCBU_FW_VERSION); // init common stuff
  initSharedMem();                                                            // initialize shared memory
  fwlib_clearDiag();                                                          // clear common diagnostic data

  while (1) {
    check_stack_fwid(buildID);
    fwlib_cmdHandler(&reqState, &cmd);                                        // check for commands and possibly request state changes
    cmdHandler(&reqState, cmd);                                               // check for project relevant commands
    status = COMMON_STATUS_OK;                                                // reset status for each iteration

    // state machine
    status = fwlib_changeState(&actState, &reqState, status);                 // handle requested state changes
    switch(actState) {                                                        // state specific do actions
      case COMMON_STATE_OPREADY :
        status = doActionOperation(status);
        if (status == COMMON_STATUS_WRBADSYNC)      reqState = COMMON_STATE_ERROR;
        if (status == COMMON_STATUS_ERROR)          reqState = COMMON_STATE_ERROR;
        break;
      default :                                                               // avoid flooding WB bus with unnecessary activity
        status = fwlib_doActionState(&reqState, actState, status);
        break;
    } // switch
    
    // update shared memory
    switch (status) {
      case COMMON_STATUS_OK :                                                 // status OK
        statusArray = statusArray |  (0x1 << COMMON_STATUS_OK);               // set OK bit
        break;
      default :                                                               // status not OK
        if ((statusArray >> COMMON_STATUS_OK) & 0x1) fwlib_incBadStatusCnt(); // changing status from OK to 'not OK': increase 'bad status count'
        statusArray = statusArray & ~((uint64_t)0x1 << COMMON_STATUS_OK);     // clear OK bit
        statusArray = statusArray |  ((uint64_t)0x1 << status);               // set status bit and remember other bits set
        break;
    } // switch status
    
    if ((pubState == COMMON_STATE_OPREADY) && (actState  != COMMON_STATE_OPREADY)) fwlib_incBadStateCnt();
    fwlib_publishStatusArray(statusArray);
    pubState          = actState;
    fwlib_publishState(pubState);
    fwlib_publishTransferStatus(nTransfer, 0x0, transStat);

    // update get values
    *pSharedGetGid        = gid;
    *pSharedGetSid        = sid;
    *pSharedGetMode       = mode;
    *pSharedGetTH1ExtHi   = (uint32_t)((TH1Ext >> 32) & 0xffffffff); 
    *pSharedGetTH1ExtLo   = (uint32_t)( TH1Ext        & 0xffffffff);
    *pSharedGetNHExt      = nHExt;
    *pSharedGetTH1InjHi   = (uint32_t)((TH1Inj >> 32) & 0xffffffff); 
    *pSharedGetTH1InjLo   = (uint32_t)( TH1Inj        & 0xffffffff);
    *pSharedGetNHInj      = nHInj;
    *pSharedGetCPhase     = cPhase;
    *pSharedGetCTrigExt   = cTrigExt;
    *pSharedGetCTrigInj   = cTrigInj;
    *pSharedGetTBeatHi    = (uint32_t)((TBeat >> 32) & 0xffffffff); 
    *pSharedGetTBeatLo    = (uint32_t)( TBeat        & 0xffffffff);
    *pSharedGetComLatency = comLatency;
  } // while

  return (1); // this should never happen ...
} // main
