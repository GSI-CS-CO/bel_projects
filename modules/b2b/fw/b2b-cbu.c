/********************************************************************************************
 *  b2b-cbu.c
 *
 *  created : 2019
 *  author  : Dietrich Beck, GSI-Darmstadt
 *  version : 13-Dec-2024
 *
 *  firmware implementing the CBU (Central Bunch-To-Bucket Unit)
 *  NB: units of variables are [ns] unless explicitely mentioned as suffix
 *
 * -------------------------------------------------------------------------------------------
 * License Agreement for this software:
 *
 * Copyright (C) 2018  Dietrich Beck
 * GSI Helmholtzzentrum fuer Schwerionenforschung GmbH
 * Planckstrasse 1
 * D-64291 Darmstadt
 * Germany
 *
 * Contact: d.beck@gsi.de
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 3 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *  
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library. If not, see <http://www.gnu.org/licenses/>.
 *
 * For all questions and ideas contact: d.beck@gsi.de
 * Last update: 23-April-2019
 ********************************************************************************************/
#define B2BCBU_FW_VERSION 0x000801                                      // make this consistent with makefile

// standard includes
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>
#include <stdint.h>
#include <math.h>

// includes specific for bel_projects
#include "dbg.h"
#include <stack.h>                                                      // stack check
#include "ebm.h"
#include "pp-printf.h"                                                  // print stuff
#include "mini_sdb.h"                                                   // sdb stuff
#include "aux.h"                                                        // cpu and IRQ
#include "uart.h"                                                       // WR console

// includes for this project
#include <common-defs.h>                                                // common defs
#include <common-fwlib.h>                                               // fw lib
#include <b2b.h>                                                        // defs for b2b
#include <b2bcbu_shared_mmap.h>                                         // autogenerated upon building firmware

// stuff required for environment
extern uint32_t* _startshared[];
unsigned int     cpuId, cpuQty;
#define  SHARED  __attribute__((section(".shared")))
uint64_t SHARED  dummy = 0;
volatile uint32_t *pShared;             // pointer to begin of shared memory region

// public variables; set-values are split into two parts due to a LSA requirement
// set values for a single commit, extraction
volatile uint32_t *pSharedSetSidEExt;     // pointer to a "user defined" u32 register; here: sequence ID of extraction machine
volatile uint32_t *pSharedSetGidExt;      // pointer to a "user defined" u32 register; here: b2b group ID of extraction ring
volatile uint32_t *pSharedSetMode;        // pointer to a "user defined" u32 register; here: mode of b2b transfer
volatile uint32_t *pSharedSetTH1ExtHi;    // pointer to a "user defined" u32 register; here: period of h=1 extraction, high bits [as]
volatile uint32_t *pSharedSetTH1ExtLo;    // pointer to a "user defined" u32 register; here: period of h=1 extraction, low bits
volatile uint32_t *pSharedSetNHExt;       // pointer to a "user defined" u32 register; here: harmonic number extraction
volatile float    *pSharedSetCTrigExt;    // pointer to a "user defined" u32 register; here: correction for trigger extraction ('extraction kicker knob') [ns]
volatile int32_t  *pSharedSetNBuckExt;    // pointer to a "user defined" u32 register; here: bucket numer of extraction
volatile float    *pSharedSetCPhase;      // pointer to a "user defined" u32 register; here: correction for phase matching ('phase knob') [ns]
volatile uint32_t *pSharedSetFFinTune;    // pointer to a "user defined" u32 register; here: flag: use fine tune
volatile uint32_t *pSharedSetFMBTune;     // pointer to a "user defined" u32 register; here: use multi-beat tune

// set values for a single commit, injection
volatile uint32_t *pSharedSetSidEInj;     // pointer to a "user defined" u32 register; here: sequence ID of injection machine
volatile uint32_t *pSharedSetGidInj;      // pointer to a "user defined" u32 register; here: b2b GID offset of injection ring
volatile uint32_t *pSharedSetLSidInj;     // pointer to a "user defined" u32 register; here: LSA SID of injection ring
volatile uint32_t *pSharedSetLBpidInj;    // pointer to a "user defined" u32 register; here: LSA BPID of injection ring
volatile uint32_t *pSharedSetLParamInjHi; // pointer to a "user defined" u32 register; here: LSA param of injection ring, high bits
volatile uint32_t *pSharedSetLParamInjLo; // pointer to a "user defined" u32 register; here: LSA param of injection ring, low bits
volatile uint32_t *pSharedSetTH1InjHi;    // pointer to a "user defined" u32 register; here: period of h=1 injection, high bits [as]
volatile uint32_t *pSharedSetTH1InjLo;    // pointer to a "user defined" u32 register; here: period of h=1 injecion, low bits
volatile uint32_t *pSharedSetNHInj;       // pointer to a "user defined" u32 register; here: harmonic number injection
volatile float    *pSharedSetCTrigInj;    // pointer to a "user defined" u32 register; here: correction for trigger injection ('injction kicker knob') [ns]
volatile int32_t  *pSharedSetNBuckInj;    // pointer to a "user defined" u32 register; here: bucket numer of injection

// set values for all SIDs; the index equals the SID
uint32_t setFlagValid[B2B_NSID];            
uint32_t setGid[B2B_NSID];
uint32_t setMode[B2B_NSID];
uint64_t setTH1Ext_as[B2B_NSID];        // [as]
uint32_t setNHExt[B2B_NSID];
uint64_t setTH1Inj_as[B2B_NSID];        // [as]
uint32_t setNHInj[B2B_NSID];
uint32_t setLSidInj[B2B_NSID];
uint32_t setLBpidInj[B2B_NSID];
uint64_t setLParamInj[B2B_NSID];
float    setCPhase[B2B_NSID];           // [ns]
float    setCTrigExt[B2B_NSID];         // [ns]
float    setCTrigInj[B2B_NSID];         // [ns]
int32_t  setNBuckExt[B2B_NSID];
int32_t  setNBuckInj[B2B_NSID];
uint32_t setFFinTune[B2B_NSID];
uint32_t setFMBTune[B2B_NSID];

// get values
volatile uint32_t *pSharedGetSid;       // pointer to a "user defined" u32 register; here: sequence ID of extraction machine
volatile uint32_t *pSharedGetGid;       // pointer to a "user defined" u32 register; here: b2b group ID of extraction machine
volatile uint32_t *pSharedGetMode;      // pointer to a "user defined" u32 register; here: mode of b2b transfer
volatile uint32_t *pSharedGetTH1ExtHi;  // pointer to a "user defined" u32 register; here: period of h=1 extraction, high bits [as]
volatile uint32_t *pSharedGetTH1ExtLo;  // pointer to a "user defined" u32 register; here: period of h=1 extraction, low bits
volatile uint32_t *pSharedGetNHExt;     // pointer to a "user defined" u32 register; here: harmonic number extraction
volatile uint32_t *pSharedGetTH1InjHi;  // pointer to a "user defined" u32 register; here: period of h=1 injection, high bits [as]
volatile uint32_t *pSharedGetTH1InjLo;  // pointer to a "user defined" u32 register; here: period of h=1 injecion, low bits
volatile uint32_t *pSharedGetNHInj;     // pointer to a "user defined" u32 register; here: harmonic number injection
volatile float    *pSharedGetCPhase;    // pointer to a "user defined" u32 register; here: correction for phase matching ('phase knob') [ns]
volatile float    *pSharedGetCTrigExt;  // pointer to a "user defined" u32 register; here: correction for trigger extraction ('extraction kicker knob') [ns]
volatile float    *pSharedGetCTrigInj;  // pointer to a "user defined" u32 register; here: correction for trigger injection ('injction kicker knob') [ns]
volatile uint32_t *pSharedGetTBeatHi;   // pointer to a "user defined" u32 register; here: period of beating, high bits [as]
volatile uint32_t *pSharedGetTBeatLo;   // pointer to a "user defined" u32 register; here: period of beating, low bits

// important for b2b system
uint32_t  gid;                          // GID used for transfer
uint32_t  sid;                          // SID user for transfer
uint32_t  mode;                         // mode for transfer
uint64_t  TH1Ext_as;                    // h=1 period [as] of extraction machine
uint32_t  nHExt;                        // harmonic number of extraction machine 0..255
uint64_t  TH1Inj_as;                    // h=1 period [as] of injection machine
uint32_t  nHInj;                        // harmonic number of injection machine 0..255
uint64_t  TBeat_as;                     // beating period [as]
b2bt_t    cPhase_t;                     // correction for phase matching
b2bt_t    cTrigExt_t;                   // correction for extraction trigger
b2bt_t    cTrigInj_t;                   // correction for injection trigger
int32_t   nBucketExt;                   // number of bucket for extraction
int32_t   nBucketInj;                   // number of bucket for injection
int       fFineTune;                    // flag: uoffse fine tuning
int       fMBTune;                      // flag: use multi-beat tuning
uint64_t  tCBS;                         // deadline of CMD_B2B_START
uint16_t  offsetPrr_us;                 // offset from CBS to to deadline of PRE [us, hfloat]
uint32_t  nGExt;                        // geometric harmonic number of extraction machine due to its circumference
uint32_t  nGInj;                        // geometric harmonic number of injections machine due to its circumference
b2bt_t    pShiftExt;                    // phase shift value for extraction machine
b2bt_t    pShiftInj;                    // phase shift value for injection machine
uint64_t  tWantExt;                     // desired earliest time of extraction


// copies for nice trigger messages
uint32_t  flagsExt;                     // LSA flags extraction
uint32_t  sidExt;                       // LSA SID extraction
uint32_t  bpidExt;                      // LSA BPID extraction
uint64_t  paramExt;                     // LSA param extraction
uint32_t  flagsInj;                     // LSA flags injection
uint32_t  sidInj;                       // LSA SID injection
uint32_t  bpidInj;                      // LSA BPID injection
uint64_t  paramInj;                     // LSA param injection


b2bt_t    tH1Ext_t;                     // h=1 phase of extraction machine
b2bt_t    tH1Inj_t;                     // h=1 phase of injection machine
int32_t   nPhaseResult;                 // number of received phase result, required to resolve diamond structure in mini FSM

uint64_t  statusArray;                  // all status infos are ORed bit-wise into statusArray, statusArray is then published
uint32_t  nTransfer;                    // # of transfers
uint32_t  transStat;                    // status of ongoing transfer
uint32_t  mState;                       // state of 'miniFSM' 
int32_t   comLatency;                   // latency for messages received via ECA [ns]
int32_t   offsDone;                     // offset deadline WR message to time when we are done [ns]
int32_t   maxComLatency;
uint32_t  maxOffsDone;
uint32_t  nLate;                        // # of late messages

// flags
uint32_t  flagClearAllSid;              // data for all SIDs shall be cleared
uint32_t  errorFlags;                   // error flags, bit 0: PM Ext, bit 1: KD Ext, bit 2: PM INJ, bit 3: KD INJ, bit 4: CBU

// constants (as variables to have a defined type)
uint64_t  one_ns_as = 1000000000;
uint64_t  one_ps_as = 1000000;
uint64_t  one_s_ns  = 1000000000;

uint32_t  *cpuRamExternal;              // external address (seen from host bridge) of this CPU's RAM            

// typical init for lm32
void init()
{
  discoverPeriphery();        // mini-sdb ...
  uart_init_hw();             // needed by WR console   
  cpuId = getCpuIdx();
} // init


// determine address and clear shared mem
void initSharedMem(uint32_t *reqState, uint32_t *sharedSize) 
{
  uint32_t idx;
  uint32_t *pSharedTemp;
  int      i; 
  const uint32_t c_Max_Rams = 10;
  sdb_location found_sdb[c_Max_Rams];
  sdb_location found_clu;
  
  // get pointer to shared memory
  pShared                 = (uint32_t *)_startshared;
  pSharedSetSidEExt       = (uint32_t *)(pShared + (B2B_SHARED_SET_SIDEEXT     >> 2));
  pSharedSetGidExt        = (uint32_t *)(pShared + (B2B_SHARED_SET_GIDEXT      >> 2));
  pSharedSetMode          = (uint32_t *)(pShared + (B2B_SHARED_SET_MODE        >> 2));
  pSharedSetTH1ExtHi      = (uint32_t *)(pShared + (B2B_SHARED_SET_TH1EXTHI    >> 2));
  pSharedSetTH1ExtLo      = (uint32_t *)(pShared + (B2B_SHARED_SET_TH1EXTLO    >> 2));
  pSharedSetNHExt         = (uint32_t *)(pShared + (B2B_SHARED_SET_NHEXT       >> 2));
  pSharedSetCTrigExt      =    (float *)(pShared + (B2B_SHARED_SET_CTRIGEXT    >> 2));
  pSharedSetNBuckExt      = (uint32_t *)(pShared + (B2B_SHARED_SET_NBUCKEXT    >> 2));
  pSharedSetCPhase          =  (float *)(pShared + (B2B_SHARED_SET_CPHASE      >> 2));
  pSharedSetFFinTune      = (uint32_t *)(pShared + (B2B_SHARED_SET_FFINTUNE    >> 2));
  pSharedSetFMBTune       = (uint32_t *)(pShared + (B2B_SHARED_SET_FMBTUNE     >> 2));
  
  pSharedSetSidEInj       = (uint32_t *)(pShared + (B2B_SHARED_SET_SIDEINJ     >> 2));
  pSharedSetGidInj        = (uint32_t *)(pShared + (B2B_SHARED_SET_GIDINJ      >> 2));
  pSharedSetLSidInj       = (uint32_t *)(pShared + (B2B_SHARED_SET_LSIDINJ     >> 2));
  pSharedSetLBpidInj      = (uint32_t *)(pShared + (B2B_SHARED_SET_LBPIDINJ    >> 2));
  pSharedSetLParamInjHi   = (uint32_t *)(pShared + (B2B_SHARED_SET_LPARAMINJHI >> 2));
  pSharedSetLParamInjLo   = (uint32_t *)(pShared + (B2B_SHARED_SET_LPARAMINJLO >> 2));
  pSharedSetTH1InjHi      = (uint32_t *)(pShared + (B2B_SHARED_SET_TH1INJHI    >> 2));
  pSharedSetTH1InjLo      = (uint32_t *)(pShared + (B2B_SHARED_SET_TH1INJLO    >> 2));
  pSharedSetNHInj         = (uint32_t *)(pShared + (B2B_SHARED_SET_NHINJ       >> 2));
  pSharedSetCTrigInj      =    (float *)(pShared + (B2B_SHARED_SET_CTRIGINJ    >> 2));
  pSharedSetNBuckInj      = (uint32_t *)(pShared + (B2B_SHARED_SET_CTRIGINJ    >> 2));
  
  pSharedGetGid           = (uint32_t *)(pShared + (B2B_SHARED_GET_GID         >> 2));
  pSharedGetSid           = (uint32_t *)(pShared + (B2B_SHARED_GET_SID         >> 2));
  pSharedGetMode          = (uint32_t *)(pShared + (B2B_SHARED_GET_MODE        >> 2));
  pSharedGetTH1ExtHi      = (uint32_t *)(pShared + (B2B_SHARED_GET_TH1EXTHI    >> 2));
  pSharedGetTH1ExtLo      = (uint32_t *)(pShared + (B2B_SHARED_GET_TH1EXTLO    >> 2));
  pSharedGetNHExt         = (uint32_t *)(pShared + (B2B_SHARED_GET_NHEXT       >> 2));
  pSharedGetTH1InjHi      = (uint32_t *)(pShared + (B2B_SHARED_GET_TH1INJHI    >> 2));
  pSharedGetTH1InjLo      = (uint32_t *)(pShared + (B2B_SHARED_GET_TH1INJLO    >> 2));
  pSharedGetNHInj         = (uint32_t *)(pShared + (B2B_SHARED_GET_NHINJ       >> 2));
  pSharedGetCPhase        =    (float *)(pShared + (B2B_SHARED_GET_CPHASE      >> 2));
  pSharedGetCTrigExt      =    (float *)(pShared + (B2B_SHARED_GET_CTRIGEXT    >> 2));
  pSharedGetCTrigInj      =    (float *)(pShared + (B2B_SHARED_GET_CTRIGINJ    >> 2));
  pSharedGetTBeatHi       = (uint32_t *)(pShared + (B2B_SHARED_GET_TBEATHI     >> 2));
  pSharedGetTBeatLo       = (uint32_t *)(pShared + (B2B_SHARED_GET_TBEATLO     >> 2));
  
  // find address of CPU from external perspective
  idx = 0;
  find_device_multi(&found_clu, &idx, 1, GSI, LM32_CB_CLUSTER);
   if (idx == 0) {
    *reqState = COMMON_STATE_FATAL;
    DBPRINT1("b2b-cbu: fatal error - did not find LM32-CB-CLUSTER!\n");
  } // if idx
  idx = 0;
  find_device_multi_in_subtree(&found_clu, &found_sdb[0], &idx, c_Max_Rams, GSI, LM32_RAM_USER);
  if (idx == 0) {
    *reqState = COMMON_STATE_FATAL;
    DBPRINT1("b2b-cbu: fatal error - did not find THIS CPU!\n");
  } // if idx
  else cpuRamExternal = (uint32_t *)(getSdbAdr(&found_sdb[cpuId]) & 0x7FFFFFFF); // CPU sees the 'world' under 0x8..., remove that bit to get host bridge perspective
  
  DBPRINT2("b2b-cbu: CPU RAM external 0x%8x, shared offset 0x%08x\n", cpuRamExternal, SHARED_OFFS);
  DBPRINT2("b2b-cbu: fw common shared begin   0x%08x\n", pShared);
  DBPRINT2("b2b-cbu: fw common shared end     0x%08x\n", pShared + (COMMON_SHARED_END >> 2));

  // clear shared mem
  i = 0;
  pSharedTemp        = (uint32_t *)(pShared + (COMMON_SHARED_END >> 2 ) + 1);
  DBPRINT2("b2b-cbu: fw specific shared begin 0x%08x\n", pSharedTemp);
  while (pSharedTemp < (uint32_t *)(pShared + (B2B_SHARED_END >> 2 ))) {
    *pSharedTemp = 0x0;
    pSharedTemp++;
    i++;
  } // while pSharedTemp
  DBPRINT2("b2b-cbu: fw specific shared end   0x%08x\n", pSharedTemp);

  *sharedSize        = (uint32_t)(pSharedTemp - pShared) << 2;

  // basic info to wr console
  DBPRINT1("\n");
  DBPRINT1("b2b-cbu: initSharedMem, shared size [bytes]: %d\n", *sharedSize);
  DBPRINT1("\n");
} // initSharedMem


// clears all statistics
void extern_clearDiag()
{
  statusArray   = 0x0;
  nTransfer     = 0x0;
  transStat     = 0x0;
  nLate         = 0x0;
  comLatency    = 0x0;
  maxComLatency = 0x0;
  offsDone      = 0x0;
  maxOffsDone   = 0x0;
} // extern_clearDiag 


// clears all multiplexing data
void clearAllSid()
{
  int i;
  for (i=0; i<B2B_NSID; i++) {
    setFlagValid[i]  = 0;            
    setGid[i]        = 0;
    setMode[i]       = 0;
    setTH1Ext_as[i]  = 0;
    setNHExt[i]      = 0;
    setTH1Inj_as[i]  = 0;
    setNHInj[i]      = 0;
    setLSidInj[i]    = 0;
    setLBpidInj[i]   = 0;
    setLParamInj[i]  = 0;
    setCPhase[i]     = 0;
    setCTrigExt[i]   = 0;
    setCTrigInj[i]   = 0;
    setNBuckExt[i]   = 0;
    setNBuckInj[i]   = 0;
    setFFinTune[i]   = 0;
    setFMBTune[i]    = 0;
  } // for i
} // clearAllSid


// submits a new set for a specific sid to the multiplexing data
uint32_t setSubmit()
{
  int          sid;
  int          flagInject;

  // SID is used as array index. Strict checking required to avoid segfaults etc
  if (*pSharedSetSidEExt > 15)   return COMMON_STATUS_OUTOFRANGE;
  else sid = *pSharedSetSidEExt;

  // diable 'valid' flag here so that the corresponding setting is disabled in case of erronous settings
  setFlagValid[sid]    = 0;

  if (*pSharedSetMode == B2B_MODE_B2C ||
      *pSharedSetMode ==  B2B_MODE_B2BFBEAT ||
      *pSharedSetMode ==  B2B_MODE_B2BPSHIFTE ||
      *pSharedSetMode ==  B2B_MODE_B2BPSHIFTI
      ) flagInject = 1;
  else  flagInject = 0;

  // in case of injection to another ring, we need to check for correct SID of extraction ring
  if (flagInject && (*pSharedSetSidEInj != sid)) return B2B_STATUS_BADSETTING;
  /* more checking required chk */

  // values required for extraction
  setMode[sid]         = *pSharedSetMode;
  //pp_printf("submit sid %d, mode %d\n", sid, *pSharedSetMode);
  setGid[sid]          = *pSharedSetGidExt;
  setTH1Ext_as[sid]    = (uint64_t)(*pSharedSetTH1ExtHi) << 32;
  setTH1Ext_as[sid]   |= (uint64_t)(*pSharedSetTH1ExtLo);
  setNHExt[sid]        = *pSharedSetNHExt;
  setCTrigExt[sid]     = *pSharedSetCTrigExt;
  setNBuckExt[sid]     = (int32_t)(*pSharedSetNBuckExt);
  setFFinTune[sid]     = *pSharedSetFFinTune;
  setCPhase[sid]       = *pSharedSetCPhase;


  // additional values required in case of injection into another ring
  if (flagInject) {
    setGid[sid]       += *pSharedSetGidInj;
    setLSidInj[sid]    = *pSharedSetLSidInj;
    setLBpidInj[sid]   = *pSharedSetLBpidInj;
    setLParamInj[sid]  = (uint64_t)(*pSharedSetLParamInjHi) << 32;
    setLParamInj[sid] |= (uint64_t)(*pSharedSetLParamInjLo);
    setTH1Inj_as[sid]  = (uint64_t)(*pSharedSetTH1InjHi) << 32;
    setTH1Inj_as[sid] |= (uint64_t)(*pSharedSetTH1InjLo);
    setNHInj[sid]      = *pSharedSetNHInj;
    setCTrigInj[sid]   = *pSharedSetCTrigInj;
    setNBuckInj[sid]   = (int32_t)(*pSharedSetNBuckInj);
    setFMBTune[sid]    = *pSharedSetFMBTune;
  } // if flagInject
  else {
    setTH1Inj_as[sid]  = 0;
    setNHInj[sid]      = 0;
    setLBpidInj[sid]   = 0;
    setLParamInj[sid]  = 0;
    setLParamInj[sid]  = 0;
    setCTrigInj[sid]   = 0;
    setNBuckInj[sid]   = 0;
    setFMBTune[sid]    = 0;
  } // else flagInject   
  
  setFlagValid[sid]    = 1;
  //pp_printf("submit %u\n", sid);
  return COMMON_STATUS_OK;
} // setSubmit


// entryActionConfigured called by common ...
uint32_t extern_entryActionConfigured()
{
  uint32_t status = COMMON_STATUS_OK;

  fwlib_clearDiag();
  clearAllSid();

  flagClearAllSid = 0;

  // configure EB master (SRC and DST MAC/IP are set from host)
  if ((status = fwlib_ebmInit(2000, 0xffffffffffff, 0xffffffff, EBM_NOREPLY)) != COMMON_STATUS_OK) {
    DBPRINT1("b2b-cbu: ERROR - init of EB master failed! %u\n", (unsigned int)status);
    return status;
  } 

  // get and publish NIC data
  fwlib_publishNICData();

  return status;
} // extern_entryActionConfigured


// entryActionOperation called by common ...
uint32_t extern_entryActionOperation()
{
  int      i;
  uint64_t tDummy;
  uint64_t eDummy;
  uint64_t pDummy;
  uint32_t fDummy;
  uint32_t flagDummy1, flagDummy2, flagDummy3, flagDummy4;
  

  // clear diagnostics
  fwlib_clearDiag();             

  // flush ECA queue for lm32
  i = 0;
  while (fwlib_wait4ECAEvent(1000, &tDummy, &eDummy, &pDummy, &fDummy, &flagDummy1, &flagDummy2, &flagDummy3, &flagDummy4) !=  COMMON_ECADO_TIMEOUT) {i++;}
  DBPRINT1("b2b-cbu: ECA queue flushed - removed %d pending entries from ECA queue\n", i);

  // init set values extraction
  *pSharedSetGidExt      = 0x0;     
  *pSharedSetSidEExt     = 0x0;     
  *pSharedSetMode        = 0x0;    
  *pSharedSetTH1ExtHi    = 0x0;
  *pSharedSetTH1ExtLo    = 0x0;
  *pSharedSetNHExt       = 0x0;   
  *pSharedSetCPhase      = 0x0;  
  *pSharedSetCTrigExt    = 0x0;  
  *pSharedSetCTrigInj    = 0x0;
  *pSharedSetNBuckExt    = 0x0;
  *pSharedSetFFinTune    = 0x0;
  *pSharedSetFMBTune     = 0x0;

  // init set values injection
  *pSharedSetGidInj      = 0x0;
  *pSharedSetSidEInj     = 0x0;
  *pSharedSetLSidInj     = 0x0;
  *pSharedSetLBpidInj    = 0x0;
  *pSharedSetLParamInjHi = 0x0;
  *pSharedSetLParamInjLo = 0x0;
  *pSharedSetTH1InjHi    = 0x0;
  *pSharedSetTH1InjLo    = 0x0;
  *pSharedSetNHInj       = 0x0;
  *pSharedSetNBuckInj    = 0x0;
    
  // init get values
  *pSharedGetGid         = 0x0;
  *pSharedGetSid         = 0x0;
  *pSharedGetMode        = 0x0;
  *pSharedGetTH1ExtHi    = 0x0; 
  *pSharedGetTH1ExtLo    = 0x0;
  *pSharedGetNHExt       = 0x0;
  *pSharedGetTH1InjHi    = 0x0;
  *pSharedGetTH1InjLo    = 0x0;
  *pSharedGetNHInj       = 0x0;
  *pSharedGetCPhase      = 0x0;
  *pSharedGetCTrigExt    = 0x0;
  *pSharedGetCTrigInj    = 0x0;
  *pSharedGetTBeatHi     = 0x0;
  *pSharedGetTBeatLo     = 0x0;

  nLate                  = 0x0;
  comLatency             = 0x0;
  maxComLatency          = 0x0;
  offsDone               = 0x0;
  maxOffsDone            = 0x0;

  return COMMON_STATUS_OK;
} // extern_entryActionOperation


// exitActionOperation called by common ...
uint32_t extern_exitActionOperation()
{
  return COMMON_STATUS_OK;
} // extern_exitActionOperation


// gets the GID for timing message used for triggering a kicker
uint32_t getTrigGid(uint32_t extFlag)
{
  uint32_t trigGid;

  switch (gid) {
    case SIS18_B2B_EXTRACT :
      if (extFlag) trigGid = SIS18_RING;
      else         trigGid = GID_INVALID;
      break;
    case SIS18_B2B_ESR :
      if (extFlag) trigGid = SIS18_RING;
      else         trigGid = ESR_RING;
      break;
    case ESR_B2B_EXTRACT :
      if (extFlag) trigGid = ESR_RING;
      else         trigGid = GID_INVALID;
      break;
    case ESR_B2B_CRYRING :
      if (extFlag) trigGid = ESR_RING;
      else         trigGid = CRYRING_RING;
      break;
    case CRYRING_B2B_EXTRACT :
      if (extFlag) trigGid = CRYRING_RING;
      else         trigGid = GID_INVALID;
      break;     
    default :
      trigGid = GID_INVALID;
  } // switch gid

  return trigGid;
} // getTrigGid


// get geometric harmonic numbers defined by ratio of ring circumferences
void getGeometricHarmonics(uint32_t gid, uint32_t *nExt, uint32_t *nInj)
{
  switch (gid) {
    case SIS18_B2B_ESR :
      *nExt = 2;
      *nInj = 1;
      break;
    case SIS18_B2B_SIS100 :
      *nExt = 1;
      *nInj = 5;
      break;
    case ESR_B2B_CRYRING :
      *nExt = 2;
      *nInj = 1;
      break;
    default :
      *nExt = 1;
      *nInj = 1;
  } // switch gid
} // getGeometricHarmonics


// calculates time for extraction
uint32_t calcExtTime(uint64_t *tExtract, uint64_t tWant)
{
  b2bt_t tExt;
  
  // check for unreasonable values
  if (TH1Ext_as == 0)                   return COMMON_STATUS_OUTOFRANGE;          // no value for period
  if (nHExt     == 0)                   return COMMON_STATUS_OUTOFRANGE;          // no value for harmonic number
  if ((tH1Ext_t.ns + one_s_ns) < tWant) return COMMON_STATUS_OUTOFRANGE;          // value older than approximately 1s

  tExt = fwlib_advanceTimePs(tH1Ext_t, fwlib_tns2tps(tWant), TH1Ext_as);
  
  *tExtract = fwlib_tps2tns(tExt);
  //pp_printf("calc ps %4d\n", tH1Ext_t.ps);
  if (*tExtract == 0)                   return COMMON_STATUS_OUTOFRANGE;

  return COMMON_STATUS_OK;
} // calcExtTime


// fine tune for individual h=1 cycles
void rfFineTune(uint64_t tH1Ext_as, uint64_t tH1Inj_as, uint64_t *tMatch_as, uint64_t *dt_as)
{
  uint64_t half;                                    // helper variable
  uint64_t nDiff;                                   // # we need project Tdiff into the future
  
  uint64_t ftTExt_as;                               // fine tune extraction period
  uint64_t ftTInj_as;                               // fine tune injection period
  uint64_t ftMatchExt_as;                           // fine tune match for extraction
  uint64_t ftMatchInj_as;                           // fine tune match for injection
  int64_t  ftDtAs1;                                 // fine tune differences ...
  int64_t  ftDtAs2;
  int64_t  ftDtAs3;

  // fine tuning; align to 'common' multiple of TH1
  // algorithm: compare match for previous, actual and next iteration
  // calculate common multiples of h=1 for each ring
  ftTExt_as     = TH1Ext_as * nGInj;
  ftTInj_as     = TH1Inj_as * nGExt;

  // ftMatch extraction, use input value as reference
  half          = TH1Ext_as >> 1;
  nDiff         = (*tMatch_as - tH1Ext_as) / TH1Ext_as;
  if (((*tMatch_as - tH1Ext_as) % TH1Ext_as) > half) nDiff++;
  ftMatchExt_as = tH1Ext_as + nDiff * TH1Ext_as;

  // ftMatch injection; use extraction match as reference
  half          = TH1Inj_as >> 1;
  nDiff         = (ftMatchExt_as - tH1Inj_as) / TH1Inj_as;
  if (((ftMatchExt_as - tH1Inj_as) % TH1Inj_as) > half) nDiff++;
  ftMatchInj_as = tH1Inj_as + nDiff * TH1Inj_as;

  //pp_printf("huhu tMatchExt %lu, tMatchInj %lu\n", (uint32_t)(ftMatchExt / 1000000000), (uint32_t)(ftMatchInj / 1000000000));
  
  // calc differences, alignment to extraction
  ftDtAs1 = (int64_t)(ftMatchExt_as - ftTExt_as) - (int64_t)(ftMatchInj_as - ftTInj_as);
  ftDtAs2 = (int64_t)(ftMatchExt_as)             - (int64_t)(ftMatchInj_as);
  ftDtAs3 = (int64_t)(ftMatchExt_as + ftTExt_as) - (int64_t)(ftMatchInj_as + ftTInj_as);

  // decide which is best
  *tMatch_as = ftMatchExt_as;
  *dt_as       = ftDtAs2;
  if (llabs(ftDtAs1) < llabs(ftDtAs2)) {*tMatch_as = ftMatchExt_as - ftTExt_as; *dt_as = ftDtAs1;}
  if (llabs(ftDtAs3) < llabs(ftDtAs2)) {*tMatch_as = ftMatchExt_as + ftTExt_as; *dt_as = ftDtAs3;}
  //pp_printf("fine tune dt1 %ld, dt2 %ld, dt3 %ld\n", (int32_t)(ftDt1/1000000), (int32_t)(ftDt2/1000000), (int32_t)(ftDt3/1000000));
} // rfFineTune


// true b2b: calculate time for phase match
uint32_t calcPhaseMatch(uint64_t tMin, uint64_t *tPhaseMatch, uint64_t *TBeat_as)  // calculates when extraction and injection machines are synchronized
{
  uint64_t TSlow_as;                                // period of 'slow' RF signal               [as] // sic! atoseconds
  uint64_t TFast_as;                                // period of 'fast' signal                  [as]
  uint64_t TRfExt_as;                               // period of RF signal extraction           [as]
  uint64_t TRfInj_as;                               // period of RF signal injection            [as]
  uint64_t tSlow_as;                                // 0 phase of 'slow' H=1 signal             [as]
  uint64_t tFast_as;                                // 0 phase of 'fast' H=1 signal             [as]
  uint64_t tH1Ext_as;                               // 0 phase of H=1 signal extraction         [as]
  uint64_t tH1Inj_as;                               // 0 phase of H=1 signal injection          [as]
  uint64_t Tdiff_as;                                // difference of true RF periods            [as]
  uint64_t nDiff;                                   // # we need project Tdiff into the future  
  uint64_t tMatch_as;                               // 0 phase of best match                    [as]
  uint64_t tTmp_as;                                 // temporary time                           [as]
  uint64_t tD0_as;                                  // tFast - tSlow                            [as]
  uint64_t tMatch;                                  // 'tMatch' [ns]
  uint64_t epoch;                                   // temporary epoch
  uint64_t tNow;                                    // current time
  uint64_t unit2as   = 1000000;                     // needed for conversion [ps] -> [as]
  uint64_t half;                                    // helper variable
  uint32_t nExtAdv;                                 // number of h=1 periods required to advance tH1Ext_t
  uint32_t nInjAdv;                                 // number of h=1 periods required to advance tH1Inj_t

  // parameters for 'best bunch probing'
#define LIMITMULTIBEAT  360                         // do multibeat-tuning, if number of h=1 periods within beating is below this number

  uint64_t nH1BeatExt;                              // number of h=1 periods within beating period extraction
  int      i;
  int      nProbes;                                 // number of probes to be used
  int      maxProbes;                               // max number of probes
  uint64_t tTimeout;                                // deadline, when this routine must finish
  int64_t  dt_as, dtTmp_as;                         // achieved precision, temporary variable
  uint64_t tMatch0_as, tMatchTmp_as;                // temporary variables
  uint64_t TBeat;                                   // beat period (see 'trick' below)          [ns]
  uint64_t iMatch;                                  // trick: iteration of good match allows continuation of fine tuning
  uint32_t tmp32;

  // define temporary epoch
  tNow    = getSysTime();
  epoch   = tNow - one_s_ns;                        // subtracting one second should be safe

  DBPRINT3("b2b-cbu: tNow - tH1Ext %u ps, tNow - tH1inj %u ns, nGExt %u, nGInj %u\n", (unsigned int)(tNow - tH1Ext_t.ns), (unsigned int)(tNow - tH1Inj_t.ns), nGExt, nGInj);

  // check for unreasonable values
  if (TH1Ext_as == 0)                     return COMMON_STATUS_OUTOFRANGE;        // no value for period
  if (TH1Inj_as == 0)                     return COMMON_STATUS_OUTOFRANGE;        // no value for period
  if (nHExt    == 0)                      return COMMON_STATUS_OUTOFRANGE;        // no value for harmonic number
  if (nHInj    == 0)                      return COMMON_STATUS_OUTOFRANGE;        // no value for harmonic number
  if (nGExt    == 0)                      return COMMON_STATUS_OUTOFRANGE;        // no value for harmonic number
  if (nGInj    == 0)                      return COMMON_STATUS_OUTOFRANGE;        // no value for harmonic number
  if (TH1Inj_as == 0)                     return COMMON_STATUS_OUTOFRANGE;        // no value for period
  if ((tH1Ext_t.ns + one_s_ns/10) < tNow) return COMMON_STATUS_OUTOFRANGE;        // value older than 100ms
  if ((tH1Inj_t.ns + one_s_ns/10) < tNow) return COMMON_STATUS_OUTOFRANGE;        // value older than 100ms

  TRfExt_as = TH1Ext_as / nGExt;
  TRfInj_as = TH1Inj_as / nGInj;

  if (TRfExt_as == TRfInj_as)            return COMMON_STATUS_OUTOFRANGE;           // no beating

  tH1Ext_as  = (tH1Ext_t.ns - epoch) * one_ns_as + tH1Ext_t.ps * one_ps_as;
  tH1Inj_as  = (tH1Inj_t.ns - epoch) * one_ns_as + tH1Inj_t.ps * one_ps_as;

  // advance measured phase to approximate time of kick
  // this should prevent adding additional beating times in case of short beating periods
  nExtAdv    = one_ns_as * (tMin - tH1Ext_t.ns) / TH1Ext_as;
  nInjAdv    = one_ns_as * (tMin - tH1Inj_t.ns) / TH1Inj_as;
  tH1Ext_as += nExtAdv * TH1Ext_as;
  tH1Inj_as += nInjAdv * TH1Inj_as;

  // assign local values and convert times 't' to [as], periods 'T' are already in [as])
  if (TRfExt_as > TRfInj_as) {
    TSlow_as  = TRfExt_as;
    tSlow_as  = tH1Ext_as;

    TFast_as  = TRfInj_as;
    tFast_as  = tH1Inj_as;
  } // if extraction has lower frequency
  else {
    TSlow_as  = TRfInj_as;
    tSlow_as  = tH1Inj_as;

    TFast_as  = TRfExt_as;
    tFast_as  = tH1Ext_as;
  } // if etraction has higher frequency

  // make sure tSlow is earlier than tFast; this is a must for the formula below
  while (tSlow_as > tFast_as)             tFast_as = tFast_as + TFast_as;

  // make sure spacing between tSlow and tFast is not too large; otherwise we need to wait for too long
  while ((tFast_as - tSlow_as) > TFast_as) tFast_as = tFast_as - TFast_as;

  // now, tSlow is earlier than tFast and both values are at most one period apart; we can now start our calculation
  tD0_as    = tFast_as - tSlow_as;                        // difference between timestamps
  Tdiff_as  = TSlow_as - TFast_as;                        // difference between periods (higher harmonics RF)
  half      = Tdiff_as >> 1;                              // required for rounding
  nDiff     = tD0_as / Tdiff_as;                          // this basically does a 'floor()'
  if ((tD0_as % Tdiff_as) > half) nDiff++;                // do a better job with rounding 
  tMatch_as = nDiff * TSlow_as + tSlow_as;              

  *TBeat_as   = (TSlow_as / Tdiff_as);                    // beating period
  if ((*TBeat_as % Tdiff_as) > half) *TBeat_as++;
  *TBeat_as   = *TBeat_as * TSlow_as;
  
  //tmp = tFast; pp_printf("b2b: tmp %llu\n", tmp);
  //pp_printf("b2b-cbu: nProject %llu, tD0 %llu, Tdiff %llu\n", nProject, tD0, Tdiff);

  // check, that tMatch is far enough in the future; if not, add sufficient beating periods
  while ((tMatch_as / one_ns_as + epoch) < tMin) tMatch_as += *TBeat_as; 

  // align to h=1 group DDS of extraction ring
  half     = TH1Ext_as >> 1;
  nDiff    = (tMatch_as - tH1Ext_as) / TH1Ext_as;
  if (((tMatch_as - tH1Ext_as) % TH1Ext_as) > half) nDiff++;
  tMatch_as = tH1Ext_as + nDiff * TH1Ext_as;

  // in case injection ring is larger, align to its h=1 group DDS
  if (nGInj > nGExt) {
    // 1st, find match for injection
    half   = TH1Inj_as >> 1;
    nDiff  = (tMatch_as - tH1Inj_as) / TH1Inj_as;
    if (((tMatch_as - tH1Inj_as) % TH1Inj_as) > half) nDiff++;
    tTmp_as = tH1Inj_as + nDiff * TH1Inj_as;
    // 2nd, find next match in the future
    while (tTmp_as < tMatch_as) tTmp_as += TH1Inj_as;
    // 3rd, advance extraction by its h=1 periods until match
    // this will just work if nGInj == 1; else further beating required
    while (tTmp_as + (TH1Ext_as >> 1) > tMatch_as) tMatch_as += TH1Ext_as;
  } // if nGInj
 
  //pp_printf("TH1Inj %llu, nPeriod %llu, nGInj %u, flagExtSlow %d\n", TH1Inj, nPeriod, nGInj, flagExtSlow);
  
  // enable fine tuning?
  if (fFineTune) nProbes = 1;
  else           nProbes = 0;
  
  // multi-beat tuning
  dt_as       = 999999999999;
  tMatch0_as  = tMatch_as;
  nH1BeatExt = *TBeat_as / TRfExt_as;
  maxProbes  = 0;
  // multi-beat tuning is applied if one of the following conditions is fullfilled
  // a. very short beating period
  // b. geometric harmonic number of injection > 1 (CR -> HESR, 'brute force')
  // c. if the multi-beat flag is set
  if ((nH1BeatExt < LIMITMULTIBEAT) || (nGInj > 1) || fMBTune) {
    tTimeout  = tMin - (COMMON_AHEADT); // time, when we must finish     
    maxProbes = (one_ns_as * (B2B_KICKOFFSETMAX - B2B_KICKOFFSETMIN)) / *TBeat_as;
    if (maxProbes > nProbes) nProbes = maxProbes;
    TBeat     = *TBeat_as / one_ns_as;
    iMatch    = 0;
  } // if nH1BeatExt
  //pp_printf("cbu, nProbes %d\n", nProbes);
  for (i=0; i < nProbes; i++) {
    // advance to next possible beat time (unless in first iteration)
    tMatchTmp_as = tMatch0_as + (uint64_t)i * *TBeat_as;

    // fine tune (and align to extraction ring) and check for improved value
    rfFineTune(tH1Ext_as, tH1Inj_as, &tMatchTmp_as, &dtTmp_as);
    if (llabs(dtTmp_as) < llabs(dt_as)) {
      tMatch_as = tMatchTmp_as;
      dt_as     = dtTmp_as;
      iMatch   = i;
    } // if dtTmp_as
    if (getSysTime() > (tTimeout + iMatch * TBeat)) break;
  } // for i

  //pp_printf("b2b: n probes (=max) %d, used %d\n", nProbes, i);

  // convert back to TAI
  tMatch       = tMatch_as / one_ns_as;
  half         = one_ns_as >> 1;
  if ((tMatch_as % one_ns_as) > half) tMatch++;
  *tPhaseMatch =  tMatch + epoch;
  //tmp32        = (uint32_t)(*TBeat_as / 1000000000); pp_printf("cbu, tbeat %u\n", tmp32);
  tmp32        = *tPhaseMatch - tMin;

  // check if we are still within allowed time window
  if (tmp32 > (B2B_KICKOFFSETMAX - B2B_KICKOFFSETMIN)) {
    //pp_printf("cbu, tPhaseMatch_0 %u, nProbes %d\n", tmp32, nProbes);
    return COMMON_STATUS_OUTOFRANGE;
  } // if tmp32

  return COMMON_STATUS_OK;    
} // calcPhaseMatch


// command handler, handles commands specific for this project
void cmdHandler(uint32_t *reqState, uint32_t cmd)
{
  // check, if the command is valid and request state change
  if (cmd) {                             // check, if cmd is valid
    switch (cmd) {                       // do action according to command
      case B2B_CMD_CONFSUBMIT :
        DBPRINT3("b2b: received cmd %d\n", cmd);
        if (setSubmit() != COMMON_STATUS_OK) DBPRINT3("b2b: submission of config data failed\n");
        break;
      case B2B_CMD_CONFCLEAR :
        DBPRINT3("b2b: received cmd %d\n", cmd);
        flagClearAllSid = 1;
        break;
      default:
        DBPRINT3("b2b: received unknown command '0x%08x'\n", cmd);
        break;
    } // switch 
  } // if command 
} // cmdHandler


// mini fsm
uint32_t getNextMState(uint32_t mode, uint32_t actMState) {
  uint32_t nextMState = B2B_MFSM_NOTHING;

  switch (mode) {
    case B2B_MODE_OFF :     // off (no or slow extraction)
      switch (actMState) {
        case B2B_MFSM_S0 :
          nextMState = B2B_MFSM_EXT_PMEAS_S;
          break;
        case B2B_MFSM_EXT_PMEAS_S :
          nextMState = B2B_MFSM_NOTHING;
          break;
        default :
          nextMState = B2B_MFSM_NOTHING;
      } // switch actMState mode OFF
      break;
    case B2B_MODE_BSE :     // trigger kicker (no synchronization to h=1 signal); might by useful for testing
      switch (actMState) {
        case B2B_MFSM_S0 :
          nextMState = B2B_MFSM_EXT_TKICK_C;
          break;
        case B2B_MFSM_EXT_TKICK_C :
          nextMState =  B2B_MFSM_EXT_PMEAS_S;
          break;
        case B2B_MFSM_EXT_PMEAS_S :
          nextMState = B2B_MFSM_EXT_TRIG;
          break;
        case B2B_MFSM_EXT_TRIG :
          nextMState = B2B_MFSM_NOTHING;
          break;
        default:
          nextMState = B2B_MFSM_NOTHING;
      } // switch actMState mode KSE
      break;
    case B2B_MODE_B2E :     // bunch to extraction
      switch (actMState) {
        case B2B_MFSM_S0 :
          nextMState = B2B_MFSM_EXT_PMEAS_S;
          break;
        case  B2B_MFSM_EXT_PMEAS_S :
          nextMState = B2B_MFSM_EXT_PMEAS_R;
          break;
        case B2B_MFSM_EXT_PMEAS_R :
          nextMState = B2B_MFSM_EXT_TNEXTRF_C;
          break;
        case B2B_MFSM_EXT_TNEXTRF_C :
          nextMState = B2B_MFSM_EXT_TRIG;
          break;
        case B2B_MFSM_EXT_TRIG :
          nextMState = B2B_MFSM_NOTHING;
          break;
        default :
          nextMState = B2B_MFSM_NOTHING;
      } // switch actMState mode B2E
      break;
    case B2B_MODE_B2C :     // bunch to coasting beam
      switch (actMState) {
        case B2B_MFSM_S0 :
          nextMState = B2B_MFSM_EXT_PMEAS_S;
          break;
        case B2B_MFSM_EXT_PMEAS_S :
          nextMState = B2B_MFSM_INJ_PMEAS_S;
          break;
        case B2B_MFSM_INJ_PMEAS_S :
          nextMState = B2B_MFSM_EXT_PMEAS_R;
          break;
        case B2B_MFSM_EXT_PMEAS_R :
          nextMState = B2B_MFSM_EXT_TNEXTRF_C;
          break;
        case B2B_MFSM_EXT_TNEXTRF_C :
          nextMState = B2B_MFSM_EXT_TRIG;
          break;
        case B2B_MFSM_EXT_TRIG :
          nextMState = B2B_MFSM_INJ_TRIG ;
          break;
        case B2B_MFSM_INJ_TRIG :
          nextMState = B2B_MFSM_NOTHING;
          break;
        default :
          nextMState = B2B_MFSM_NOTHING;
      } // switch actMState mode B2C
      break;
    case B2B_MODE_B2BFBEAT :     // bunch to bucket, frequency beating
      switch (actMState) {
        case B2B_MFSM_S0 :
          nextMState = B2B_MFSM_EXT_PMEAS_S;
          break;
        case B2B_MFSM_EXT_PMEAS_S :
          nextMState = B2B_MFSM_INJ_PMEAS_S;
          break;
        case B2B_MFSM_INJ_PMEAS_S :
          nPhaseResult = 0;     
          nextMState = B2B_MFSM_ALL_PMEAS_R;
          break;                           
        case B2B_MFSM_ALL_PMEAS_R :                                  // we have a diamond structure: we requested two phase measurements
          nPhaseResult++;                                            // but we don't know which result is received first; the simplest 
          if (nPhaseResult == 2) nextMState = B2B_MFSM_EXT_TFBEAT_C; // solution is to use a counter and count to 2
          else                   nextMState = B2B_MFSM_ALL_PMEAS_R;
          break;
        case B2B_MFSM_EXT_TFBEAT_C :
          nextMState = B2B_MFSM_EXT_TRIG;
          break;
        case B2B_MFSM_EXT_TRIG :
          nextMState = B2B_MFSM_INJ_TRIG ;
          break;
        case B2B_MFSM_INJ_TRIG :
          nextMState = B2B_MFSM_NOTHING;
          break;
        default :
          nextMState = B2B_MFSM_NOTHING;
      } // switch actMState mode B2C
      break;
    case B2B_MODE_B2EPSHIFT :   // bunch to extraction; basically the same as mode B2B_MODE_B2E but with additional phase shift; might be useful for testing
      switch (actMState) {
        case B2B_MFSM_S0 :
          nextMState = B2B_MFSM_EXT_PMEAS_S;
          break;
        case  B2B_MFSM_EXT_PMEAS_S :
          nextMState = B2B_MFSM_EXT_PMEAS_R;
          break;
        case B2B_MFSM_EXT_PMEAS_R :
          nextMState = B2B_MFSM_EXT_PSHIFT_S;
          break;
        case B2B_MFSM_EXT_PSHIFT_S :
          nextMState = B2B_MFSM_EXT_TNEXTRF_C;
          break;
        case B2B_MFSM_EXT_TNEXTRF_C :
          nextMState = B2B_MFSM_EXT_TRIG;
          break;
        case B2B_MFSM_EXT_TRIG :
          nextMState = B2B_MFSM_NOTHING;
          break;
        default :
          nextMState = B2B_MFSM_NOTHING;
      } // switch actMState mode B2EPSHIFT
      break;
      
    default :
      nextMState = B2B_MFSM_NOTHING;
  } // switch mode

  // pp_printf("mode %x, actMState %x nxtMState %x\n", mode, actMState, nextMState);

  return nextMState;
} // getNextMState


// doActionOperation: almost everything happens here
uint32_t doActionOperation(uint32_t actStatus)                // actual status of firmware
{
  uint32_t status;                                            // status returned by routines
  uint32_t flagIsLate;                                        // flag indicating that we received a 'late' event from ECA
  uint32_t flagIsEarly;                                       // flag 'early'
  uint32_t flagIsConflict;                                    // flag 'conflict'
  uint32_t flagIsDelayed;                                     // flag 'delayed'
  uint32_t ecaAction;                                         // action triggered by event received from ECA
  uint64_t sendDeadline;                                      // deadline to send
  uint64_t sendEvtId;                                         // evtID to send
  uint64_t sendParam;                                         // param to send
  uint32_t sendTef;                                           // TEF to send
  uint32_t sendGid;                                           // GID to send
  uint64_t recDeadline;                                       // deadline received
  uint64_t recId;                                             // evt ID received
  uint64_t recParam;                                          // param received
  uint32_t recTef;                                            // TEF received
  uint32_t recGid;                                            // GID received
  uint32_t recSid;                                            // SID received
  uint32_t recBpid;                                           // BPID received
  uint32_t recRes;                                            // reserved bits received
  uint64_t tMatch;                                            // time when phases of injecion and extraction match
  uint64_t tTrig;                                             // time when kickers shall be triggered;
  uint64_t tTrigExt;                                          // time when extraction kicker shall be triggered; tTrigExt = tTrig + cTrigExt;
  uint64_t tTrigInj;                                          // time when injection kicker shall be triggered;  tTrigInj = tTrig + cTrigInj;
  uint16_t offsetFin_us;                                      // offset from deadline CBS to time, when extraction trigger is sent [us, hfloat]
  uint16_t cTrigExt_us;                                       // correction for extraction trigger [half precision, us]
  uint16_t cTrigInj_us;                                       // correction for injection trigger [half precision, us]
  uint16_t cPhase_us;                                         // correction for phase [half precision, us]
  
  uint32_t tmp32;
  float    tmpf;
  fdat_t   tmp;
  uint64_t t1, t2;
  

  status = actStatus;

  ecaAction = fwlib_wait4ECAEvent(COMMON_ECATIMEOUT * 1000, &recDeadline, &recId, &recParam, &recTef, &flagIsLate, &flagIsEarly, &flagIsConflict, &flagIsDelayed);

  switch (ecaAction) {

    case B2B_ECADO_B2B_START :                                // received: CMD_B2B_START from DM; B2B transfer starts
      comLatency   = (int32_t)(getSysTime() - recDeadline); 

      recGid       = (uint32_t)((recId >> 48) & 0x0fff);
      recSid       = (uint32_t)((recId >> 20) & 0x0fff);
      recBpid      = (uint32_t)((recId >>  6) & 0x3fff);

      sid          = (uint32_t)((recId >> 20) & 0x0fff);      // required for proper indexing
      gid          = (uint32_t)((recId >> 48) & 0x0fff);      // temporary assignment useful for debugging if routine setSubmit() fails

      // clear 'local' variables
      flagsExt      = 0x0;
      sidExt        = 0x0;
      bpidExt       = 0x0;
      paramExt      = 0x0;
      flagsInj      = 0x0;
      sidInj        = 0x0;
      bpidInj       = 0x0;
      paramInj      = 0x0;
      mode          = 0x0;
      nHExt         = 0x0;
      nHInj         = 0x0;
      TH1Ext_as     = 0x0;
      TH1Inj_as     = 0x0;
      TBeat_as      = 0x0;
      cPhase_t.ns   = 0x0;
      cPhase_t.ps   = 0x0;
      cTrigExt_t.ns = 0x0;
      cTrigExt_t.ps = 0x0;      
      cTrigInj_t.ns = 0x0;
      cTrigInj_t.ps = 0x0;
      nBucketExt    = 0x0;
      nBucketInj    = 0x0;
      fFineTune     = 0x0;
      fMBTune       = 0x0;
      tCBS          = 0x0;
      nGExt         = 0x0;
      nGInj         = 0x0;
      offsetPrr_us  = 0x0;

      transStat    = 0x0;                                     // reset transfer status
      nTransfer++;                                            // increment transfer counter
      status       = COMMON_STATUS_OK;                        // set to 'ok' if a a new transfer starts

      // submit data and primitive error checks
      if ((status = setSubmit()) != COMMON_STATUS_OK) {mState = B2B_MFSM_NOTHING;          return status;}
      if (sid > 15)                                   {sid = 0; mState = B2B_MFSM_NOTHING; return COMMON_STATUS_OUTOFRANGE;}
      if (!setFlagValid[sid])                         {mState = B2B_MFSM_NOTHING;          return B2B_STATUS_BADSETTING;}

      // copy LSA data needed for proper trigger messages
      flagsExt     = B2B_FLAG_BEAMIN;
      sidExt       = recSid;
      bpidExt      = recBpid;
      paramExt     = recParam;
      flagsInj     = B2B_FLAG_BEAMIN;
      sidInj       = setLSidInj[sid];
      bpidInj      = setLBpidInj[sid];
      paramInj     = setLParamInj[sid];

      // primary data
      gid         = setGid[sid]; 
      mode        = setMode[sid];
      TH1Ext_as   = setTH1Ext_as[sid];
      nHExt       = setNHExt[sid];
      TH1Inj_as   = setTH1Inj_as[sid];
      nHInj       = setNHInj[sid];
      cPhase_t    = fwlib_tfns2tps(setCPhase[sid]);
      cTrigExt_t  = fwlib_tfns2tps(setCTrigExt[sid]);
      cTrigInj_t  = fwlib_tfns2tps(setCTrigInj[sid]);
      
      nBucketExt  = setNBuckExt[sid];
      nBucketInj  = setNBuckInj[sid];
      fFineTune   = setFFinTune[sid];
      fMBTune     = setFMBTune[sid];

      cTrigExt_us = fwlib_float2half(fwlib_tps2tfns(cTrigExt_t)/1000.0); // 16 bit float [us]
      cTrigInj_us = fwlib_float2half(fwlib_tps2tfns(cTrigInj_t)/1000.0); // 16 bit float [us]
      cPhase_us   = fwlib_float2half(fwlib_tps2tfns(cPhase_t)/1000.0);   // 16 bit float [us]

      tCBS        = recDeadline;
      getGeometricHarmonics(gid, &nGExt, &nGInj);

      // initialize approximate/earliest trigger time
      switch (mode) {
        case B2B_MODE_BSE        :   // kick Start, simply trigger at eaerliest deadline; maybe useful for testing
        case B2B_MODE_B2E        :   // fast extraction in phase gap; this is an OR, no 'break' on purpose
        case B2B_MODE_B2C        :   // bunch to coasting beam; transfer between rings; this is an OR, no 'break' on purpose
        case B2B_MODE_B2BFBEAT   :   // bunch to bucket using frequency beating; this is an OR, no 'break' on purpose
          tWantExt = tCBS + B2B_KICKOFFSETMIN;
          break;
        case B2B_MODE_B2EPSHIFT  :   // phase shift followed by fast extraction in bunch gap; maybe useful for testing
        case B2B_MODE_B2BPSHIFTE :   // bunch to bucket using phase shift at extraction machine; this is an OR, no 'break' on purpose
        case B2B_MODE_B2BPSHIFTI :   // bunch to bucket using phase shift at injection machine; this is an OR, no 'break' on purpose
          tWantExt = tCBS + B2B_KICKOFFSETPSHIFT;
          break;
        default :
          tWantExt = tCBS;
          break;
      } // switch mode

      // initialize phase shift values
      switch (mode) {
        case B2B_MODE_B2EPSHIFT  :
          pShiftExt.ns = cPhase_t.ns;                         // chk: temporary solution; in the future this value might be available by a dedicated parameter
          pShiftExt.ps = cPhase_t.ps;                         // chk: temporary solution; in the future this value might be available by a dedicated parameter
          pShiftInj.ns = 0;
          pShiftInj.ps = 0;
          break;
        default :
          pShiftExt.ns = 0;
          pShiftExt.ps = 0;
          pShiftInj.ns = 0;
          pShiftInj.ps = 0;
          break;
      } // switch mode

      mState      = getNextMState(mode, B2B_MFSM_S0);
      errorFlags  = 0x0;
      break;

    case B2B_ECADO_B2B_PREXT :                                 // received: measured phase from extraction machine
      if (mode < B2B_MODE_B2E) return status;                  // ignore informative phase result
      comLatency   = (int32_t)(getSysTime() - recDeadline);
       
      tmpf         = (float)(getSysTime() - tCBS) / 1000.0;    // time from CBS to now [us]
      offsetPrr_us = fwlib_float2half(tmpf);                   // -> half precision
      recGid       = (uint32_t)((recId >> 48) & 0xfff     );
      recSid       = (uint32_t)((recId >> 20) & 0xfff     );
      recRes       = (uint32_t)(recId & 0x3f);                 // lowest 6 bit of EvtId

      // check, if received evtID is valid
      if (recGid != gid)                                                        return COMMON_STATUS_OUTOFRANGE;   
      if (recSid != sid)                                                        return COMMON_STATUS_OUTOFRANGE;
      if ((mState != B2B_MFSM_EXT_PMEAS_R) && (mState != B2B_MFSM_ALL_PMEAS_R)) return COMMON_STATUS_OUTOFRANGE;

      // handling error bits
      if (recRes & B2B_ERRFLAG_PMEXT) errorFlags |= B2B_ERRFLAG_PMEXT;
      
      tH1Ext_t.ns   = recParam;
      tH1Ext_t.ps   = ( int32_t)( int16_t)( recTef & 0x0000ffff);
      tH1Ext_t.dps  = (uint32_t)(uint16_t)((recTef & 0xffff0000) >> 16);
      transStat    |= mState;
      mState        = getNextMState(mode, mState);
      //pp_printf("b2b: %d %u\n", tH1Ext_t.ps, tH1Ext_t.dps);
      //pp_printf("b2b: PREXT %u\n", mState);
      break;

    case B2B_ECADO_B2B_PRINJ :                                 // received: measured phase from injection machine
      if (mode <  B2B_MODE_B2BFBEAT) return status;            // ignore informative phase result
      comLatency    = (int32_t)(getSysTime() - recDeadline);
      tmpf          = (float)(getSysTime() - tCBS) / 1000.0;    // time from CBS to now [us]
      offsetPrr_us  = fwlib_float2half(tmpf);                   // -> half precision
      recGid        = (uint32_t)((recId >> 48) & 0xfff     );
      recSid        = (uint32_t)((recId >> 20) & 0xfff     );
      recRes        = (uint32_t)(recId & 0x3f);               // lowest 6 bit of EvtId

      // check, if received evtID is valid
      if (recGid != gid)             return COMMON_STATUS_OUTOFRANGE;   
      if (recSid != sid)             return COMMON_STATUS_OUTOFRANGE;
      if (mState != B2B_MFSM_ALL_PMEAS_R) return COMMON_STATUS_OUTOFRANGE;

      // handling error bits
      if (recRes & B2B_ERRFLAG_PMINJ) errorFlags |= B2B_ERRFLAG_PMINJ;

      tH1Inj_t.ns   = recParam;
      tH1Inj_t.ps   = ( int32_t)( int16_t)(recTef & 0x0000ffff);
      tH1Inj_t.dps  = (uint32_t)(uint16_t)((recTef & 0xffff0000) >> 16); 

      tH1Inj_t.ns  -= cPhase_t.ns;
      tH1Inj_t.ps  -= cPhase_t.ps;
      transStat    |= mState;
      mState        = getNextMState(mode, mState);
      //pp_printf("b2b: PRINJ %u\n", mState);
      break;

    default :
      return status;                                          // the miniFSM is driven by ECA Events; don't continue if timeout
  } // switch ecaAction

  // trigger at earliest kicker deadline
  if (mState == B2B_MFSM_EXT_TKICK_C) {
    tTrig      = tWantExt;
    transStat |= mState;
    mState     = getNextMState(mode, mState);
  } // B2B_MFSM_EXT_TKICK_C

  // request phase measurement of extraction 
  if (mState == B2B_MFSM_EXT_PMEAS_S) {
    tH1Ext_t.ns    = 0x0;
    tH1Ext_t.ps    = 0x0;
    tH1Ext_t.dps   = 0x0;
    
    // send command: phase measurement at extraction machine
    sendEvtId      = fwlib_buildEvtidV1(gid, B2B_ECADO_B2B_PMEXT, flagsExt, sidExt, bpidExt, 0); 
    sendParam      = TH1Ext_as & 0x000fffffffffffff;                            // use low 52 bit as period
    sendParam     |= (uint64_t)(nGExt & 0xff) << 56;                            // use upper 8 bit as geometric harmonic number
    sendParam     |= (uint64_t)(mode & 0xf)   << 52;                            // use next upper 4 bit as mode info
    sendTef        = (uint32_t)(cTrigExt_us)  << 16;                            // high 16 bit: ext kicker correction
    sendTef       |= (uint32_t)(cTrigInj_us);                                   // low 16 bit : inj kicker correction
    sendDeadline   = tCBS + (uint64_t)B2B_PMOFFSET;                             // fixed deadline relative to CBS
    fwlib_ebmWriteTM(sendDeadline, sendEvtId, sendParam, sendTef, 0);
    transStat     |= mState;
    mState         = getNextMState(mode, mState);
  } // B2B_MFSM_EXT_PMEAS_S

  // request phase measurement of injection
  if (mState == B2B_MFSM_INJ_PMEAS_S) {
    tH1Inj_t.ns    = 0x0;
    tH1Inj_t.ps    = 0x0;
    tH1Inj_t.dps   = 0x0;
    
    // send command: phase measurement at injection machine
    sendEvtId      = fwlib_buildEvtidV1(gid, B2B_ECADO_B2B_PMINJ, flagsInj, sidExt, bpidExt, 0); 
    sendParam      = TH1Inj_as & 0x000fffffffffffff;                            // use low 52 bit as period
    sendParam     |= (uint64_t)(nGInj & 0xff) << 56;                            // use upper 8 bit as geometric harmonic number
    // sendParam: next upper 4 bit: reserved
    sendTef        = (uint32_t)(cPhase_us) << 16;                               // high 16 bit: phase correction, low 16 bit: reserved
    sendDeadline   = tCBS + (uint64_t)B2B_PMOFFSET + 1;                         // fixed deadline relative to B2BS, add 1ns to avoid collision with PMEXT
    fwlib_ebmWriteTM(sendDeadline, sendEvtId, sendParam, sendTef, 0);
    transStat     |= mState;
    mState         = getNextMState(mode, mState);
  } // B2B_MFSM_INJ_PMEAS_S

  // send phase shift request to low-level rf at extraction machine
  if (mState == B2B_MFSM_EXT_PSHIFT_S) {
    // send command: phase shift at extraction machine
    pp_printf("now: EXT_PSHIFT_S\n");
    sendEvtId      = fwlib_buildEvtidV1(gid, B2B_ECADO_B2B_PSHIFTEXT, flagsExt, sidExt, bpidExt, 0);
    // send param: low word: absolute phase shift value [degree, float]
    // chk: N.B. this only works if the absolute phase shift so far is '0'
    tmp.f = 360.0 * fwlib_tps2tfns(pShiftExt)/((float)TH1Ext_as / 1000000000.0);// phase shift [degree, float]
    sendParam      = (uint64_t)(tmp.data);
    tmp.f          = B2B_PHASESHIFTTIME;                                        // time for phase shift [s, float]
    sendParam     |= (uint64_t)(tmp.data) << 32;
    sendDeadline   =  getSysTime() + (uint64_t)COMMON_AHEADT;                   // use a conservative deadline
    fwlib_ebmWriteTM(sendDeadline, sendEvtId, sendParam, 0, 0);
    transStat     |= mState;
    mState         = getNextMState(mode, mState);
  } // B2B_MFSM_EXT_PSHIFT_S

  // prepare fast extraction at ~tWantExt; calculate time for next positive 0-crossing of h=1 signal
  if (mState == B2B_MFSM_EXT_TNEXTRF_C) {
    tWantExt      = tWantExt + pShiftExt.ns; 
    if (errorFlags) tTrig = tWantExt;                                           // plan B
    else if (calcExtTime(&tTrig, tWantExt) != COMMON_STATUS_OK) {
      tTrig       = tWantExt;                                                   // plan B
      errorFlags |= B2B_ERRFLAG_CBU;
    } // if NOT STATUS_OK
    transStat |= mState;
    mState     = getNextMState(mode, mState);
  } // B2B_MFSM_EXT_TNEXTRF_C

  // prepare fast extraction with phase matching between both machines is achieved: calculate trigger time
  if (mState == B2B_MFSM_EXT_TFBEAT_C) {
    //tmp32 = (getSysTime() - tCBS); pp_printf("pre phase match %u\n", tmp32);
    if (errorFlags) {tTrig =  tWantExt;/*pp_printf("b2b: error flags\n");*/}  // plan B
    else if ((status = calcPhaseMatch(tWantExt, &tTrig, &TBeat_as)) != COMMON_STATUS_OK) {
      tTrig       = tWantExt;                                                 // plan B
      errorFlags |= B2B_ERRFLAG_CBU;
      //pp_printf("b2b: error match algorithm, TBeat %lu\n", (uint32_t)(TBeat_as / 1000000000));
    } // if NOT STATUS_OK
    transStat   |= mState;
    mState       = getNextMState(mode, mState);
    //tmp32 = (getSysTime() - tCBS); pp_printf("post phase match %u\n", tmp32);
  } // B2B_MFSM_EXT_TFBEAT_C

  // trigger extraction kicker
  if (mState == B2B_MFSM_EXT_TRIG ) {
    sendGid      =  getTrigGid(1);
    if (!sendGid) return COMMON_STATUS_OUTOFRANGE;
    tTrigExt     = tTrig + cTrigExt_t.ns;                                     // trigger correction; chk: sub-ns part
    offsDone     = getSysTime() - tCBS;
    tmpf         = (float)offsDone / 1000.0;                                  // time from CBS to now [us]
    //tmp32 = (uint32_t)tmpf; pp_printf("sid %d, fin-cbs %u\n", sid, tmp32);
    offsetFin_us = fwlib_float2half(tmpf);
    if (tTrigExt < getSysTime() + (uint64_t)(COMMON_LATELIMIT)) {             // we are too late!
      errorFlags |= B2B_ERRFLAG_CBU;                                          // just set error flag
    } // if tTrigExt
    sendEvtId    = fwlib_buildEvtidV1(sendGid, B2B_ECADO_B2B_TRIGGEREXT, flagsExt, sidExt, bpidExt, errorFlags);
    sendParam    = paramExt;                                                  
    sendTef      = (uint32_t)(offsetFin_us & 0xffff) << 16;                   // high 16 bit: offset 'fin (ready)' to CBS
    sendTef     |= (uint32_t)(offsetPrr_us & 0xffff);                         // low 16 bit: offset 'received PRE' to CBS
    sendDeadline = tTrigExt;
    fwlib_ebmWriteTM(sendDeadline, sendEvtId, sendParam, sendTef, 0);
    transStat   |= mState;
    mState       = getNextMState(mode, mState);
  } // B2B_MFSM_EXT_TRIG

  // trigger injection kicker
  if (mState == B2B_MFSM_INJ_TRIG ) {
    sendGid      =  getTrigGid(0);
    if (!sendGid) return COMMON_STATUS_OUTOFRANGE;
    tTrigInj     = tTrig + cTrigInj_t.ns;                                     // trigger correction; chk: sub-ns part
    if (tTrigInj < getSysTime() + (uint64_t)(COMMON_LATELIMIT)) {             // we are too late!
      errorFlags |= B2B_ERRFLAG_CBU;                                          // set error flag
    } // if tTrigInj
    else { // only trigger kicker if we are not late; in case of stacking a kick at the wrong time might kick out already stored beam
      sendEvtId    = fwlib_buildEvtidV1(sendGid, B2B_ECADO_B2B_TRIGGERINJ, flagsInj, sidInj, bpidInj, errorFlags);
      sendParam    = paramInj;
      sendDeadline = tTrigInj;
      fwlib_ebmWriteTM(sendDeadline, sendEvtId, sendParam, 0, 0);
    } // else tTrigInj
    transStat   |= mState;
    mState       = getNextMState(mode, mState);
  } // B2B_MFSM_INJ_TRIG
  
  if (flagClearAllSid) {clearAllSid(); flagClearAllSid = 0;}

  // check for late event
  if ((status == COMMON_STATUS_OK) && flagIsLate) {
    status = B2B_STATUS_LATEMESSAGE;
    nLate++;
  } // if status
  
  // check WR sync state; worst case, do this last
  if (fwlib_wrCheckSyncState() == COMMON_STATUS_WRBADSYNC) return COMMON_STATUS_WRBADSYNC;
  else                                                     return status;
} // doActionOperation


// main :-)
int main(void) {
  uint32_t status;                              // (error) status
  uint32_t cmd;                                 // command via shared memory
  uint32_t actState;                            // actual FSM state
  uint32_t pubState;                            // published state value
  uint32_t reqState;                            // requested FSM state
  uint32_t sharedSize;                          // size of shared memory
  uint32_t *buildID;                            // WB address of build ID

  // init local variables
  buildID        = (uint32_t *)(INT_BASE_ADR + BUILDID_OFFS);                 // required for 'stack check'

  reqState       = COMMON_STATE_S0;
  actState       = COMMON_STATE_UNKNOWN;
  pubState       = COMMON_STATE_UNKNOWN;
  status         = COMMON_STATUS_OK;
  nTransfer      = 0x0;
  
  init();                                                                     // initialize stuff for lm32
  initSharedMem(&reqState, &sharedSize);                                     // initialize shared memory THIS MUST BE CALLED FIRST
  fwlib_init((uint32_t *)_startshared, cpuRamExternal, SHARED_OFFS, sharedSize, "b2b-cbu", B2BCBU_FW_VERSION); // init common stuff
  fwlib_clearDiag();                                                          // clear common diagnostic data

  while (1) {
    check_stack_fwid(buildID);
    fwlib_cmdHandler(&reqState, &cmd);                                        // check for commands and possibly request state changes
    cmdHandler(&reqState, cmd);                                               // check for project relevant commands
    /* status = COMMON_STATUS_OK;  hm... maybe its better to reset only upon the start of a new transaction                // reset status for each iteration */

    // state machine
    status = fwlib_changeState(&actState, &reqState, status);                 // handle requested state changes
    switch(actState) {                                                        // state specific do actions
      case COMMON_STATE_OPREADY :
        status = doActionOperation(status);
        if (status == COMMON_STATUS_WRBADSYNC)      reqState = COMMON_STATE_ERROR;
        if (status == COMMON_STATUS_ERROR)          reqState = COMMON_STATE_ERROR;
        break;
      default :                                                               // avoid flooding WB bus with unnecessary activity
        status = fwlib_doActionState(&reqState, actState, status);
        break;
    } // switch
    
    // update shared memory
    switch (status) {
      case COMMON_STATUS_OK :                                                 // status OK
        statusArray = statusArray |  (0x1 << COMMON_STATUS_OK);               // set OK bit
        break;
      default :                                                               // status not OK
        if ((statusArray >> COMMON_STATUS_OK) & 0x1) fwlib_incBadStatusCnt(); // changing status from OK to 'not OK': increase 'bad status count'
        statusArray = statusArray & ~((uint64_t)0x1 << COMMON_STATUS_OK);     // clear OK bit
        statusArray = statusArray |  ((uint64_t)0x1 << status);               // set status bit and remember other bits set
        break;
    } // switch status
    
    if ((pubState == COMMON_STATE_OPREADY) && (actState  != COMMON_STATE_OPREADY)) fwlib_incBadStateCnt();
    fwlib_publishStatusArray(statusArray);
    pubState        = actState;
    fwlib_publishState(pubState);
    if (comLatency > maxComLatency) maxComLatency = comLatency;
    if (offsDone   > maxOffsDone)   maxOffsDone   = offsDone;
    fwlib_publishTransferStatus(nTransfer, 0x0, transStat, nLate, maxOffsDone, maxComLatency); 

    // update get values
    *pSharedGetGid        = gid;
    *pSharedGetSid        = sid;
    *pSharedGetMode       = mode;
    /* pp_printf("update, sid %d, mode %d\n", sid, mode); */
    *pSharedGetTH1ExtHi   = (uint32_t)((TH1Ext_as >> 32) & 0xffffffff); 
    *pSharedGetTH1ExtLo   = (uint32_t)( TH1Ext_as        & 0xffffffff);
    *pSharedGetNHExt      = nHExt;
    *pSharedGetTH1InjHi   = (uint32_t)((TH1Inj_as >> 32) & 0xffffffff); 
    *pSharedGetTH1InjLo   = (uint32_t)( TH1Inj_as        & 0xffffffff);
    *pSharedGetNHInj      = nHInj;
    *pSharedGetCPhase     = fwlib_tps2tfns(cPhase_t);
    *pSharedGetCTrigExt   = fwlib_tps2tfns(cTrigExt_t);
    *pSharedGetCTrigInj   = fwlib_tps2tfns(cTrigInj_t);
    *pSharedGetTBeatHi    = (uint32_t)((TBeat_as >> 32)  & 0xffffffff); 
    *pSharedGetTBeatLo    = (uint32_t)( TBeat_as         & 0xffffffff);
  } // while

  return (1); // this should never happen ...
} // main 
