/********************************************************************************************
 *  example.c
 *
 *  created : 2020
 *  author  : Dietrich Beck, GSI-Darmstadt
 *  version : 14-May-2020
 *
 *  lm32 example program using common libraries
 *  
 * -------------------------------------------------------------------------------------------
 * License Agreement for this software:
 *
 * Copyright (C) 2018  Dietrich Beck
 * GSI Helmholtzzentrum fuer Schwerionenforschung GmbH
 * Planckstrasse 1
 * D-64291 Darmstadt
 * Germany
 *
 * Contact: d.beck@gsi.de
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 3 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *  
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library. If not, see <http://www.gnu.org/licenses/>.
 *
 * For all questions and ideas contact: d.beck@gsi.de
 * Last update: 22-November-2018
 ********************************************************************************************/
#define EXAMPLE_FW_VERSION 0x000003                                     // make this consistent with makefile

// standard includes
#include <stdio.h>
#include <string.h>
#include <inttypes.h>
#include <stdint.h>

// includes specific for bel_projects 
#include "dbg.h"                                                        // debug outputs
#include <stack.h>
#include "pp-printf.h"                                                  // print statement
#include "mini_sdb.h"                                                   // sdb stuff
#include "aux.h"                                                        // cpu and IRQ
#include "uart.h"                                                       // WR console

// includes for this project
#include <common-defs.h>                                                // common defs for firmware
#include <common-fwlib.h>                                               // common routines for firmware
#include <example_shared_mmap.h>                                        // autogenerated upon building firmware

// stuff required for environment
extern uint32_t* _startshared[];
unsigned int     cpuId, cpuQty;
#define  SHARED  __attribute__((section(".shared")))
uint64_t SHARED  dummy = 0;

// global variables
// shared mem
volatile uint32_t *pShared;             // pointer to begin of shared memory region
uint32_t *cpuRamExternal;               // external address (seen from host bridge) of this CPU's RAM

// other global stuff
uint32_t statusArray;                   // all status infos are ORed bit-wise into sum status, sum status is then published

// typical init for lm32
void init() 
{
  discoverPeriphery();        // mini-sdb ...
  uart_init_hw();             // needed by WR console   
  cpuId = getCpuIdx();
} // init


// determine address and clear shared mem
void initSharedMem( uint32_t *sharedSize) 
{
  uint32_t idx;
  uint32_t *pSharedTemp;
  int      i; 
  const uint32_t c_Max_Rams = 10;
  sdb_location found_sdb[c_Max_Rams];
  sdb_location found_clu;
  
  // get pointer to shared memory
  pShared           = (uint32_t *)_startshared;

  // get address to data
  // ... insert code here to init pointers to shared RAM
  
  // find address of CPU from external perspective
  idx = 0;
  find_device_multi(&found_clu, &idx, 1, GSI, LM32_CB_CLUSTER);	
  idx = 0;
  find_device_multi_in_subtree(&found_clu, &found_sdb[0], &idx, c_Max_Rams, GSI, LM32_RAM_USER);
  if(idx >= cpuId) cpuRamExternal           = (uint32_t *)(getSdbAdr(&found_sdb[cpuId]) & 0x7FFFFFFF); // CPU sees the 'world' under 0x8..., remove that bit to get host bridge perspective

  DBPRINT2("example: CPU RAM External 0x%8x, begin shared 0x%08x\n", pCpuRamExternal, SHARED_OFFS);
  DBPRINT2("example: fw common shared begin   0x%08x\n", pShared);
  DBPRINT2("example: fw common shared end     0x%08x\n", pShared + (COMMON_SHARED_END >> 2));

  // clear shared mem
  i = 0;
  pSharedTemp        = (uint32_t *)(pShared + (COMMON_SHARED_END >> 2 ) + 1);
  DBPRINT2("example: fw specific shared begin 0x%08x\n", pSharedTemp);

  // ... insert code here to clear shared RAM

  *sharedSize        = (uint32_t)(pSharedTemp - pShared) << 2;
  DBPRINT2("example: used size of shared mem is %d words (uint32_t), begin %x, end %x\n", i, pShared, pSharedTemp-1);
} // initSharedMem 


// clears all statistics
void extern_clearDiag() 
{
  // ... insert code here
} // clearDiag


// entry action configured state
uint32_t extern_entryActionConfigured()
{
  uint32_t status = COMMON_STATUS_OK;

  //... insert code here

  return status;
} // entryActionConfigured


// entry action state 'op ready'
uint32_t extern_entryActionOperation()
{
  uint32_t status = COMMON_STATUS_OK;

  //... insert code here

  return status;
} // entryActionOperation

// exit action state 'op ready'
uint32_t extern_exitActionOperation(){
  uint32_t status = COMMON_STATUS_OK;

  //... insert code here

  return status;
} // exitActionOperation


// command handler, handles commands specific for this project
void cmdHandler(uint32_t *reqState, uint32_t cmd)
{
  // check, if the command is valid and request state change
  if (cmd) {                             // check, if cmd is valid
    switch (cmd) {                       // do action according to command
      // ... insert code here
      default:
        DBPRINT3("wr-unipz: received unknown command '0x%08x'\n", cmd);
        break;
    } // switch 
  } // if command 
} // cmdHandler


// do action state 'op ready' - this is the main code of this FW
uint32_t doActionOperation(uint32_t actStatus)                // actual status of firmware
{
  uint32_t status;                                            // status returned by routines

  status = actStatus;

  // ... insert code here
  
  return status;
} // doActionOperation


int main(void) {
  uint32_t status;                                            // (error) status
  uint32_t cmd;                                               // command via shared memory
  uint32_t actState;                                          // actual FSM state
  uint32_t pubState;                                          // value of published state
  uint32_t reqState;                                          // requested FSM state
  uint32_t sharedSize;                                        // size of shared memory
  uint32_t *buildID;

  // init local variables
  reqState       = COMMON_STATE_S0;
  actState       = COMMON_STATE_UNKNOWN;
  pubState       = COMMON_STATE_UNKNOWN;
  status         = COMMON_STATUS_OK;
  buildID        = (uint32_t *)(INT_BASE_ADR + BUILDID_OFFS);

  // init 
  init();                                                              // initialize stuff for lm32
  initSharedMem(&sharedSize);                                          // initialize shared memory
  fwlib_init((uint32_t *)_startshared, cpuRamExternal, SHARED_OFFS, sharedSize, "example", EXAMPLE_FW_VERSION); // init common stuff
  fwlib_clearDiag();                                                   // clear common diagnostic data

  while (1) {
    check_stack_fwid(buildID);                                         // check for stack corruption
    fwlib_cmdHandler(&reqState, &cmd);                                 // check for common commands and possibly request state changes
    cmdHandler(&reqState, cmd);                                        // check for project relevant commands
    status = COMMON_STATUS_OK;                                         // reset status for each iteration
    status = fwlib_changeState(&actState, &reqState, status);          // handle requested state changes
    switch(actState) {                                                 // state specific do actions 
      case COMMON_STATE_OPREADY :
        status = doActionOperation(status);
        if (status == COMMON_STATUS_WRBADSYNC) reqState = COMMON_STATE_ERROR;
        if (status == COMMON_STATUS_ERROR)     reqState = COMMON_STATE_ERROR;
        break;
      default :                                                        // avoid flooding WB bus with unnecessary activity
        status = fwlib_doActionState(&reqState, actState, status);     // handle do actions states
        break;
    } // switch
    
    // update sum status
    switch (status) {
      case COMMON_STATUS_OK :                                                     // status OK
        statusArray = statusArray |  (0x1 << COMMON_STATUS_OK);                   // set OK bit
        break;
      default :                                                                   // status not OK
        if ((statusArray >> COMMON_STATUS_OK) & 0x1) fwlib_incBadStatusCnt();     // changing status from OK to 'not OK': increase 'bad status count'
        statusArray = statusArray & ~(0x1 << COMMON_STATUS_OK);                   // clear OK bit
        statusArray = statusArray |  (0x1 << status);                             // set status bit and remember other bits set
        break;
    } // switch status
    
    // update shared memory
    if ((pubState == COMMON_STATE_OPREADY) && (actState  != COMMON_STATE_OPREADY)) fwlib_incBadStateCnt();
    fwlib_publishStatusArray(statusArray);
    pubState             = actState;
    fwlib_publishState(pubState);
    
    // ... insert code here to publish your stuff
    
  } // while

  return(1);
} // main
