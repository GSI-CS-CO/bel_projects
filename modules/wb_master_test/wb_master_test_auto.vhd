--! @file        wb_master_test_auto.vhd
--  DesignUnit   wb_master_test_auto
--! @author      M. Kreider <>
--! @date        13/05/2025
--! @version     0.0.1
--! @copyright   2025 GSI Helmholtz Centre for Heavy Ion Research GmbH
--!

--! @brief AUTOGENERATED WISHBONE-SLAVE CORE FOR wb_master_test.vhd
--!
--------------------------------------------------------------------------------
--! This library is free software; you can redistribute it and/or
--! modify it under the terms of the GNU Lesser General Public
--! License as published by the Free Software Foundation; either
--! version 3 of the License, or (at your option) any later version.
--!
--! This library is distributed in the hope that it will be useful,
--! but WITHOUT ANY WARRANTY; without even the implied warranty of
--! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
--! Lesser General Public License for more details.
--!
--! You should have received a copy of the GNU Lesser General Public
--! License along with this library. If not, see <http://www.gnu.org/licenses/>.
--------------------------------------------------------------------------------

-- ***********************************************************
-- ** WARNING - THIS IS AUTO-GENERATED CODE! DO NOT MODIFY! **
-- ***********************************************************
--
-- If you want to change the interface,
-- modify wb_master_test.xml and re-run 'python wbgenplus.py wb_master_test.xml' !

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.wishbone_pkg.all;
use work.wbgenplus_pkg.all;
use work.genram_pkg.all;
use work.wb_master_test_auto_pkg.all;

entity wb_master_test_auto is
Port(
  clk_sys_i         : std_logic;                            -- Clock input for sys domain
  rst_sys_n_i       : std_logic;                            -- Reset input (active low) for sys domain
  error_i           : in  std_logic_vector(1-1 downto 0);   -- Error control
  fuse_read_i       : in  std_logic_vector(32-1 downto 0);  -- Fuse to indicate if the register below has been read.
  fuse_read_V_i     : in  std_logic_vector(1-1 downto 0);   -- Valid flag - fuse_read
  fuse_write_i      : in  std_logic_vector(32-1 downto 0);  -- Fuse to indicate if the register below has been written.
  fuse_write_V_i    : in  std_logic_vector(1-1 downto 0);   -- Valid flag - fuse_write
  stall_i           : in  std_logic_vector(1-1 downto 0);   -- flow control
  write_test_reg_o  : out std_logic_vector(32-1 downto 0);  -- Read/Write register that burns a fuse if it was accessed.
  
  data_i            : in  t_wishbone_slave_in;
  data_o            : out t_wishbone_slave_out

  
);
end wb_master_test_auto;

architecture rtl of wb_master_test_auto is

  signal s_pop, s_push    : std_logic;
  signal s_empty, s_full  : std_logic;
  signal r_e_wait, s_e_p  : std_logic;
  signal s_stall          : std_logic;
  signal s_valid,
         s_valid_ok,
         r_valid_check    : std_logic;
  signal r_ack            : std_logic;
  signal r_err            : std_logic;
  signal s_e, r_e, s_w    : std_logic;
  signal s_d              : std_logic_vector(32-1 downto 0);
  signal s_s              : std_logic_vector(4-1 downto 0);
  signal s_a              : std_logic_vector(2-1 downto 0);
  signal s_a_ext,
         r_a_ext0,
         r_a_ext1         : std_logic_vector(4-1 downto 0);
  signal r_error          : std_logic_vector(1-1 downto 0)  := std_logic_vector(to_unsigned(0, 1)); -- Error
  signal s_error_i        : std_logic_vector(1-1 downto 0)  := (others => '0');                     -- Error control
  signal s_stall_i        : std_logic_vector(1-1 downto 0)  := (others => '0');                     -- flow control
  signal r_fuse_read_V    : std_logic_vector(1-1 downto 0)  := (others => '0');                     -- Valid flag - fuse_read
  signal s_fuse_read_V_i  : std_logic_vector(1-1 downto 0)  := (others => '0');                     -- Valid flag - fuse_read
  signal r_fuse_read      : std_logic_vector(32-1 downto 0) := (others => '0');                     -- Fuse to indicate if the register below has been read.
  signal s_fuse_read_i    : std_logic_vector(32-1 downto 0) := (others => '0');                     -- Fuse to indicate if the register below has been read.
  signal r_read_test_reg  : std_logic_vector(32-1 downto 0) := (others => '0');                     -- Read only register that burns a fuse if it was accessed.
  signal r_fuse_write_V   : std_logic_vector(1-1 downto 0)  := (others => '0');                     -- Valid flag - fuse_write
  signal s_fuse_write_V_i : std_logic_vector(1-1 downto 0)  := (others => '0');                     -- Valid flag - fuse_write
  signal r_fuse_write     : std_logic_vector(32-1 downto 0) := (others => '0');                     -- Fuse to indicate if the register below has been written.
  signal s_fuse_write_i   : std_logic_vector(32-1 downto 0) := (others => '0');                     -- Fuse to indicate if the register below has been written.
  signal r_write_test_reg : std_logic_vector(32-1 downto 0) := (others => '0');                     -- Read/Write register that burns a fuse if it was accessed.


begin

  sp : wb_skidpad
  generic map(
    g_adrbits   => 2
  )
  Port map(
    clk_i        => clk_sys_i,
    rst_n_i      => rst_sys_n_i,
    push_i       => s_push,
    pop_i        => s_pop,
    full_o       => s_full,
    empty_o      => s_empty,
    adr_i        => data_i.adr(3 downto 2),
    dat_i        => data_i.dat,
    sel_i        => data_i.sel,
    we_i         => data_i.we,
    adr_o        => s_a,
    dat_o        => s_d,
    sel_o        => s_s,
    we_o         => s_w
  );

  validmux: with to_integer(unsigned(s_a_ext)) select
  s_valid <= 
  s_fuse_read_V_i(0)  when c_fuse_read_GET,   -- 
  s_fuse_write_V_i(0) when c_fuse_write_GET,  -- 
  '1'                 when others;
  
  s_valid_ok      <=  r_valid_check and s_valid;
  s_e_p           <=  r_e or r_e_wait;
  s_a_ext         <= s_a & "00";
  s_stall         <= s_full;
  s_push          <= data_i.cyc and data_i.stb and not s_stall;
  s_e             <= not (s_empty or s_e_p);
  s_pop           <= s_valid_ok;
  data_o.stall    <= s_stall;
  
  s_error_i         <= error_i;
  s_stall_i         <= stall_i;
  s_fuse_read_V_i   <= fuse_read_V_i;
  s_fuse_read_i     <= fuse_read_i;
  s_fuse_write_V_i  <= fuse_write_V_i;
  s_fuse_write_i    <= fuse_write_i;
  write_test_reg_o  <= r_write_test_reg;
  
  data : process(clk_sys_i)
  begin
    if rising_edge(clk_sys_i) then
      if(rst_sys_n_i = '0') then
        r_e           <= '0';
        r_e_wait      <= '0';
        r_valid_check <= '0';
        r_error           <= std_logic_vector(to_unsigned(0, 1));
        r_fuse_read       <= (others => '0');
        r_read_test_reg   <= X"12345678";
        r_fuse_write      <= (others => '0');
        r_write_test_reg  <= (others => '0');
      else
        r_e           <= s_e;
        r_a_ext0      <= s_a_ext;
        r_a_ext1      <= r_a_ext0;
        r_e_wait      <= s_e_p and not s_valid_ok;
        r_valid_check <= (r_valid_check or (s_e_p and not stall_i(0))) and not s_valid_ok;
        r_ack         <= s_pop and not (error_i(0) or r_error(0));
        r_err         <= s_pop and     (error_i(0) or r_error(0));
        data_o.ack    <= r_ack;
        data_o.err    <= r_err;
        
        
        if stall_i = "0" then
          r_error <= (others => '0');
        end if;
        
        if s_fuse_read_V_i  = "1" then r_fuse_read  <= s_fuse_read_i; end if;   -- 
        if s_fuse_write_V_i = "1" then r_fuse_write <= s_fuse_write_i; end if;  -- 
        
        
        if(s_e = '1') then
          if(s_w = '1') then
            -- WISHBONE WRITE ACTIONS
            case to_integer(unsigned(s_a_ext)) is
              when c_write_test_reg_RW  => r_write_test_reg <= f_wb_wr(r_write_test_reg, s_d, s_s, "owr");  -- 
              when others               => r_error          <= "1";
            end case;
          else
            -- WISHBONE READ ACTIONS
            case to_integer(unsigned(s_a_ext)) is
              when c_fuse_read_GET      => null;
              when c_read_test_reg_GET  => null;
              when c_fuse_write_GET     => null;
              when c_write_test_reg_RW  => null;
              when others               => r_error <= "1";
            end case;
          end if; -- s_w
        end if; -- s_e
        
        case to_integer(unsigned(r_a_ext1)) is
          when c_fuse_read_GET      => data_o.dat <= std_logic_vector(resize(unsigned(r_fuse_read), data_o.dat'length));        -- 
          when c_read_test_reg_GET  => data_o.dat <= std_logic_vector(resize(unsigned(r_read_test_reg), data_o.dat'length));    -- 
          when c_fuse_write_GET     => data_o.dat <= std_logic_vector(resize(unsigned(r_fuse_write), data_o.dat'length));       -- 
          when c_write_test_reg_RW  => data_o.dat <= std_logic_vector(resize(unsigned(r_write_test_reg), data_o.dat'length));   -- 
          when others               => data_o.dat <= (others => 'X');
        end case;

        
      end if; -- rst
    end if; -- clk edge
  end process;

end rtl;
