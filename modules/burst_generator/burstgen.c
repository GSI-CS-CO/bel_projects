/*******************************************************************************
 *  burstgen.c (derived from lm32 example)
 *
 *  created : 2019, GSI Darmstadt
 *  author  : Enkhbold Ochirsuren
 *  version : 20-Jun-2022
 *
 *  This firmware, burst generator, is targeted to the soft-core LM32 CPU and
 *  dedicated to generate the burst signals at the IO pin of Timing Receivers.
 *
 *  Inside TR the burst generation is based on the timing event handling with
 *  the ECA unit: the ECA condition table is configured with specific rules
 *  for the embedded CPU (eCPU) actions and IO actions. The eCPU actions
 *  are triggered by the external timing messages, which are received from the
 *  WR timing network and used to control the burst generator operation.
 *  Unlike it, the IO actions are triggered by the internal timing events, which
 *  are sent internally by LM32 and control the IO output to drive the output
 *  signals. In other words, the signal bursts are generated by 2 kinds
 *  of timing messages:
 *  - external messages (alias control events) from the timing network
 *  - internal messages (alias IO events) sent by the burst generator.
 *
 *  From user point of view the signal bursts are generated in 2 steps:
 *   1. Configuration - burst parameters are provided to the burst generator
 *      using the host tools or user application
 *   2. Production - once the configuration is complete desired bursts are
 *      generated by the control events
 *
 *  In order to demonstrate the burst generation a special SAFTlib tool,
 *  saft-burst-ctl, can be used besides this burst generator firmware.
 *
 *  build:  make clean && make TARGET=burstgen
 *  deploy: scp burstgen.bin root@scuxl0304.acc:.
 *  load:   eb-fwload dev/wbm0 u 0x0 burstgen.bin
 *  run:    eb-reset dev/wbm0 cpureset 0 (assume only one LM32 is instantiated)
 *  debug:  eb-console dev/wbm0
 *
 * -----------------------------------------------------------------------------
 * License Agreement for this software:
 *
 * Copyright (C) 2017  Dietrich Beck
 * GSI Helmholtzzentrum für Schwerionenforschung GmbH
 * Planckstraße 1
 * D-64291 Darmstadt
 * Germany
 *
 * Contact: d.beck@gsi.de
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 3 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library. If not, see <http://www.gnu.org/licenses/>.
 *
 * For all questions and ideas contact: d.beck@gsi.de
 * Last update: 25-April-2015
 ******************************************************************************/

/* standard includes */
#include <stdio.h>
#include <string.h>
#include <inttypes.h>
#include <stdint.h>

/* includes specific for bel_projects */
#include "mprintf.h"
#include "mini_sdb.h"
#include "aux.h"
#include "dbg.h"
#include "syscon.h"
#include "stack.h"

/* common lib includes */
#include <common-defs.h>
#include <common-fwlib.h>

#include "bg.h" // burst generation

/* function prototypes */
void initSharedBuffers(void);                      // initialize the command and its argument buffers
void buildTimingMsg(uint32_t *msg, uint32_t id);   // build timing message
void injectTimingMsg(uint32_t *msg);               // inject timing message to ECA event input
void ecaHandler(uint32_t);                         // pop pending eCPU actions from ECA queue
void cmdHandler(uint32_t *actState, uint32_t *reqState, uint32_t cmd); // handle user command received from the host

int ecaMsiHandler(int id);           // handler for the ECA MSIs
int hostMsiHandler(int id);          // handler for the host MSIs
int triggerIoActions(int id);        // trigger IO actions to generate pulses

void setupTimingMsg(uint32_t *msg);  // build default timing msg for IO action, estimate the duration of message injection to the ECA event input
void setupMsiHandlers(void);         // set up MSI handlers
void setupTasks(void);               // set up tasks for the IO actions and host communication, initialize the trg/tgg config table

/* definitions of MSI message buffers */
enum {
  ECA_MSI = 0,
  HOST_MSI,
  N_MSI_BUF
};

/* task configuration table */
static Task_t tasks[N_BURSTS];        // each burst is produced by a corresponding task
static Task_t *pTask = &tasks[0];     // task table pointer
static uint32_t gBurstsCreated = 0x0; // created bursts, bitwise, bit 0 = burst 1
static uint32_t gBurstsCycled = 0x0;  // triggered & completed bursts, bitwise, bit 0 = burst 1

volatile struct message_buffer msg_buf[N_MSI_BUF] = {0};   // MSI message buffers
volatile struct message_buffer *pMsgBufHead = &msg_buf[0]; // pointer to MSI msg buffer head

uint32_t bufTimMsg[LEN_TIM_MSG];  // buffer of timing message for IO action (will be sent by this LM32)

/* burst trigger/toggle control */
static Config_t gTrigConfigs[N_CONFIGS] = {0, 0}; // configuration table for the burst trigger events
static Config_t gToggConfigs[N_CONFIGS] = {0, 0}; // configuration table for the burst toggle events

static Control_t gTrigCtrl = {0, 0};
static Control_t gToggCtrl = {0, 0};

/* stuff required for environment */
unsigned int cpuId, cpuQty;
#define SHARED __attribute__((section(".shared")))
uint64_t SHARED dummy = 0;

// global variables
volatile uint32_t *pEcaCtl;         // WB address of ECA control
volatile uint32_t *pEca;            // WB address of ECA event input (discoverPeriphery())
volatile uint32_t *pECAQ;           // WB address of ECA queue
volatile uint32_t *pShared;         // pointer to begin of shared memory region
volatile uint32_t *pCpuRamExternal; // external address (seen from host bridge) of this CPU's RAM
extern volatile uint32_t *pSharedCmd; // user command buffer in the shared memory
volatile uint32_t *pSharedInput;    // pointer to a "user defined" u32 register; here: get input from host system
volatile uint32_t *pMbSlotHost;     // WB address of a mailbox slot subscribed by a host system

uint64_t gInjection = 0;            // time duration for local message injection to ECA event input
int gEcaChECPU = 0;                 // ECA channel for an embedded CPU (LM32), connected to ECA queue pointed by pECAQ
int mbSlotLm32 = -1;                // slot number in mailbox subscribed by LM32, no slot is subscribed by default

uint32_t statusArray;               // all status infos are ORed bit-wise into sum status, sum status is then published

/* stuff for built-in measurements */
#define N_ELAPSED  4                // points to measure elapsed time to handle ECA MSIs
uint64_t tElapsed[N_ELAPSED] = {0};
#define N_ACT_CNT  5                // counters for ECA MSIs
volatile uint32_t *pSharedActCnt;   // pointer to ECA action counters (located at shared memory)

enum MSR_TASK_PERFORMACE {          // offset for measurements
  MSR_TICK_FIRST_TASK = 0,          // time point to execute the first IO action task
  MSR_TASK_INTERVAL = N_BURSTS,     // current interval of all IO action tasks
  MSR_TASK_INTERVAL_MAX,            // maximum interval of all IO action tasks
  N_MSR_TASK_PERFORMANCE
};

int enableSchedulerMeasure = 1;     // control flag to dis/enable the scheduler period measurement (cmd 0x77 toggles it)
uint64_t msrCnt = 0;                // measurement count, reset with the user command CMD_DIAG_PRINT_TASK_INTERVAL
uint64_t msrTickActEntr = 0;        // entry time point of IO action task
uint64_t msrTickActExit = 0;        // exit time point of IO action task
int taskIdx = 1;                    // current task index, iterate all tasks except a dummy task with index 0
volatile uint64_t msrTaskTiming[N_MSR_TASK_PERFORMANCE];  // timing performance measurements for all IO action tasks
uint32_t ecaActCounters[N_ACT_CNT];

static void msrInitActionTiming(void)
{
  if (pShared) {
    pSharedActCnt = ecaActCounters;
    msrCnt = 0;

    // clear ECA action counters and buffer for measurements
    memset(pSharedActCnt, 0, sizeof(uint32_t) * N_ACT_CNT);
    memset(msrTaskTiming, 0, sizeof(uint64_t) * N_MSR_TASK_PERFORMANCE);

    uint32_t offset = (uint32_t)(&msrTaskTiming[1]) - (uint32_t)pShared;
    mprintf("IO task stats (1..%d) available @ 0x%08x (ext)\n",
        N_BURSTS-1,
        (uint32_t)(pCpuRamExternal + ((SHARED_OFFS + offset) >> 2)));

    offset = (uint32_t)(&msrTaskTiming[N_BURSTS]) - (uint32_t)pShared;
    mprintf("IO task intervals (current, maximum) available @ 0x%08x (ext)\n",
	(uint32_t)(pCpuRamExternal + ((SHARED_OFFS + offset) >> 2)));

    mprintf("Built-in measurements are %s.\n", enableSchedulerMeasure ? "enabled" : "disabled");
  }
  else {
    pSharedActCnt = 0;
    mprintf("No built-in measurements!\n");
  }
}

/**
 * \brief Measure performance of the main loop
 *
 * The IO action functions are called to inject internal events
 * for generating bursts. Because of a strict timing constraint each burst
 * must be re-triggered within 200 us period. The violation of this period
 * causes an unexpected termination of bursts.
 *
 * Hence, 2 timing factors are measured: task duration and intervals between neighbor tasks.
 * These will be measured by noting task entry and exit time points.
 *
 * \param[in] taskIdx   Task index, 1..N_BURSTS
 * \param[in] msrTickActEntr  Action entry time point (updated before this function call)
 * \param[in] msrTickActExit  Action complete time point (updated after this function call)
 **/
static void msrMeasureActionTiming(int taskIdx, uint64_t msrTickActEntr, uint64_t msrTickActExit)
{
  if (enableSchedulerMeasure == 0)
    return;

  uint64_t value = msrTaskTiming[taskIdx];  // get value of the last measurement
  uint64_t duration = value & 0xffffffff;   // average duration of the current task
  uint64_t distance = value >> 32;          // average distance from a previous task
  uint64_t now = getSysTime();

  // calculate the average duration of task execution
  value = now - msrTickActEntr;
  duration = (value + (duration * msrCnt))/(msrCnt + 1);

  // calculate the average distance to a previous task
  if (msrTickActExit) {
    value = now - msrTickActExit;
    distance = (value + (distance * msrCnt))/(msrCnt + 1);
  }

  // store the measurements (hi32:distance, lo32:duration)
  msrTaskTiming[taskIdx] = (distance << 32) | duration;

  // measure the total duration of all tasks (1..N_BURSTS)
  if (taskIdx == 1)                               // keep the timestamp of the first io task
  {
    msrTaskTiming[MSR_TICK_FIRST_TASK] = msrTickActEntr;
  }
  else if (taskIdx == (N_BURSTS - 1))             // the last io task is done
  {
    if (msrTaskTiming[MSR_TICK_FIRST_TASK]) {
      msrTaskTiming[MSR_TASK_INTERVAL] = msrTickActEntr - msrTaskTiming[MSR_TICK_FIRST_TASK];   // update time interval to execute all IO action tasks

      if (msrTaskTiming[MSR_TASK_INTERVAL] > msrTaskTiming[MSR_TASK_INTERVAL_MAX]) {            // update the maximum interval
	msrTaskTiming[MSR_TASK_INTERVAL_MAX] = msrTaskTiming[MSR_TASK_INTERVAL];
      }
    }

    msrCnt++;
  }
}

/**
 * \brief Measure performance of the main loop
 *
 * The IO action functions are called to inject internal events
 * for generating bursts. Because of a strict timing constraint each burst
 * must be re-triggered within 200 us period. The violation of this period
 * causes an unexpected termination of bursts.
 *
 * This function measures the period of action, where all IO action tasks are run to completion.
 * The initial duration measurement is ignored.
 *
 * \param[in] msrTickActEntr  Action entry time point (updated before this function call)
 * \param[in] msrTickActExit  Action complete time point (updated after this function call)
 **/
static void msrMeasureActionPeriod(uint64_t msrTickActEntr, uint64_t msrTickActExit)
{
  if (enableSchedulerMeasure == 0)
    return;

  uint64_t value = msrTaskTiming[0];        // get value of the last measurement
  uint64_t duration = value & 0xffffffff;   // average duration of all tasks
  uint64_t distance = value >> 32;          // average distance from a previous action
  uint64_t now = getSysTime();

  // calculate the average duration of all tasks
  value = now - msrTickActEntr;
  duration = (value + (duration * msrCnt))/(msrCnt + 1);

  // calculate the average distance from a previous action
  if (msrTickActExit) {
    value = now - msrTickActExit;
    distance = (value + (distance * msrCnt))/(msrCnt + 1);

    // determine the extremes
    msrTaskTiming[MSR_TASK_INTERVAL] = value;   // update time interval to execute all IO action tasks

    if (msrTaskTiming[MSR_TASK_INTERVAL] > msrTaskTiming[MSR_TASK_INTERVAL_MAX])  // update the maximum interval
      msrTaskTiming[MSR_TASK_INTERVAL_MAX] = msrTaskTiming[MSR_TASK_INTERVAL];

    msrCnt++;
  }

  // store the measurements (hi32:distance, lo32:duration)
  msrTaskTiming[0] = (distance << 32) | duration;
}

void printMsiHandleMeasurement(void)
{
  mprintf("\tiH  %x:%8x\n", (uint32_t)(tElapsed[0] >> 32), (uint32_t)tElapsed[0]);
  uint64_t p = tElapsed[1] - tElapsed[0];
  mprintf("\teM< %x:%8x\n", (uint32_t)(p >> 32), (uint32_t)p);
  p = tElapsed[2] - tElapsed[1];
  mprintf("\teH  %x:%8x\n", (uint32_t)(p >> 32), (uint32_t)p);
  p = tElapsed[3] - tElapsed[1];
  mprintf("\teM> %x:%8x\n", (uint32_t)(p >> 32), (uint32_t)p);
  memset(tElapsed, 0, sizeof(uint64_t) * N_ELAPSED);
}

void printTrgTggCtlCfg(void)
{
  mprintf("\n\tbursts, deadline\n\t");
  mprintf("trig: 0x%x, 0x%Lx\n\t", gTrigCtrl.bursts, gTrigCtrl.deadline);
  mprintf("togg: 0x%x, 0x%Lx\n", gToggCtrl.bursts, gToggCtrl.deadline);
  mprintf("\n\tevent id : bursts\n\t");

  for (int i = 0; i < N_CONFIGS; ++i) {
    mprintf("%Lx:%x ", gTrigConfigs[i].id, gTrigConfigs[i].bursts);
    if (((i + 1) % 4) == 0)
      mprintf("\n\t");
  }

  mprintf("\n\t");
  for (int i = 0; i < N_CONFIGS; ++i) {
    mprintf("%Lx:%x ", gToggConfigs[i].id, gToggConfigs[i].bursts);
    if (((i + 1) % 4) == 0)
      mprintf("\n\t");
  }
}

int printSharedInput(int start, int end)
{
  int i = 0;
  for (i = start; i < end; ++i)
    mprintf("%8x @ 0x%x\n", *(pSharedInput +i), (uint32_t)(pSharedInput +i));

  return i;
}

static int printTaskContext(int id) {
  int cnt;
  cnt =  mprintf(" 0x%x: 0x%x,", id, pTask[id].flag);
  cnt += mprintf(" 0x%x, 0x%x,", pTask[id].io_type, pTask[id].io_index);
  cnt += mprintf(" 0x%Lx, 0x%Lx\n", pTask[id].trigger, pTask[id].toggle);
  return cnt;
}

/*******************************************************************************
 * \brief Update the control event configuration table
 *
 * Control events are timing messages that are defined to control the burst
 * generation. There are 2 kinds of control events:
 * - trigger: start the burst generation
 * - toggle:  stop/restart the burst generation
 *
 * On creation of bursts such control events are assigned to target bursts.
 * These assignments are recorded in the control event configuration table.
 *
 * \param[in] configs  Control event configuration table
 * \param[in] e_id     Event ID to trigger/toggle the specified burst
 * \param[in] id       Burst ID
 * \param[in] set      Set or reset the configuration
 ******************************************************************************/
static int updateConfigs(Config_t *configs, uint64_t e_id, int id, int set) {

  int i, pos = N_CONFIGS;

  if (configs == 0)          // null pointer check
    return pos;

  if (e_id == 0 || id == 0)  // allow only non-zero event id and burst id
    return pos;

  // determine if a configuration already exists
  for (i = 0; i < N_CONFIGS; ++i)
    if ((configs + i)->id == e_id)
      pos = i;

  i = 0;
  while ((pos == N_CONFIGS) && (i < N_CONFIGS)) {
    if ((configs + i)->id == 0) {
      pos = i;
      i = N_CONFIGS;
    }
    ++i;
  }

  if (pos == N_CONFIGS)
    return pos;

  // set or reset the configuration entry
  if (set) {
    (configs + pos)->bursts |= 0x1 << (id - 1);
    (configs + pos)->id = e_id;
  }
  else {
    (configs + pos)->bursts &= ~(0x1 << (id -1));
    if ((configs + pos)->bursts == 0 )
      (configs + pos)->id = 0;
  }

  return pos;
}
/*******************************************************************************
 *
 * Trigger IO actions to generate pulses at IO pin
 *
 ******************************************************************************/
int triggerIoActions(int id) {

  int result = STATUS_OK;

  if (id == 0)
    return result;

  // check trigger/toggle control flags
  uint32_t bMask = 0x1 << (id - 1);

  // setup burst generation
  if (gTrigCtrl.bursts & bMask) {  // trigger flag is set
    gTrigCtrl.bursts &= ~bMask;
    pTask[id].lasttick = 0;
    pTask[id].failed = 0;
    pTask[id].deadline = gTrigCtrl.deadline + pTask[id].setup; // initial block will be delayed for the setup period
  }
  else if (gToggCtrl.bursts & bMask) { // toggle flag is set
    gToggCtrl.bursts &= ~bMask;
    if (pTask[id].deadline == 0) {     // cycle never run or already stopped, cancel it
      pTask[id].cycle = 0;
    }
    else if (pTask[id].deadline >= gToggCtrl.deadline) {  // deadline is over, stop immediatelly
      pTask[id].deadline = 0;
      pTask[id].cycle = 0;
      gBurstsCycled |= (0x1 << (id - 1));
    }
    else if (pTask[id].cycle != 0) { // update remaining cycle (consider endless loop)
      uint64_t remaining = gToggCtrl.deadline - pTask[id].deadline;
      if (remaining < pTask[id].period)
	pTask[id].cycle = 1;
      else
	pTask[id].cycle = remaining / pTask[id].period + 1;
    }
  }

  if (pTask[id].cycle == 0)        // production cycle is over, cannot trigger!
    result = STATUS_NOT_READY;

  if (pTask[id].flag & CTL_EN == CTL_DIS)   // burst is disabled, do not trigger!
    result = STATUS_DISABLED;

  if (pTask[id].deadline == 0)     // deadline is unset, cannot trigger!
    result = STATUS_NOT_READY;

  uint64_t deadline = pTask[id].deadline;
  uint64_t now = getSysTime();
  int64_t elapsed_injection = deadline - now;

  *(bufTimMsg   ) = EVT_ID_IO_H32 + (id << 4); // update peripheral timing message
  *(bufTimMsg +6) = hiU32(deadline);
  *(bufTimMsg +7) = loU32(deadline);

  if (elapsed_injection <= 0) // late!
  {
    if (pTask[id].failed == 0)
      pTask[id].failed = now;
    result = STATUS_ERR;
  }

  if (result != STATUS_OK)
  {
    // delay generation: 183 for 7376 ns (doubled time duration to execute the trigger operations)
    // 150/6320 ns, 120/5888 ns, 100/5248, 90/4928, 70/4288
    for (int i = 0; i < 150; i++) // FIXME: extended the dry-run period
      asm("nop");

    return result;
  }
  else if ((pTask[id].lasttick == 0) ||
      (( elapsed_injection < pTask[id].period) && // next period of a pulse block or initial injection (depends on lasstick)
      (pTask[id].lasttick < now)))               // the only injection in this period
  {
    injectTimingMsg(bufTimMsg);  // inject internal timing message for IO actions
    pTask[id].action = now;

    pTask[id].lasttick = pTask[id].deadline; // update the task timestamp
    pTask[id].deadline += pTask[id].period;  // update deadline for next trigger

    if (pTask[id].cycle > 0)     // verify and update the production cycle
    {
      if (--pTask[id].cycle == 0)
      {
	pTask[id].deadline = 0;
	gBurstsCycled |= (0x1 << (id - 1));
      }
    }
    return result;
  }

  return STATUS_IDLE;
}

/*******************************************************************************
 *
 * Clear failed actions
 *
 ******************************************************************************/
void clearFailedActions()
{
  atomic_on();

  *(pEcaCtl + (ECA_CHANNEL_SELECT_RW >> 2)) = gEcaChECPU;    // select ECA channel for LM32
  *(pEcaCtl + (ECA_CHANNEL_NUM_SELECT_RW >> 2)) = 0;         // set the subchannel index to 0

  *(pEcaCtl + (ECA_CHANNEL_CODE_SELECT_RW >> 2)) = (ECA_FG_DELAYED >> 16);
  *(pEcaCtl + (ECA_CHANNEL_FAILED_COUNT_GET >> 2));          // read and clear the delayed counter
  *(pEcaCtl + (ECA_CHANNEL_CODE_SELECT_RW >> 2)) = (ECA_FG_CONFLICT >> 16);
  *(pEcaCtl + (ECA_CHANNEL_FAILED_COUNT_GET >> 2));          // read and clear the conflict counter
  *(pEcaCtl + (ECA_CHANNEL_CODE_SELECT_RW >> 2)) = (ECA_FG_EARLY >> 16);
  *(pEcaCtl + (ECA_CHANNEL_FAILED_COUNT_GET >> 2));          // read and clear the early counter
  *(pEcaCtl + (ECA_CHANNEL_CODE_SELECT_RW >> 2)) = (ECA_FG_LATE >> 16);
  *(pEcaCtl + (ECA_CHANNEL_FAILED_COUNT_GET >> 2));          // read and clear the late counter

  atomic_off();
}

/*******************************************************************************
 *
 * Clear old actions
 *
 ******************************************************************************/
void clearOldActions()
{
  atomic_on();

  *(pEcaCtl + (ECA_CHANNEL_SELECT_RW >> 2)) = gEcaChECPU;    // select ECA channel for LM32
  *(pEcaCtl + (ECA_CHANNEL_NUM_SELECT_RW >> 2)) = 0;         // set the subchannel index to 0

  uint32_t full  = *(pEcaCtl + (ECA_CHANNEL_MOSTFULL_ACK_GET >> 2)) & 0xFFFF0000;
  full >>= 16;
  for (int i = 0; i < full; ++i)
    *(pECAQ + (ECA_QUEUE_POP_OWR >> 2)) = 0x1;               // clear the fill status of the ECA channel for LM32

  *(pEcaCtl + (ECA_CHANNEL_OVERFLOW_COUNT_GET >> 2));        // read and clear the overflow counter
  *(pEcaCtl + (ECA_CHANNEL_VALID_COUNT_GET >> 2));           // read and clear the valid counter

  atomic_off();

  clearFailedActions();
}

/*******************************************************************************
 *
 * Handle pending valid actions
 *
 ******************************************************************************/
void handleValidActions()
{
  uint32_t valCnt;
  atomic_on();
  *(pEcaCtl + (ECA_CHANNEL_SELECT_RW >> 2)) = gEcaChECPU;    // select ECA channel for LM32
  *(pEcaCtl + (ECA_CHANNEL_NUM_SELECT_RW >> 2)) = 0;         // set the subchannel index to 0
  valCnt = *(pEcaCtl + (ECA_CHANNEL_VALID_COUNT_GET >> 2));  // read and clear valid counter
  atomic_off();
  //mprintf("\nvalid=%d\n", valCnt);
  tElapsed[2] = getSysTime();

  if (valCnt != 0)
    ecaHandler(valCnt);                             // pop pending valid actions

  if (pSharedActCnt) {
    valCnt = *(pSharedActCnt);
    *(pSharedActCnt) = ++valCnt;                    // count the valid actions (cnt value at +0x00)

    if (valCnt == 0) {                              // something went wrong to read the valid action counter!
      valCnt = *(pSharedActCnt + 3);                // count the not-valid actions (cnt value at +0x0c)
      *(pSharedActCnt +3) = ++valCnt;
    }
  }
}

/*******************************************************************************
 *
 * Handle a pending ECA MSI
 *
 ******************************************************************************/
int ecaMsiHandler(int id)
{
  if (has_msg(pMsgBufHead, ECA_MSI)) {

    struct msi m = remove_msg(pMsgBufHead, ECA_MSI);

    tElapsed[1] = getSysTime();
    tElapsed[2] = tElapsed[1];
    uint32_t cnt = 0;
    //mprintf("\nMSI 0x%08x (h16: 0-3 fail, 4 vald, 5 ovrflw, 6 full)\n", m.msg); // debugging, remove later

    switch (m.msg & ECA_FG_MASK)
    {
      case ECA_FG_VALID: // valid actions are pending
	handleValidActions(); // ECA MSI handling
	break;
      case ECA_FG_MOSTFULL:
	if (pSharedActCnt) {
	  cnt = *(pSharedActCnt +1);
	  *(pSharedActCnt +1) = ++cnt; // count the full messages (cnt value at +0x04)
	}
	break;
      case ECA_FG_LATE:
	clearFailedActions();
	if (pSharedActCnt) {
	  cnt = *(pSharedActCnt +4);
	  *(pSharedActCnt +4) = ++cnt; // count the late actions (cnt value at +0x10)
	}
	break;
      default:
	clearFailedActions();
	if (pSharedActCnt) {
	  cnt = *(pSharedActCnt +2);
	  *(pSharedActCnt +2) = ++cnt; // count other actions (cnt value at +0x08)
	}
	break;
    }

    tElapsed[3] = getSysTime();
  }

  return STATUS_OK;
}

/*******************************************************************************
 *
 * Configure ECA to send MSI to embedded soft-core LM32:
 * - MSI is sent on production of actions for the ECA action
 *   channel for LM32
 * - ECA action channel is selected and MSI target address of LM32 is set in the
 *   ECA MSI target register
 *
 * @param[in] enable  Enable or disable ECA MSI
 * @param[in] channel The index of the selected ECA action channel
 *
 ******************************************************************************/
void configureEcaMsi(int enable, uint32_t channel) {

  if (enable != 0 && enable != 1) {
    mprintf("Bad enable argument. %s\n", errMsgEcaMsi);
    return;
  }

  if (channel > ECAQMAX) {
    mprintf("Bad channel argument. %s\n", errMsgEcaMsi);
    return;
  }

  clearOldActions();     // clean ECA queue and channel from previous actions

  atomic_on();
  *(pEcaCtl + (ECA_CHANNEL_SELECT_RW >> 2)) = channel;            // select channel
  *(pEcaCtl + (ECA_CHANNEL_NUM_SELECT_RW >> 2)) = 0;         // set the subchannel index to 0
  *(pEcaCtl + (ECA_CHANNEL_MSI_SET_ENABLE_OWR >> 2)) = 0;         // disable ECA MSI (required to set a target address)
  *(pEcaCtl + (ECA_CHANNEL_MSI_SET_TARGET_OWR >> 2)) = (uint32_t)pMyMsi;  // set MSI destination address as a target address
  *(pEcaCtl + (ECA_CHANNEL_MSI_SET_ENABLE_OWR >> 2)) = enable;    // enable ECA MSI
  atomic_off();

  mprintf("\nMSI path (ECA -> LM32)      : %s\n\tECA channel = %d\n\tdestination = 0x%08x\n",
          enable == 1 ? "enabled" : "disabled", channel, (uint32_t)pMyMsi);
}

/*******************************************************************************
 *
 * Respond to host request
 *
 * @param[in] data Response data to host request
 *
 ******************************************************************************/
void respondToHost(uint32_t data)
{
  if (pMbSlotHost) {
    *pMbSlotHost = data;
    //mprintf("\t0x%x is written into 0x%x\n", data, (uint32_t)pMbSlotHost);
  }
}

/*******************************************************************************
 *
 * Check if unhandled MSI messages exist
 *
 * /return  status  Returns non-zero value if unhandled MSI messages exist
 *
 ******************************************************************************/
int hasPendingMsi(void)
{
  return (has_msg(pMsgBufHead, ECA_MSI) || has_msg(pMsgBufHead, HOST_MSI));
}

/*******************************************************************************
 *
 * Handle MSIs
 *
 * Any WB device connected to MSI crossbar as a master can send MSIs: ECA, SCU bus etc.
 * Besides data value, an MSI message includes also a destination address.
 * In order to identify a particular sender, LM32 has to inform them distinct
 * MSI destinations as its destination address.
 *
 * Handling ECA MSIs
 * If interrupt was caused by a valid ECA action, then MSI has value of (4<<16|num).
 * Both ECA action channel and ECA queue connected to that channel must be handled:
 * - read and clear the valid counter value of ECA action channel for LM32 and,
 * - pop pending actions from ECA queue connected to this action channel
 *
 ******************************************************************************/
void irqHandler() {

  struct msi m;
  m.msg = global_msi.msg;
  m.adr = global_msi.adr;

  uint32_t sender = m.adr & MSI_OFFS_MASK;
  switch (sender) {

    case MSI_OFFS_ECA:     // ECA
      tElapsed[0] = getSysTime();

      add_msg(pMsgBufHead, ECA_MSI, m);
      break;

    case MSI_OFFS_HOST:    // HOST
      add_msg(pMsgBufHead, HOST_MSI, m);
      break;

    default:
      mprintf("%s: %x Unknown MSI sender. Cannot handle MSI!\n", m.adr);
  }
  //mprintf(" MSI:\t%08x\nAdr:\t%08x\nSel:\t%01x\n", global_msi.msg, global_msi.adr, global_msi.sel);
}

/*******************************************************************************
 *
 * Initialize interrupt table
 * - set up an interrupt handler
 * - enable interrupt generation globally
 *
 ******************************************************************************/
void initIrqTable() {
  isr_table_clr();
  memset((void *)pMsgBufHead, 0, N_MSI_BUF * sizeof(struct message_buffer));
  if (hasPendingMsi())
  {
    mprintf("MSI buffers are not empty!!!\n");
    mprintf("Cannot enable interrupt!!!\n");
    return;
  }
  else
    mprintf("MSI buffers are clean.\n");

  isr_ptr_table[0] = &irqHandler;
  irq_set_mask(0x01);
  irq_enable();
  mprintf("Init IRQ table is done.\n");
}

/*******************************************************************************
 *
 * \brief Initialize the shared memory pointers
 *
 * - pShared: points to the head of the shared memory
 * - pCpuRamExternal: points also to the shared memory, but from the host bridge perspective
 *
 * Determine the size of shared memory reserved for the application.
 *
 * \param[out] sharedSize Size of an area in the allocated memory (in bytes)
 *
 * \return status Return status
 ******************************************************************************/
status_t initSharedMem(uint32_t *sharedSize)
{
  uint32_t i,j;
  uint32_t idx;

  const uint32_t c_Max_Rams = 10;
  sdb_location found_sdb[c_Max_Rams];
  sdb_location found_clu;

  // get pointer to shared memory; internal perspective of this LM32
  pShared        = (uint32_t *)_startshared;                // begin of shared mem

  // print pointer info to UART
  mprintf("\n");
  mprintf("Internal shared memory    @ 0x%08x\n", (uint32_t)pShared);

  // get pointer to shared memory; external perspective from host bridge
  idx = 0;
  find_device_multi(&found_clu, &idx, 1, GSI, LM32_CB_CLUSTER);
  idx = 0;
  find_device_multi_in_subtree(&found_clu, &found_sdb[0], &idx, c_Max_Rams, GSI, LM32_RAM_USER);
  if(idx >= cpuId) {
    pCpuRamExternal = (uint32_t*)(getSdbAdr(&found_sdb[cpuId]) & 0x7FFFFFFF); // CPU sees the 'world' under 0x8..., remove that bit to get host bridge perspective
    // print external WB info to UART
    mprintf("External shared memory    @ 0x%08x\n", (uint32_t)(pCpuRamExternal + (SHARED_OFFS >> 2)));
  } else {
    pCpuRamExternal = (uint32_t*)ERROR_NOT_FOUND;
    mprintf("Could not find external WB address of my own RAM !\n");
    return COMMON_STATUS_ERROR;
  }

  initSharedBuffers();       // initialize the command and its argument buffers (in the shared memory)

  *sharedSize = BG_SHARED_END;
  return COMMON_STATUS_OK;
}

/*******************************************************************************
 * \brief Set up application relevant stuff
 ******************************************************************************/
void setup(void)
{
  setupTimingMsg(bufTimMsg);        // build default timing msg for IO action, estimate the duration of message injection to the ECA event input
  setupMsiHandlers();               // set up MSI handlers
  setupTasks();                     // set up tasks for the IO actions and host communication, initialize the trg/tgg config table
  // TODO: remove it after updating saft-burst-ctl
  DBPRINT1("wrote FW ID %x at loc 0x%08x\n", BG_FW_ID, (uint32_t)(pShared + (BG_SHARED_BEGIN >> 2)));
  *(pShared + (BG_SHARED_BEGIN >> 2)) = BG_FW_ID; // label the starting point of the shared memory with the firmware id
}

/*******************************************************************************
 *
 * Subscribe a slot in mailbox
 *
 * Check mailbox slots starting from the second slot. If a slot has the same
 * destination address, then re-use it. If a slot is free, then subscribe it.
 *
 * @param[in] offset  Offset address used to recognize a sender.
 * /return    slot    Subscribed slot number. Returns -1, if no free slot is found.
 *
 ******************************************************************************/
int subscribeMboxSlot(uint32_t offset)
{
  uint32_t myDestAddr = (uint32_t)(pMyMsi + (offset >> 2));
  uint32_t destination;
  unsigned char notFound = 1;
  uint8_t slot = 1;

  atomic_on();
  while (notFound && (slot < 128))
  {
    destination = *(pCpuMsiBox + (slot << 1)); // get destination address
    if (destination == myDestAddr)             // slot has my destination address
      notFound = 0;
    else if (destination == 0xffffffff) {      // slot is free, subscribe it
      cfgMsiBox(slot,offset);
      notFound = 0;
    }
    else
      slot++;
  }
  atomic_off();

  return (notFound ? -1 : slot);
}

/*******************************************************************************
 *
 * Find WB address of ECA queue connect to ECA channel for LM32
 *
 * - ECA queue address is set to "pECAQ"
 * - index of ECA channel for LM32 is set to "gEcaChECPU"
 *
 * /return  status  Return OK if a queue is found, otherwise return ERROR
 *
 ******************************************************************************/
uint32_t findEcaQueue()
{
  sdb_location EcaQ_base[ECAQMAX];
  uint32_t EcaQ_idx = 0;
  uint32_t *tmp;
  int i;

  // get list of ECA queues
  find_device_multi(EcaQ_base, &EcaQ_idx, ECAQMAX, ECA_QUEUE_SDB_VENDOR_ID, ECA_QUEUE_SDB_DEVICE_ID);
  pECAQ = 0x0;

  // find ECA queue connected to ECA channel for LM32
  for (i=0; i < EcaQ_idx; i++) {
    tmp = (uint32_t *)(getSdbAdr(&EcaQ_base[i]));
    //mprintf("-- found ECA queue 0x%08x, idx %d\n", (uint32_t)tmp, i);
    if ( *(tmp + (ECA_QUEUE_QUEUE_ID_GET >> 2)) == ECACHANNELFORLM32) {
      pECAQ = tmp;    // update global variables
      gEcaChECPU = ECACHANNELFORLM32 +1; // refer to eca_queue_regs.h
      i = EcaQ_idx;   // break loop
    }
  }

  return (pECAQ ? STATUS_OK : STATUS_ERR);
}

/*******************************************************************************
*
* Pop pending eCPU actions from an ECA queue and handle them
*
* @param[in] cnt The number of pending valid actions
*
*******************************************************************************/
void ecaHandler(uint32_t cnt)
{
  uint32_t flag;                // flag for the next action
  uint32_t evtIdHigh;           // event id (high 32bit)
  uint32_t evtIdLow;            // event id (low 32bit)
  uint32_t evtDeadlHigh;        // deadline (high 32bit)
  uint32_t evtDeadlLow;         // deadline (low 32bit)
  uint32_t actTag;              // tag of action
  uint32_t paramHigh;           // event parameter (high 32bit)
  uint32_t paramLow;            // event parameter (low 32bit)
  uint64_t evtId;

  for (int i = 0; i < cnt; ++i) {  // TODO: avoid loop!!!
    // read flag and check if there was an action
    flag         = *(pECAQ + (ECA_QUEUE_FLAGS_GET >> 2));
    if (flag & (0x0001 << ECA_VALID)) {
      // read data
      evtIdHigh    = *(pECAQ + (ECA_QUEUE_EVENT_ID_HI_GET >> 2));
      evtIdLow     = *(pECAQ + (ECA_QUEUE_EVENT_ID_LO_GET >> 2));
      evtDeadlHigh = *(pECAQ + (ECA_QUEUE_DEADLINE_HI_GET >> 2));
      evtDeadlLow  = *(pECAQ + (ECA_QUEUE_DEADLINE_LO_GET >> 2));
      actTag       = *(pECAQ + (ECA_QUEUE_TAG_GET >> 2));
      paramHigh    = *(pECAQ + (ECA_QUEUE_PARAM_HI_GET >> 2));
      paramLow     = *(pECAQ + (ECA_QUEUE_PARAM_LO_GET >> 2));

      // pop action from channel
      *(pECAQ + (ECA_QUEUE_POP_OWR >> 2)) = 0x1;

      // here: do s.th. according to action
      if (actTag == MY_ACT_TAG) {
        //mprintf("id: 0x%08x:%08x; deadline: 0x%08x:%08x; param: 0x%08x:%08x; flag: 0x%08x\n",
          //      evtIdHigh, evtIdLow, evtDeadlHigh, evtDeadlLow, paramHigh, paramLow, flag);

	toU64(evtIdHigh, evtIdLow, evtId);

	uint64_t deadline, param;

	toU64(evtDeadlHigh, evtDeadlLow, deadline);
	toU64(paramHigh, paramLow, param);

        /* Deadline specifies the time point to trigger configured action.
         * Additionally, external delay is given in the parameter field.
         * An initial action will be delayed for the setup period, in which
         * the burst head is generated by the IO actions. After the setup period
         * LM32 takes the control to generate the burst body.*/
	if (param)
	  deadline +=param;       // apply an external delay

	// find an entry with the given e_id in the config table
	// update control flag
	// - check if the flag equals to zero before update
	// - check the forbidden state (trig and togg must not be set at the same time)
	int trigger_idx = N_CONFIGS;
	int toggle_idx = N_CONFIGS;

	for (int j = 0; j < N_CONFIGS; ++j) { // FIXME: search takes longer! Make it periodic with const short execution time!
	  if ((gTrigConfigs + j)->id == evtId)
	    trigger_idx = j;
	  if ((gToggConfigs + j)->id == evtId)
	    toggle_idx = j;
	}

	if (trigger_idx != N_CONFIGS) {

	  gTrigCtrl.bursts |= (gTrigConfigs + trigger_idx)->bursts;
	  gTrigCtrl.deadline = deadline;

	  if ((gToggCtrl.bursts & gTrigCtrl.bursts) != 0) {
	    // Conflict: toggle and trigger for the same bursts! TODO: react!
	  }
	}
	else if (toggle_idx != N_CONFIGS) {

	  gToggCtrl.bursts |= (gToggConfigs + toggle_idx)->bursts;
	  gToggCtrl.deadline = deadline;

	  if ((gTrigCtrl.bursts & gToggCtrl.bursts) != 0) {
	    // Conflict: trigger and toggle for the same bursts! TODO: react
	  }
	}
      }
    }
  }
}

/*******************************************************************************
 *
 * Execute commands received from host
 *
 * @param[i]  cmd  Predefined command code
 *
 ******************************************************************************/
void execHostCmd(int32_t cmd)
{
  int result = STATUS_OK;
  uint64_t e_id;
  uint32_t h32, l32, id;
  int first, last;
  // check, if a command has been issued (no cmd: 0x0)
  if (cmd) {
    mprintf("\ncmd 0x%x: ", cmd);
    switch (cmd) {

      case CMD_SHOW_ALL:    // show pulse parameters
	mprintf("show\n");  // show actual state

	id = *pSharedInput;
	if (0 < id && id < N_BURSTS) {
	  mprintf("id = 0x%x, flag=0x%x\n", id, pTask[id].flag);
	  mprintf("trig=0x%x:%x, togg=0x%x:%x\n",
	    (uint32_t)(pTask[id].trigger >> 32),  (uint32_t)pTask[id].trigger,
	    (uint32_t)(pTask[id].toggle >> 32),   (uint32_t)pTask[id].toggle);
	  mprintf("cycle=0x%x:%x, period=0x%x:%x, deadln=0x%x:%x, action=0x%x:%x\n",
	    (uint32_t)(pTask[id].cycle >> 32),    (uint32_t)pTask[id].cycle,
	    (uint32_t)(pTask[id].period >> 32),   (uint32_t)pTask[id].period,
	    (uint32_t)(pTask[id].deadline >> 32), (uint32_t)pTask[id].deadline,
	    (uint32_t)(pTask[id].action >> 32),   (uint32_t)pTask[id].action);
	}
	else if (id == 0) {
	  for (int i = 1; i < N_BURSTS; ++i) {
	    if (pTask[i].flag & CTL_VALID) {
	      mprintf("id = 0x%x, flag=0x%x\n", i, pTask[id].flag);
	      mprintf("trig=0x%x:%x, togg=0x%x:%x\n",
		(uint32_t)(pTask[i].trigger >> 32),  (uint32_t)pTask[i].trigger,
		(uint32_t)(pTask[i].toggle >> 32),   (uint32_t)pTask[i].toggle);
	      mprintf("cycle=0x%x:%x, period=0x%x:%x, deadln=0x%x:%x, action=0x%x:%x\n",
		(uint32_t)(pTask[i].cycle >> 32),    (uint32_t)pTask[i].cycle,
		(uint32_t)(pTask[i].period >> 32),   (uint32_t)pTask[i].period,
		(uint32_t)(pTask[i].deadline >> 32), (uint32_t)pTask[i].deadline,
                (uint32_t)(pTask[id].action>> 32),   (uint32_t)pTask[id].action);
	    }
	  }
	}
	break;

      case CMD_GET_PARAM:    // get the parameters of a given burst
	mprintf("get parameters\n");

	id = *pSharedInput;
	if (0 < id && id < N_BURSTS) {
	  if ((pTask[id].flag & CTL_VALID) != 0) {
	    uint32_t b_flag = *(pSharedInput + GET_PARAM_FLAG);
	    if (b_flag == 1)
	      pTask[id].period += *(pSharedInput + GET_PARAM_PERIOD);
	    else
	      pTask[id].period = *(pSharedInput + GET_PARAM_PERIOD);
            pTask[id].setup = *(pSharedInput + GET_PARAM_SETUP);

	    if (*(pSharedInput + GET_PARAM_VERBOSE)) // verbose
	      printSharedInput(0, N_GET_PARAM);
	  }
	}
	else {
	  result = STATUS_ERR;
	  mprintf("failed: %d\n", id);
	  break;
	}
	break;

      case CMD_GET_CYCLE:    // get the number of cycles (cycles * period of a pulse block) of the given burst
	mprintf("get cycle\n");

	id = *pSharedInput;
	if (0 < id && id < N_BURSTS) {
	  if ((pTask[id].flag & CTL_VALID) != 0) {
	    toU64(*(pSharedInput +1), *(pSharedInput +2), pTask[id].cycle);

	    if (*(pSharedInput + 3)) // verbose
	      printSharedInput(0, 3);

	    pTask[id].deadline = 0;
	  }
	}
	else {
	  result = STATUS_ERR;
	  mprintf("failed: %d\n", id);
	  break;
	}
	break;

      case CMD_RD_MSI_ECPU: // read the ECA MSI settings for eCPU
	mprintf("read MSI cfg\n");

	atomic_on();
	*(pEcaCtl + (ECA_CHANNEL_SELECT_RW >> 2)) = gEcaChECPU;              // select channel for eCPU
	*(pEcaCtl + (ECA_CHANNEL_NUM_SELECT_RW >> 2)) = 0;         // set the subchannel index to 0
	uint32_t dest   = *(pEcaCtl + (ECA_CHANNEL_MSI_GET_TARGET_GET >> 2));  // get MSI destination address
	uint32_t enable = *(pEcaCtl + (ECA_CHANNEL_MSI_GET_ENABLE_GET >> 2));  // get the MSI enable flag
	atomic_off();

	mprintf("MSI dest addr   = 0x%08x\n", dest);
	mprintf("MSI enable flag = 0x%x\n", enable);

	break;

      case CMD_RD_ECPU_CHAN: // read the content of the ECA eCPU channel
	mprintf("read eCPU chan counter\n");

	atomic_on();
	*(pEcaCtl + (ECA_CHANNEL_SELECT_RW >> 2)) = gEcaChECPU;    // select ECA channel for eCPU
	*(pEcaCtl + (ECA_CHANNEL_NUM_SELECT_RW >> 2)) = 0;         // set the subchannel index to 0
	uint32_t valid    = *(pEcaCtl + (ECA_CHANNEL_VALID_COUNT_GET >> 2));
	uint32_t overflow = *(pEcaCtl + (ECA_CHANNEL_OVERFLOW_COUNT_GET >> 2));
	uint32_t failed   = *(pEcaCtl + (ECA_CHANNEL_FAILED_COUNT_GET >> 2));
	uint32_t full     = *(pEcaCtl + (ECA_CHANNEL_MOSTFULL_ACK_GET >> 2));
	atomic_off();
	mprintf("failed: 0x%x, valid: 0x%x, overflow: 0x%x, full: 0x%x\n",
		  failed, valid, overflow, full);
	break;

      case CMD_RD_ECPU_QUEUE: // read the content of ECA queue connected to eCPU channel
	mprintf("read eCPU queue\n");

	atomic_on();
	*(pEcaCtl + (ECA_CHANNEL_SELECT_RW >> 2)) = gEcaChECPU;    // select ECA channel for eCPU
	*(pEcaCtl + (ECA_CHANNEL_NUM_SELECT_RW >> 2)) = 0;         // set the subchannel index to 0
	uint32_t flag      = *(pECAQ + (ECA_QUEUE_FLAGS_GET >> 2));
	uint32_t evtHigh   = *(pECAQ + (ECA_QUEUE_EVENT_ID_HI_GET >> 2));
	uint32_t evtLow    = *(pECAQ + (ECA_QUEUE_EVENT_ID_LO_GET >> 2));
	uint32_t tag       = *(pECAQ + (ECA_QUEUE_TAG_GET >> 2));
	uint32_t paramHigh = *(pECAQ + (ECA_QUEUE_PARAM_HI_GET >> 2));
	uint32_t paramLow  = *(pECAQ + (ECA_QUEUE_PARAM_LO_GET >> 2));
	atomic_off();
	mprintf("event: 0x%08x:%08x, param: 0x%08x:%08x, tag: 0x%08x, flag: 0x%08x\n",
		  evtHigh, evtLow, paramHigh, paramLow, tag, flag);
	break;

      case CMD_LS_BURST: // list burst (if id==0, then IDs of available bursts are written into memory, otherwise burst info)
	mprintf("ls burst\n");

	id = *pSharedInput;
	uint32_t verbose = *(pSharedInput + 1);

	if (id == 0) {
	  *pSharedInput = gBurstsCreated;
	  *(pSharedInput + 1) = gBurstsCycled;

	  if (verbose)
	    mprintf(" created: 0x%x, cycled: 0x%x\n", gBurstsCreated, gBurstsCycled);

	  gBurstsCycled = 0; // clear after read
	}
	else if (id < N_BURSTS) {
	  *(pSharedInput + INFO_IO_TYPE)       = (uint32_t)pTask[id].io_type;  // IO type and index (type << 16| index)
	  *(pSharedInput + INFO_IO_IDX)        = (uint32_t)pTask[id].io_index;
	  *(pSharedInput + INFO_START_EVT_H32) = (uint32_t)(pTask[id].trigger >> 32); // trigger event id
	  *(pSharedInput + INFO_START_EVT_L32) = (uint32_t)pTask[id].trigger;
	  *(pSharedInput + INFO_STOP_EVT_H32)  = (uint32_t)(pTask[id].toggle >> 32); // get toggle event id
	  *(pSharedInput + INFO_STOP_EVT_L32)  = (uint32_t)pTask[id].toggle;
	  *(pSharedInput + INFO_LOOPS_H32)     = (uint32_t)(pTask[id].cycle >> 32); // get cycle count
	  *(pSharedInput + INFO_LOOPS_L32)     = (uint32_t)pTask[id].cycle;
          *(pSharedInput + INFO_ACTION_H32)    = (uint32_t)(pTask[id].action >> 32); // get action time
	  *(pSharedInput + INFO_ACTION_L32)    = (uint32_t)pTask[id].cycle;
	  *(pSharedInput + INFO_FLAG)          = (uint32_t)pTask[id].flag;

	  if (verbose)
	    printSharedInput(0, N_BURST_INFO);
	}
	else {
	  result = STATUS_ERR;
	  mprintf("failed: %d\n", id);
	  break;
	}
	break;

      case CMD_MK_BURST: // declare burst with the id number
	mprintf("new burst\n");

	id = *pSharedInput;
	verbose = *(pSharedInput + 6);

	if (0 < id && id < N_BURSTS) {
	  l32 = *(pSharedInput +1); // IO type and index (type << 16| index)
	  pTask[id].io_type = (uint8_t)(l32 >> 16);
	  pTask[id].io_index = (uint8_t)l32;
	  h32 = *(pSharedInput +2); // get trigger event id
	  l32 = *(pSharedInput +3);
	  toU64(h32, l32, e_id);
	  pTask[id].trigger = e_id;

	  h32 = *(pSharedInput +4); // get toggle event id
	  l32 = *(pSharedInput +5);
	  toU64(h32, l32, e_id);
	  pTask[id].toggle = e_id;

	  pTask[id].period = 0;
	  pTask[id].cycle = 0;
	  pTask[id].deadline = 0;
	  pTask[id].state = 0;
	  pTask[id].flag = CTL_VALID;
	  gBurstsCreated |= 0x1 << (id - 1);

	  // update trigger/toggle configuration tables
	  if (pTask[id].trigger)
	    updateConfigs(gTrigConfigs, pTask[id].trigger, id, 1);
	  if (pTask[id].toggle)
	    updateConfigs(gToggConfigs, pTask[id].toggle, id, 1);

	  if (verbose)
	    printTaskContext(id);
	}
	else {
	  result = STATUS_ERR;
	  mprintf("failed: %d\n", id);
	  break;
	}
	break;

      case CMD_RM_BURST: // remove burst
	mprintf("remove burst\n");

	id = *pSharedInput;
	verbose = *(pSharedInput + 1);

	if (0 < id && id < N_BURSTS) {
	  pTask[id].flag = CTL_DIS;
	  gBurstsCreated &= ~(0x1 << (id -1));

	  // update trigger/toggle configuration tables
	  if (pTask[id].trigger)
	    updateConfigs(gTrigConfigs, pTask[id].trigger, id, 0);
	  if (pTask[id].toggle)
	    updateConfigs(gToggConfigs, pTask[id].toggle, id, 0);

	  pTask[id].io_type = 0;
	  pTask[id].io_index = 0;
	  pTask[id].trigger = 0;
	  pTask[id].toggle = 0;

	  if (verbose)
	    printTaskContext(id);
	}
	else {
	  result = STATUS_ERR;
	  mprintf("failed: %d\n", id);
	  break;
	}
	break;

      case CMD_DE_BURST: // dis/enable burst with the id number (=0 all)
	mprintf("dis/enable burst\n");

	id = *pSharedInput;                   // burst id
	uint32_t disen = *(pSharedInput + 1); // dis/enable selection

	verbose = *(pSharedInput +2);         // verbose
	first = -1;
	last = -1;

	if (id == 0) {
	  first = 1;
	  last = N_BURSTS - 1;
	}
	else if (id < N_BURSTS) {
	  first = last = id;
	}
	else {
	  result = STATUS_ERR;
	  mprintf("failed: %d\n", id);
	  break;
	}

	if ((pTask[id].flag & CTL_VALID) == CTL_DIS) { // break here, if burst is undeclared
	  result = STATUS_ERR;
	  mprintf("unknown: %d\n", id);
	  break;
	}

	for (int i = first; i <= last; ++i) {
	  if (disen)
	    pTask[id].flag |= CTL_EN;
	  else
	    pTask[id].flag &= ~CTL_EN;

	  if (verbose)
	    printTaskContext(id);
	}
	break;

      case CMD_LS_FW_ID: // list the firmware id
	mprintf("fw id\n");
	*pSharedInput = BG_FW_ID;
	break;

      /* diagnostic commands used in firmware development */
      case CMD_DIAG_PRINT_MSI_HANDLE_DURATION: // print elapsed time to handle MSIs
	mprintf("MSI handle\n");
	printMsiHandleMeasurement();
	break;

      case CMD_DIAG_PRINT_IO_EVENT_CTRL_CFG: // print the trigger/toggle control and trigger/toggle configuration tables
	mprintf("trg/tgg\n");
	printTrgTggCtlCfg();
	break;

      case CMD_DIAG_PRINT_TASK_INTERVAL: // print elapsed time between tasks (requires the burst id)
	mprintf("task ticks\n");
        mprintf("\tid, lasttick, failed\n");
	id = *pSharedInput;
	if (id) {
	  mprintf("\t%d, 0x%016Lx, 0x%016Lx\n", id, pTask[id].lasttick, pTask[id].failed);
	} else {
	  for (int i = 1; i < N_BURSTS; ++i)
	    mprintf("\t%d, 0x%016Lx, 0x%016Lx\n", i, pTask[i].lasttick, pTask[i].failed);
	}

        // print all statistics
        uint64_t sum = 0;

        mprintf("\ttask distance:duration (cnt=%Lu)\n", msrCnt);
        for (int i = 0; i < N_BURSTS; i++) {
          mprintf("\t %2d %8x:%8x\n", i, (uint32_t)(msrTaskTiming[i] >> 32), (uint32_t)(msrTaskTiming[i]));
          sum += msrTaskTiming[i];
        }
        mprintf("\t sum %8x:%8x\n", (uint32_t)(sum >> 32), (uint32_t)sum);
	mprintf("Task intervals: cur=0x%Lx, max=0x%Lx\n", msrTaskTiming[MSR_TASK_INTERVAL], msrTaskTiming[MSR_TASK_INTERVAL_MAX]);

	msrInitActionTiming(); // reset measurements

	break;

      case CMD_DIAG_TOGGLE_MEASUREMENT: // dis/enable to measure the task scheduler period
        mprintf("toggle measurement\n");

	enableSchedulerMeasure ^= 1;

        msrInitActionTiming(); // reset measurements

	break;

      default:
	mprintf("unknown\n");
	result = STATUS_ERR;
    }

    cmd = (result << 16) | (cmd & CMD_MASK); // both instruction result and instruction code are sent by MSI
    respondToHost((uint32_t)cmd);
  }
}

/*******************************************************************************
 *
 * Handle a pending host MSI
 *
 ******************************************************************************/
int hostMsiHandler(int id)
{
  if (has_msg(pMsgBufHead, HOST_MSI)) {

    struct msi m = remove_msg(pMsgBufHead, HOST_MSI);
    execHostCmd(m.msg);
  }

  return STATUS_OK;
}

/*******************************************************************************
 * \brief Handle user commands received from the host
 *
 * Handle user commands in the 'configured' state only.
 * Otherwise, commands are denied.
 *
 * \param[in] actState Actual state
 * \param[in] reqState Requested state
 * \param[in] cmd      User command code
 *
 ******************************************************************************/
void cmdHandler(uint32_t *actState, uint32_t *reqState, uint32_t cmd)
{
  if (*actState == COMMON_STATE_CONFIGURED) {  // 'configured' state
    execHostCmd(cmd);
  }
  else {                                       // other states
    uint32_t response = (STATUS_ERR << 16) | (cmd & CMD_MASK); // instruction result and instruction code are sent by MSI
    respondToHost((uint32_t)response);
  }
}

/*******************************************************************************
*
* Initialize dedicated buffers in shared memory
*
*******************************************************************************/
void initSharedBuffers(void)
{
  pSharedInput = (uint32_t *)(pShared + (BG_SHARED_INPUT >> 2));   // get pointer to shared input buffer

  // location of the command buffer is defined by common-libs
  DBPRINT("Command buffer (ext)      @ 0x%08x (0x%08x)\n",
      (uint32_t)pSharedCmd, (uint32_t)(pCpuRamExternal + ((BG_SHARED_CMD + SHARED_OFFS) >> 2)));
  mprintf("Argument buffer (ext)     @ 0x%08x (0x%08x)\n",
      (uint32_t)pSharedInput, (uint32_t)(pCpuRamExternal + ((BG_SHARED_INPUT + SHARED_OFFS) >> 2)));
}

/*******************************************************************************
 *
 * Set up MSI handlers
 *
 ******************************************************************************/
void setupMsiHandlers(void)
{
  mbSlotLm32 = subscribeMboxSlot(MSI_OFFS_HOST); // MSIs are forwarded to destination address of (pMyMsi + MSI_OFFS_HOST)

  if (mbSlotLm32 == -1)  {
    mprintf("Could not find free slot in mailbox. Exit!\n");
    return;
  }
  else  {
    if (pShared)
    {
      *(pShared + (BG_SHARED_MB_SLOT_LM32 >> 2)) = mbSlotLm32; // write the subscribed mailbox slot into the shared memory
    }
    else
    {
      mprintf("Logic error: shared memory must be initialized prior to the mailbox slot subscription");
      return;
    }

    uint32_t *pMbSlotLm32 = (uint32_t *)pCpuMsiBox + ((mbSlotLm32 * 8) >> 2);
    mprintf("\nMailbox slot for LM32 (burst generator):\n"
        "- number=0x%x\n"
        "- addr (intern)=0x%x\n"
        "- addr (extern)=0x%x\n",
	mbSlotLm32,
        (uint32_t)(pShared + (BG_SHARED_MB_SLOT_LM32 >> 2)),
	(uint32_t)(pCpuRamExternal + ((BG_SHARED_MB_SLOT_LM32 + SHARED_OFFS) >> 2)));
    mprintf("WB addr of LM32 mailbox slot:\n"
        "- addr (intern)=0x%x\n"
        "- addr (extern)=0x%x\n",
        (uint32_t)pMbSlotLm32,
        (uint32_t)pMbSlotLm32 & 0x7FFFFFFF);
  }

  configureEcaMsi(1, gEcaChECPU); // ECA MSIs are sent to destination address of pMyMsi

  initIrqTable();     // set up MSI handler

  // get a mailbox slot subscribed by host
  int mbSlotHost = *(pShared + (BG_SHARED_MB_SLOT_HOST >> 2));
  if (mbSlotHost == MB_SLOT_CFG_FREE || mbSlotHost == 0)       // valid slot ranges are 1-127
    mprintf("Invalid mailbox slot for host = 0x%x\n", mbSlotHost);
  else {
    pMbSlotHost = pCpuMsiBox + (mbSlotHost << 1);
    mprintf("\nMailbox slot for the host:\n"
        "- number=0x%x\n"
        "- addr (intern)=0x%x\n"
        "- addr (extern)=0x%x\n",
        mbSlotHost,
	(uint32_t)(pShared + (BG_SHARED_MB_SLOT_HOST >> 2)),
	(uint32_t)(pCpuRamExternal + ((BG_SHARED_MB_SLOT_HOST + SHARED_OFFS) >> 2)));
    mprintf("WB address of host mailbox slot:\n"
        "- addr (intern)=0x%x\n"
        "- addr (extern)=0x%x\n",
        (uint32_t)pMbSlotHost,
        (uint32_t)pMbSlotHost & 0x7FFFFFFF);
  }
}

/*******************************************************************************
 * \brief Set up tasks
 *
 * Tasks with indices 1..N_BURSTS-1 are used to generate bursts
 *
 ******************************************************************************/
void setupTasks(void)
{
  memset((void *)gTrigConfigs, 0, N_CONFIGS * sizeof(Config_t));
  memset((void *)gToggConfigs, 0, N_CONFIGS * sizeof(Config_t));

  for (int taskIdx = 0; taskIdx < N_BURSTS; ++taskIdx)
  {
    pTask[taskIdx].state = 0;
    pTask[taskIdx].flag = CTL_DIS;
    pTask[taskIdx].trigger = 0;
    pTask[taskIdx].toggle = 0;
    pTask[taskIdx].cycle = 0;
    pTask[taskIdx].period = 0;
    pTask[taskIdx].deadline = 0;
    pTask[taskIdx].interval = ALWAYS;
    pTask[taskIdx].lasttick = 0;
    pTask[taskIdx].failed = 0;
    pTask[taskIdx].func = triggerIoActions;
  }
}

/*******************************************************************************
 *
 * Build a timing message
 *
 * @param[out] msg The location of message buffer
 * @param[in]  id  The event id
 *
 ******************************************************************************/
void buildTimingMsg(uint32_t *msg, uint32_t id)
{
  *msg = id; // FID+GID*EVTNO+flags
  *(msg +1) = 0x0; // SID+BPID+resrv
  *(msg +2) = 0x0; // param_up
  *(msg +3) = 0x0; // param_lo
  *(msg +4) = 0x0; // resrv
  *(msg +5) = 0x0; // TEF
  *(msg +6) = 0x0;
  *(msg +7) = 0x0;

  /*mprintf("\nconstructed timing msg:\n");
  mprintf("event: %x-%x\n",msg[0], msg[1]);
  mprintf("param: %x-%x\n",msg[2], msg[3]);
  mprintf("resrv: %x\n",msg[4]);
  mprintf("TEF  : %x\n",msg[5]);*/
}

/*******************************************************************************
 *
 * Inject the given timing message to the ECA event input
 *
 * @param[in] msg The location of message buffer
 *
 ******************************************************************************/
void injectTimingMsg(uint32_t *msg)
{
  atomic_on();

  for (int i = 0; i < LEN_TIM_MSG; i++)
    *pEca = msg[i];

  atomic_off();
}

/*******************************************************************************
 *
 * Set up internal timing message for the IO actions
 *
 * @param[in]  msg  The location of the timing message buffer
 *
 ******************************************************************************/
void setupTimingMsg(uint32_t *msg)
{
  buildTimingMsg(msg, EVT_ID_IO_H32); // build the default timing message for the IO actions

  // estimate the time duration of message injection
  uint64_t deadline = getSysTime(); // start measurement

  *(msg +6) = hiU32(deadline); // deadline can be late, don't care it
  *(msg +7) = loU32(deadline);

  injectTimingMsg(msg);        // inject a dummy message

  pTask[0].lasttick = pTask[0].deadline; // post-injection operations
  pTask[0].deadline += pTask[0].period;
  pTask[0].cycle = 1;

  if (pTask[0].cycle > 0)
  {
    if (--pTask[0].cycle == 0)
    {
      pTask[0].deadline = 0;
      gBurstsCycled |= (0x0 << (1 - 1));
    }
  }

  gInjection = getSysTime() -deadline; // stop measurement and calculate the injection duration
  gInjection <<= 1;
  mprintf("Injection (ns)              : 0x%x%08x\n", (uint32_t) (gInjection >> 32), (uint32_t) gInjection );
}

/*******************************************************************************
 *
 * Initialization
 * - discover WB devices
 * - init UART
 * - detect ECA control unit
 * - detect ECA queues
 * - timer
 * - disable IRQ
 *
 ******************************************************************************/
status_t init(void)
{
  status_t status;

  discoverPeriphery();    // mini-sdb: get info on important Wishbone infrastructure, such as (this) CPU, flash, ...

  uart_init_hw();         // init UART, required for printf... . To view print message, you may use 'eb-console' from the host

  mprintf("\n Wishbone device detection (%s)\n", __FILE__);

  if (pEca)
    mprintf("ECA event input                @ 0x%08x\n", (uint32_t) pEca);
  else {
    mprintf("Could not find the ECA event input. Exit!\n");
    return STATUS_ERR;
  }

  mprintf("Mailbox                        @ 0x%08x\n", (uint32_t)pCpuMsiBox);
  mprintf("MSI destination path of LM32   : 0x%08x\n", (uint32_t)pMyMsi);

  cpuId = getCpuIdx();    // get ID of THIS CPU

  pEcaCtl = find_device_adr(ECA_SDB_VENDOR_ID, ECA_SDB_DEVICE_ID);

  if (pEcaCtl)
    mprintf("ECA channel control            @ 0x%08x\n", (uint32_t) pEcaCtl);
  else {
    mprintf("Could not find the ECA channel control. Exit!\n");
    return STATUS_ERR;
  }

  status = findEcaQueue();
  if (status == STATUS_OK)
    mprintf("ECA queue to eCPU action ch    @ 0x%08x\n", (uint32_t) pECAQ);
  else {
    mprintf("Could not find an ECA queue connected to eCPU action ch. Exit!\n");
    return status;
  }

  fwlib_publishNICData(); // NIC data (MAC, IP) are assigned to global variables (pSharedIp, pSharedMacHi/Lo)

  timer_init(1);          // needed by usleep_init()
  usleep_init();          // needed by scu_mil.c

  isr_table_clr();        // set MSI IRQ handler
  irq_set_mask(0x01);     // ...
  irq_disable();          // ...

  return STATUS_OK;
}

/*******************************************************************************
 * \brief Do action in the 'op ready' state
 *
 * Main loop routine
 *
 * \param[in] actStatus Actual operation status
 * \return    status    Return status
 ******************************************************************************/
uint32_t doActionOperation(uint32_t actStatus)                // actual status of firmware
{

  uint32_t status;         // status returned by routines

  status = actStatus;

  /* Iterate all tasks except a dummy task with index 0. */
  // Run the continuous tasks always (with interval 'ALWAYS').
  // Run the periodic tasks only if the number of ticks since the last time
  // the task was run is greater than or equal to the task interval.
  msrTickActEntr = getSysTime();

  // iterate all tasks
  for (taskIdx = 1; taskIdx < N_BURSTS; taskIdx++) {

    if (pTask[taskIdx].interval == ALWAYS) {
      // run the continuous task
      (*pTask[taskIdx].func)(taskIdx);

    } else if ((msrTickActEntr - pTask[taskIdx].lasttick) >= pTask[taskIdx].interval) {
      // run the periodic task
      (*pTask[taskIdx].func)(taskIdx);
      pTask[taskIdx].lasttick = msrTickActEntr;  // save timestamp at which the task was ran
    }

    ecaMsiHandler(0);                  // handle pending ECA MSI
  }

  msrMeasureActionPeriod(msrTickActEntr, msrTickActExit); // measure a time interval to execute all io action tasks

  msrTickActExit = getSysTime();             // action completed

  return status;
}

/*******************************************************************************
 * \brief Entry action for the 'configure' state
 *
 * Called with the COMMON_CMD_CONFIGURE user command from the host.
 * Initialize application relevant components.
 *
 * \return status Return status
 ******************************************************************************/
uint32_t extern_entryActionConfigured()
{
  uint32_t status = COMMON_STATUS_OK;

  msrInitActionTiming();           // initialize the main loop performance measurement

  DBPRINT1(BG_TAG, "configured");

  return status;
}

/*******************************************************************************
 * \brief Clears all statistics
 *
 ******************************************************************************/
void extern_clearDiag()
{
  // ... insert code here
}

/*******************************************************************************
 * \brief Entry action for the 'op ready' state
 *
 ******************************************************************************/
uint32_t extern_entryActionOperation()
{
  uint32_t status = COMMON_STATUS_OK;

  //... insert code here

  return status;
}

/*******************************************************************************
 * \brief Exit action for the 'op ready' state
 *
 ******************************************************************************/
uint32_t extern_exitActionOperation()
{
  uint32_t status = COMMON_STATUS_OK;

  //... insert code here

  return status;
}

int main(void) {
  uint32_t status;      // (error) status
  uint32_t cmd;         // command via shared memory
  uint32_t actState;    // actual FSM state
  uint32_t pubState;    // value of published state
  uint32_t reqState;    // requested FSM state
  uint32_t *buildID;
  uint32_t sharedSize;

  // init local variables
  reqState       = COMMON_STATE_S0;
  actState       = COMMON_STATE_UNKNOWN;
  pubState       = COMMON_STATE_UNKNOWN;
  status         = COMMON_STATUS_OK;
  buildID        = (uint32_t *)(INT_BASE_ADR + BUILDID_OFFS);

  // init
  if (init() != COMMON_STATUS_OK)                     // initialize stuff for lm32: discover mailbox, own MSI path, ECA
    return COMMON_STATUS_ERROR;

  if (initSharedMem(&sharedSize) != COMMON_STATUS_OK) // initialize shared memory pointers
    return COMMON_STATUS_ERROR;

  fwlib_init((uint32_t *)_startshared, (uint32_t *)pCpuRamExternal, SHARED_OFFS, sharedSize, "burstgen", BG_FW_VERSION); // init common stuff
  fwlib_clearDiag();                                                   // clear common diagnostic data

  setup();                                            // set up application relevant stuff

  while (1) {
    check_stack_fwid(buildID);                                         // check for stack corruption
    fwlib_cmdHandler(&reqState, &cmd);                                 // check for common commands and possibly request state changes
    cmdHandler(&actState, &reqState, cmd);                             // check for project relevant commands
    status = COMMON_STATUS_OK;                                         // reset status for each iteration
    status = fwlib_changeState(&actState, &reqState, status);          // handle requested state changes
    switch(actState) {                                                 // state specific do actions
      case COMMON_STATE_OPREADY :
        status = doActionOperation(status);
        if (status == COMMON_STATUS_WRBADSYNC) reqState = COMMON_STATE_ERROR;
        if (status == COMMON_STATUS_ERROR)     reqState = COMMON_STATE_ERROR;
        break;
      default :                                                        // avoid flooding WB bus with unnecessary activity
        status = fwlib_doActionState(&reqState, actState, status);     // handle do actions states
        break;
    } // switch

    // update sum status
    switch (status) {
      case COMMON_STATUS_OK :                                                  // status OK
        statusArray = statusArray |  (0x1 << COMMON_STATUS_OK);                // set OK bit
        break;
      default :                                                                // status not OK
        if ((statusArray >> COMMON_STATUS_OK) & 0x1) fwlib_incBadStatusCnt();  // changing status from OK to 'not OK': increase 'bad status count'
        statusArray = statusArray & ~(0x1 << COMMON_STATUS_OK);                // clear OK bit
        statusArray = statusArray |  (0x1 << status);                          // set status bit and remember other bits set
        break;
    } // switch status

    // update shared memory
    if ((pubState == COMMON_STATE_OPREADY) && (actState  != COMMON_STATE_OPREADY)) fwlib_incBadStateCnt();
    fwlib_publishStatusArray(statusArray);
    pubState             = actState;
    fwlib_publishState(pubState);
    // ... insert code here
  } // while

  return(1);
}
