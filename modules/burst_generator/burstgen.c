/*******************************************************************************
 *  burstgen.c (derived from lm32 example)
 *
 *  created : 2019, GSI Darmstadt
 *  author  : Dietrich Beck, Enkhbold Ochirsuren
 *  version : 14-Jun-2019
 *
 *  This example demonstrates the pulse generation at IO (of SCU) according to
 *  the ECA timing event principle: ECA condition table is configured with
 *  rules for embedded CPU (eCPU) actions and IO actions. The pulses are
 *  generated by IO actions, which are produced with internal timing messages
 *  sent from LM32. The eCPU actions are used to control pulse generation.
 *  They are produced by external timing messages and handled by LM32.
 *
 *  The pulse generation consists of two phases:
 *   1. Configuration - host configures ECA for both eCPU and IO actions and
 *      provides pulse parameters and production cycle to LM32
 *   2. Production - on eCPU action LM32 starts to send timing messages
 *      periodically to ECA event input to produce IO actions (pulses at IO).
 *      The pulse generation is stopped either after a certain time period or
 *      by another dedicated eCPU action.
 *
 *  A dedicated saftlib tool, saft-burst-ctl, is used to configure bursts.
 *
 *  build:  make clean && make TARGET=burstgen
 *  deploy: scp burstgen.bin root@scuxl0304.acc:.
 *  load:   eb-fwload dev/wbm0 u 0x0 burstgen.bin
 *  run:    eb-reset dev/wbm0 cpureset 0 (assume only one LM32 is instantiated)
 *  debug:  eb-console dev/wbm0
 *
 * -----------------------------------------------------------------------------
 * License Agreement for this software:
 *
 * Copyright (C) 2017  Dietrich Beck
 * GSI Helmholtzzentrum für Schwerionenforschung GmbH
 * Planckstraße 1
 * D-64291 Darmstadt
 * Germany
 *
 * Contact: d.beck@gsi.de
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 3 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library. If not, see <http://www.gnu.org/licenses/>.
 *
 * For all questions and ideas contact: d.beck@gsi.de
 * Last update: 25-April-2015
 ******************************************************************************/

/* standard includes */
#include <stdio.h>
#include <string.h>
#include <inttypes.h>
#include <stdint.h>

/* includes specific for bel_projects */
#include "mprintf.h"
#include "mini_sdb.h"
#include "aux.h"
#include "dbg.h"
#include "syscon.h"

#include "bg.h" // burst generation

/* function prototypes */
void buildTimingMsg(uint32_t *msg, uint32_t id); // build timing message
void injectTimingMsg(uint32_t *msg);  // inject timing message to ECA event input
void ecaHandler(uint32_t);            // pop pending eCPU actions from ECA queue

int ecaMsiHandler(int id);           // handler for the ECA MSIs
int hostMsiHandler(int id);          // handler for host MSIs
int triggerIoActions(int id);        // trigger IO actions to generate pulses

/* definitions of MSI message buffers */
enum {
  ECA_MSI = 0,
  HOST_MSI,
  N_MSI_BUF
};

/* task configuration table */
static Task_t tasks[N_TASKS];
static Task_t *pTask = &tasks[0];     // task table pointer
static uint32_t gBurstsCreated = 0x0; // created bursts, bitwise, bit 0 = burst 1
static uint32_t gBurstsCycled = 0x0;  // triggered & completed bursts, bitwise, bit 0 = burst 1

volatile struct message_buffer msg_buf[N_MSI_BUF] = {0};   // MSI message buffers
volatile struct message_buffer *pMsgBufHead = &msg_buf[0]; // pointer to MSI msg buffer head

uint32_t bufTimMsg[LEN_TIM_MSG];  // buffer of timing message for IO action (will be sent by this LM32)

/* burst trigger/toggle control */
static Config_t gTrigConfigs[N_CONFIGS] = {0, 0};
static Config_t gToggConfigs[N_CONFIGS] = {0, 0};
static Config_t *pTrigConfigs = &gTrigConfigs[0];
static Config_t *pToggConfigs = &gToggConfigs[0];

static Control_t gTrigCtrl = {0, 0};
static Control_t gToggCtrl = {0, 0};

/* stuff required for environment */
unsigned int cpuId, cpuQty;
#define SHARED __attribute__((section(".shared")))
uint64_t SHARED dummy = 0;

// global variables
volatile uint32_t *pEcaCtl;         // WB address of ECA control
volatile uint32_t *pEca;            // WB address of ECA event input (discoverPeriphery())
volatile uint32_t *pECAQ;           // WB address of ECA queue
volatile uint32_t *pShared;         // pointer to begin of shared memory region
volatile uint32_t *pCpuRamExternal; // external address (seen from host bridge) of this CPU's RAM
volatile uint32_t *pSharedInput;    // pointer to a "user defined" u32 register; here: get input from host system
volatile uint32_t *pSharedCmd;      // pointer to a "user defined" u32 register; here: get commnand from host system
volatile uint32_t *pHostMbSlot;     // WB address of a mailbox slot subscribed by a host system

uint64_t gInjection = 0;            // time duration for local message injection to ECA event input
int gEcaChECPU = 0;                 // ECA channel for an embedded CPU (LM32), connected to ECA queue pointed by pECAQ
int gMbSlot = -1;                   // slot in mailbox subscribed by LM32, no slot is subscribed by default

/* stuff for built-in measurements */
#define N_ELAPSED  4                // points to measure elapsed time to handle ECA MSIs
uint64_t tElapsed[N_ELAPSED] = {0};
#define N_ACT_CNT  5                // counters for ECA MSIs
volatile uint32_t *pSharedActCnt;   // pointer to ECA action counters (located at shared memory)
#define N_MEASURES  3               // points to measure time interval to execute all io action tasks
volatile uint64_t tickFirstTask;    // time point to execute the first io action task
volatile uint64_t intervalCur, intervalMax;   // current and maximum time intervals spent to execute all io action tasks
volatile uint64_t *pMeasures;       // ticks for each tasks
int enableSchedulerMeasure = 1;     // control flag to dis/enable the scheduler period measurement (cmd 0x77 toggles it)

static void initSchedulerMeasure(void)
{
  tickFirstTask = intervalCur = intervalMax = 0;

  if (pShared) {
    static uint64_t taskSchedTicks[N_TASKS + N_MEASURES];
    static uint32_t ecaActCounters[N_ACT_CNT];
    pMeasures = taskSchedTicks;
    pSharedActCnt = ecaActCounters;

    for (int idx = 0; idx < N_ACT_CNT; ++idx)  // clear ECA action counters
      *(pSharedActCnt +idx) = 0;

    for (int idx = 0; idx < (N_TASKS + N_MEASURES); ++idx) // clear buffers for measurements
      *(pMeasures +idx) = 0;

    mprintf("Built-in measurements are activated.\n");
    uint32_t offset = (uint32_t)(pMeasures + N_TASKS) - (uint32_t)pShared;
    mprintf("IO task periods (curr, max) available @ 0x%08x (ext 0x%08x)\n",
	(uint32_t)(pMeasures + N_TASKS), (uint32_t)(pCpuRamExternal + ((SHARED_OFFS + offset) >> 2)));
  }
  else {
    pSharedActCnt = 0;
    pMeasures = 0;
    mprintf("No built-in measurements!\n");
  }
}

static void doSchedulerMeasure(int taskIdx, uint64_t tick)
{
  if (pMeasures == 0)
    return;

  if (enableSchedulerMeasure == 0)
    return;

  //*(pMeasures + taskIdx) = tick;                  // kepp the tick of each task
  if (taskIdx == 1)                               // keep the tick of the first io task
  {
    tickFirstTask = tick;
    *(pMeasures + N_TASKS + 2) = tick;
  }
  else if ((taskIdx +1) == N_TASKS)               // the last io task is done
  {
    if (tickFirstTask) {
      intervalCur = tick - tickFirstTask;         // get time interval to execute all IO action tasks
      *(pMeasures + N_TASKS) = intervalCur;       // keep the current interval

      if (intervalCur > intervalMax) {
	intervalMax = intervalCur;
	*(pMeasures + N_TASKS + 1) = intervalMax; // keep the maximum interval
      }
    }
  }
}

void printMsiHandleMeasurement(void)
{
  mprintf("\tiH  %x:%8x\n", (uint32_t)(tElapsed[0] >> 32), (uint32_t)tElapsed[0]);
  uint64_t p = tElapsed[1] - tElapsed[0];
  mprintf("\teM< %x:%8x\n", (uint32_t)(p >> 32), (uint32_t)p);
  p = tElapsed[2] - tElapsed[1];
  mprintf("\teH  %x:%8x\n", (uint32_t)(p >> 32), (uint32_t)p);
  p = tElapsed[3] - tElapsed[1];
  mprintf("\teM> %x:%8x\n", (uint32_t)(p >> 32), (uint32_t)p);
  memset(tElapsed, 0, sizeof(uint64_t) * N_ELAPSED);
}

void printTrgTggCtlCfg(void)
{
  mprintf("\n\tbursts, deadline\n\t");
  mprintf("trig: 0x%x, 0x%Lx\n\t", gTrigCtrl.bursts, gTrigCtrl.deadline);
  mprintf("togg: 0x%x, 0x%Lx\n", gToggCtrl.bursts, gToggCtrl.deadline);
  mprintf("\n\tevent id : bursts\n\t");

  for (int i = 0; i < N_CONFIGS; ++i) {
    mprintf("%Lx:%x ", gTrigConfigs[i].id, gTrigConfigs[i].bursts);
    if (((i + 1) % 4) == 0)
      mprintf("\n\t");
  }

  mprintf("\n\t");
  for (int i = 0; i < N_CONFIGS; ++i) {
    mprintf("%Lx:%x ", gToggConfigs[i].id, gToggConfigs[i].bursts);
    if (((i + 1) % 4) == 0)
      mprintf("\n\t");
  }
}

int printSharedInput(int start, int end)
{
  int i = 0;
  for (i = start; i < end; ++i)
    mprintf("%8x @ 0x%x\n", *(pSharedInput +i), (uint32_t)(pSharedInput +i));

  return i;
}

static int printTaskContext(int id) {
  int cnt;
  cnt =  mprintf(" 0x%x: 0x%x,", id, pTask[id].flag);
  cnt += mprintf(" 0x%x, 0x%x,", pTask[id].io_type, pTask[id].io_index);
  cnt += mprintf(" 0x%Lx, 0x%Lx\n", pTask[id].trigger, pTask[id].toggle);
  return cnt;
}

static int updateConfigs(Config_t *configs, uint64_t e_id, int id, int set) {

  int i, pos = N_CONFIGS;

  if (configs == 0)          // null pointer check
    return pos;

  if (e_id == 0 || id == 0)  // allow only non-zero event id and burst id
    return pos;

  for (i = 0; i < N_CONFIGS; ++i)
    if ((configs + i)->id == e_id)
      pos = i;

  i = 0;
  while ((pos == N_CONFIGS) && (i < N_CONFIGS)) {
    if ((configs + i)->id == 0) {
      pos = i;
      i = N_CONFIGS;
    }
    ++i;
  }

  if (pos == N_CONFIGS)
    return pos;

  if (set) {
    (configs + pos)->bursts |= 0x1 << (id - 1);
    (configs + pos)->id = e_id;
  }
  else {
    (configs + pos)->bursts &= ~(0x1 << (id -1));
    if ((configs + pos)->bursts == 0 )
      (configs + pos)->id = 0;
  }

  return pos;
}
/*******************************************************************************
 *
 * Trigger IO actions to generate pulses at IO pin
 *
 ******************************************************************************/
int triggerIoActions(int id) {

  int result = STATUS_OK;

  if (id == 0)
    return result;

  // check trigger/toggle control flags
  uint32_t bMask = 0x1 << (id - 1);

  if (gTrigCtrl.bursts & bMask) {  // trigger flag is set
    gTrigCtrl.bursts &= ~bMask;
    pTask[id].lasttick = 0;
    pTask[id].failed = 0;
    pTask[id].deadline = gTrigCtrl.deadline;
  }
  else if (gToggCtrl.bursts & bMask) { // toggle flag is set
    gToggCtrl.bursts &= ~bMask;
    if (pTask[id].deadline == 0) {     // cycle never run or already stopped, cancel it
      pTask[id].cycle = 0;
    }
    else if (pTask[id].deadline >= gToggCtrl.deadline) {  // deadline is over, stop immediatelly
      pTask[id].deadline = 0;
      pTask[id].cycle = 0;
      gBurstsCycled |= (0x1 << (id - 1));
    }
    else if (pTask[id].cycle != 0) { // update remaining cycle (consider endless loop)
      uint64_t remaining = gToggCtrl.deadline - pTask[id].deadline;
      if (remaining < pTask[id].period)
	pTask[id].cycle = 1;
      else
	pTask[id].cycle = remaining / pTask[id].period + 1;
    }

    if (pTask[id].cycle == 0)        // production cycle is over, cannot trigger!
      result = STATUS_NOT_READY;
  }

  if (pTask[id].flag & CTL_EN == CTL_DIS)   // burst is disabled, do not trigger!
    result = STATUS_DISABLED;

  if (pTask[id].deadline == 0)     // deadline is unset, cannot trigger!
    result = STATUS_NOT_READY;

  uint64_t deadline = pTask[id].deadline;
  uint64_t now = getSysTime();
  int64_t elapsed_injection = deadline - now;

  *(bufTimMsg   ) = EVT_ID_IO_H32 + (id << 4); // update peripheral timing message
  *(bufTimMsg +6) = hiU32(deadline);
  *(bufTimMsg +7) = loU32(deadline);

  if (elapsed_injection <= 0) // late!
  {
    if (pTask[id].failed == 0)
      pTask[id].failed = now;
    result = STATUS_ERR;
  }

  if (result != STATUS_OK)
  {
    // delay generation: 183 for 7376 ns (doubled time duration to execute the trigger operations)
    // 150/6320 ns, 120/5888 ns, 100/5248, 90/4928, 70/4288
    for (int i = 0; i < 150; i++) // FIXME: extended the dry-run period
      asm("nop");

    return result;
  }
  else if ((pTask[id].lasttick == 0) ||
      (( elapsed_injection < pTask[id].period) && // next period of a pulse block or initial injection (depends on lasstick)
      (pTask[id].lasttick < now)))               // the only injection in this period
  {
    injectTimingMsg(bufTimMsg);  // inject internal timing message for IO actions

    pTask[id].lasttick = pTask[id].deadline; // update the task timestamp
    pTask[id].deadline += pTask[id].period;  // update deadline for next trigger

    if (pTask[id].cycle > 0)     // verify and update the production cycle
    {
      if (--pTask[id].cycle == 0)
      {
	pTask[id].deadline = 0;
	gBurstsCycled |= (0x1 << (id - 1));
      }
    }
    return result;
  }

  return STATUS_IDLE;
}

/*******************************************************************************
 *
 * Clear failed actions
 *
 ******************************************************************************/
void clearFailedActions()
{
  atomic_on();

  *(pEcaCtl + (ECA_CHANNEL_SELECT_RW >> 2)) = gEcaChECPU;    // select ECA channel for LM32
  *(pEcaCtl + (ECA_CHANNEL_NUM_SELECT_RW >> 2)) = 0;         // set the subchannel index to 0

  *(pEcaCtl + (ECA_CHANNEL_CODE_SELECT_RW >> 2)) = (ECA_FG_DELAYED >> 16);
  *(pEcaCtl + (ECA_CHANNEL_FAILED_COUNT_GET >> 2));          // read and clear the delayed counter
  *(pEcaCtl + (ECA_CHANNEL_CODE_SELECT_RW >> 2)) = (ECA_FG_CONFLICT >> 16);
  *(pEcaCtl + (ECA_CHANNEL_FAILED_COUNT_GET >> 2));          // read and clear the conflict counter
  *(pEcaCtl + (ECA_CHANNEL_CODE_SELECT_RW >> 2)) = (ECA_FG_EARLY >> 16);
  *(pEcaCtl + (ECA_CHANNEL_FAILED_COUNT_GET >> 2));          // read and clear the early counter
  *(pEcaCtl + (ECA_CHANNEL_CODE_SELECT_RW >> 2)) = (ECA_FG_LATE >> 16);
  *(pEcaCtl + (ECA_CHANNEL_FAILED_COUNT_GET >> 2));          // read and clear the late counter

  atomic_off();
}

/*******************************************************************************
 *
 * Clear old actions
 *
 ******************************************************************************/
void clearOldActions()
{
  atomic_on();

  *(pEcaCtl + (ECA_CHANNEL_SELECT_RW >> 2)) = gEcaChECPU;    // select ECA channel for LM32
  *(pEcaCtl + (ECA_CHANNEL_NUM_SELECT_RW >> 2)) = 0;         // set the subchannel index to 0

  uint32_t full  = *(pEcaCtl + (ECA_CHANNEL_MOSTFULL_ACK_GET >> 2)) & 0xFFFF0000;
  full >>= 16;
  for (int i = 0; i < full; ++i)
    *(pECAQ + (ECA_QUEUE_POP_OWR >> 2)) = 0x1;               // clear the fill status of the ECA channel for LM32

  *(pEcaCtl + (ECA_CHANNEL_OVERFLOW_COUNT_GET >> 2));        // read and clear the overflow counter
  *(pEcaCtl + (ECA_CHANNEL_VALID_COUNT_GET >> 2));           // read and clear the valid counter

  atomic_off();

  clearFailedActions();
}

/*******************************************************************************
 *
 * Handle pending valid actions
 *
 ******************************************************************************/
void handleValidActions()
{
  uint32_t valCnt;
  atomic_on();
  *(pEcaCtl + (ECA_CHANNEL_SELECT_RW >> 2)) = gEcaChECPU;    // select ECA channel for LM32
  *(pEcaCtl + (ECA_CHANNEL_NUM_SELECT_RW >> 2)) = 0;         // set the subchannel index to 0
  valCnt = *(pEcaCtl + (ECA_CHANNEL_VALID_COUNT_GET >> 2));  // read and clear valid counter
  atomic_off();
  //mprintf("\nvalid=%d\n", valCnt);
  tElapsed[2] = getSysTime();

  if (valCnt != 0)
    ecaHandler(valCnt);                             // pop pending valid actions

  if (pSharedActCnt) {
    valCnt = *(pSharedActCnt);
    *(pSharedActCnt) = ++valCnt;                    // count the valid actions (cnt value at +0x00)

    if (valCnt == 0) {                              // something went wrong to read the valid action counter!
      valCnt = *(pSharedActCnt + 3);                // count the not-valid actions (cnt value at +0x0c)
      *(pSharedActCnt +3) = ++valCnt;
    }
  }
}

/*******************************************************************************
 *
 * Handle a pending ECA MSI
 *
 ******************************************************************************/
int ecaMsiHandler(int id)
{
  if (has_msg(pMsgBufHead, ECA_MSI)) {

    struct msi m = remove_msg(pMsgBufHead, ECA_MSI);

    tElapsed[1] = getSysTime();
    tElapsed[2] = tElapsed[1];
    uint32_t cnt = 0;
    //mprintf("\n!Got MSI 0x%08x (h16: 0-3 faild, 4 vald, 5 ovrflw, 6 full)\n", m.msg); // debugging, remove later

    switch (m.msg & ECA_FG_MASK)
    {
      case ECA_FG_VALID: // valid actions are pending
	handleValidActions(); // ECA MSI handling
	break;
      case ECA_FG_MOSTFULL:
	if (pSharedActCnt) {
	  cnt = *(pSharedActCnt +1);
	  *(pSharedActCnt +1) = ++cnt; // count the full messages (cnt value at +0x04)
	}
	break;
      case ECA_FG_LATE:
	clearFailedActions();
	if (pSharedActCnt) {
	  cnt = *(pSharedActCnt +4);
	  *(pSharedActCnt +4) = ++cnt; // count the late actions (cnt value at +0x10)
	}
	break;
      default:
	clearFailedActions();
	if (pSharedActCnt) {
	  cnt = *(pSharedActCnt +2);
	  *(pSharedActCnt +2) = ++cnt; // count other actions (cnt value at +0x08)
	}
	break;
    }

    tElapsed[3] = getSysTime();
  }

  return STATUS_OK;
}

/*******************************************************************************
 *
 * Configure ECA to send MSI to embedded soft-core LM32:
 * - MSI is sent on production of actions for the ECA action
 *   channel for LM32
 * - ECA action channel is selected and MSI target address of LM32 is set in the
 *   ECA MSI target register
 *
 * @param[in] enable  Enable or disable ECA MSI
 * @param[in] channel The index of the selected ECA action channel
 *
 ******************************************************************************/
void configureEcaMsi(int enable, uint32_t channel) {

  if (enable != 0 && enable != 1) {
    mprintf("Bad enable argument. %s\n", errMsgEcaMsi);
    return;
  }

  if (channel > ECAQMAX) {
    mprintf("Bad channel argument. %s\n", errMsgEcaMsi);
    return;
  }

  clearOldActions();     // clean ECA queue and channel from previous actions

  atomic_on();
  *(pEcaCtl + (ECA_CHANNEL_SELECT_RW >> 2)) = channel;            // select channel
  *(pEcaCtl + (ECA_CHANNEL_NUM_SELECT_RW >> 2)) = 0;         // set the subchannel index to 0
  *(pEcaCtl + (ECA_CHANNEL_MSI_SET_ENABLE_OWR >> 2)) = 0;         // disable ECA MSI (required to set a target address)
  *(pEcaCtl + (ECA_CHANNEL_MSI_SET_TARGET_OWR >> 2)) = (uint32_t)pMyMsi;  // set MSI destination address as a target address
  *(pEcaCtl + (ECA_CHANNEL_MSI_SET_ENABLE_OWR >> 2)) = enable;    // enable ECA MSI
  atomic_off();

  mprintf("\nMSI path (ECA -> LM32)      : %s\n\tECA channel = %d\n\tdestination = 0x%08x)\n",
          enable == 1 ? "enabled" : "disabled", channel, (uint32_t)pMyMsi);
}

/*******************************************************************************
 *
 * Respond to host request
 *
 * @param[in] data Response data to host request
 *
 ******************************************************************************/
void respondToHost(uint32_t data)
{
  if (pHostMbSlot) {
    *pHostMbSlot = data;
    //mprintf("\t0x%x is written into 0x%x\n", data, (uint32_t)pHostMbSlot);
  }
}

/*******************************************************************************
 *
 * Check if unhandled MSI messages exist
 *
 * /return  status  Returns non-zero value if unhandled MSI messages exist
 *
 ******************************************************************************/
int hasPendingMsi(void)
{
  return (has_msg(pMsgBufHead, ECA_MSI) || has_msg(pMsgBufHead, HOST_MSI));
}

/*******************************************************************************
 *
 * Handle MSIs
 *
 * Any WB device connected to MSI crossbar as a master can send MSIs: ECA, SCU bus etc.
 * Besides data value, an MSI message includes also a destination address.
 * In order to identify a particular sender, LM32 has to inform them distinct
 * MSI destinations as its destination address.
 *
 * Handling ECA MSIs
 * If interrupt was caused by a valid ECA action, then MSI has value of (4<<16|num).
 * Both ECA action channel and ECA queue connected to that channel must be handled:
 * - read and clear the valid counter value of ECA action channel for LM32 and,
 * - pop pending actions from ECA queue connected to this action channel
 *
 ******************************************************************************/
void irqHandler() {

  struct msi m;
  m.msg = global_msi.msg;
  m.adr = global_msi.adr;

  uint32_t sender = m.adr & MSI_OFFS_MASK;
  switch (sender) {

    case MSI_OFFS_ECA:     // ECA
      tElapsed[0] = getSysTime();

      add_msg(pMsgBufHead, ECA_MSI, m);
      break;

    case MSI_OFFS_HOST:    // HOST
      add_msg(pMsgBufHead, HOST_MSI, m);
      break;

    default:
      mprintf("%s: %x Unknown MSI sender. Cannot handle MSI!\n", m.adr);
  }
  //mprintf(" MSI:\t%08x\nAdr:\t%08x\nSel:\t%01x\n", global_msi.msg, global_msi.adr, global_msi.sel);
}

/*******************************************************************************
 *
 * Initialize interrupt table
 * - set up an interrupt handler
 * - enable interrupt generation globally
 *
 ******************************************************************************/
void initIrqTable() {
  isr_table_clr();
  memset((void *)pMsgBufHead, 0, N_MSI_BUF * sizeof(struct message_buffer));
  if (hasPendingMsi())
  {
    mprintf("MSI buffers are not empty!!!\n");
    mprintf("Cannot enable interrupt!!!\n");
    return;
  }
  else
    mprintf("MSI buffers are clean.\n");

  isr_ptr_table[0] = &irqHandler;
  irq_set_mask(0x01);
  irq_enable();
  mprintf("Init IRQ table is done.\n");
}

/*******************************************************************************
 *
 * Demonstrate exchange of data to Wishbone via shared RAM
 * - the data can be accessed via Etherbone->Wishbone
 * - try eb-read/eb-write from the host system
 *
 ******************************************************************************/
void initSharedMem()
{
  uint32_t i,j;
  uint32_t idx;
  const uint32_t c_Max_Rams = 10;
  sdb_location found_sdb[c_Max_Rams];
  sdb_location found_clu;

  // get pointer to shared memory; internal perspective of this LM32
  pShared        = (uint32_t *)_startshared;                // begin of shared mem

  // print pointer info to UART
  mprintf("\n");
  mprintf("Internal shared memory    @ 0x%08x\n", (uint32_t)pShared);

  // get pointer to shared memory; external perspective from host bridge
  idx = 0;
  find_device_multi(&found_clu, &idx, 1, GSI, LM32_CB_CLUSTER);
  idx = 0;
  find_device_multi_in_subtree(&found_clu, &found_sdb[0], &idx, c_Max_Rams, GSI, LM32_RAM_USER);
  if(idx >= cpuId) {
    pCpuRamExternal = (uint32_t*)(getSdbAdr(&found_sdb[cpuId]) & 0x7FFFFFFF); // CPU sees the 'world' under 0x8..., remove that bit to get host bridge perspective
    // print external WB info to UART
    mprintf("External shared memory    @ 0x%08x\n", (uint32_t)(pCpuRamExternal + (SHARED_OFFS >> 2)));
  } else {
    pCpuRamExternal = (uint32_t*)ERROR_NOT_FOUND;
    mprintf("Could not find external WB address of my own RAM !\n");
  }
}

/*******************************************************************************
 *
 * Get/subscribe slot in mailbox
 *
 * Check mailbox slots starting from the second slot. If a slot has the same
 * destination address, then re-use it. If a slot is free, then subscribe it.
 *
 * @param[in] offset  Offset address used to recognize a sender.
 * /return    slot    Subscribed slot number. Returns -1, if no free slot is found.
 *
 ******************************************************************************/
int getMboxSlot(uint32_t offset)
{
  uint32_t myDestAddr = (uint32_t)(pMyMsi + (offset >> 2));
  uint32_t destination;
  unsigned char notFound = 1;
  uint8_t slot = 1;

  atomic_on();
  while (notFound && (slot < 128))
  {
    destination = *(pCpuMsiBox + (slot << 1)); // get destination address
    if (destination == myDestAddr)             // slot has my destination address
      notFound = 0;
    else if (destination == 0xffffffff) {      // slot is free, subscribe it
      cfgMsiBox(slot,offset);
      notFound = 0;
    }
    else
      slot++;
  }
  atomic_off();

  return (notFound ? -1 : slot);
}

/*******************************************************************************
 *
 * Find WB address of ECA queue connect to ECA channel for LM32
 *
 * - ECA queue address is set to "pECAQ"
 * - index of ECA channel for LM32 is set to "gEcaChECPU"
 *
 * /return  status  Return OK if a queue is found, otherwise return ERROR
 *
 ******************************************************************************/
uint32_t findEcaQueue()
{
  sdb_location EcaQ_base[ECAQMAX];
  uint32_t EcaQ_idx = 0;
  uint32_t *tmp;
  int i;

  // get list of ECA queues
  find_device_multi(EcaQ_base, &EcaQ_idx, ECAQMAX, ECA_QUEUE_SDB_VENDOR_ID, ECA_QUEUE_SDB_DEVICE_ID);
  pECAQ = 0x0;

  // find ECA queue connected to ECA channel for LM32
  for (i=0; i < EcaQ_idx; i++) {
    tmp = (uint32_t *)(getSdbAdr(&EcaQ_base[i]));
    //mprintf("-- found ECA queue 0x%08x, idx %d\n", (uint32_t)tmp, i);
    if ( *(tmp + (ECA_QUEUE_QUEUE_ID_GET >> 2)) == ECACHANNELFORLM32) {
      pECAQ = tmp;    // update global variables
      gEcaChECPU = ECACHANNELFORLM32 +1; // refer to eca_queue_regs.h
      i = EcaQ_idx;   // break loop
    }
  }

  return (pECAQ ? STATUS_OK : STATUS_ERR);
}

/*******************************************************************************
*
* Pop pending eCPU actions from an ECA queue and handle them
*
* @param[in] cnt The number of pending valid actions
*
*******************************************************************************/
void ecaHandler(uint32_t cnt)
{
  uint32_t flag;                // flag for the next action
  uint32_t evtIdHigh;           // event id (high 32bit)
  uint32_t evtIdLow;            // event id (low 32bit)
  uint32_t evtDeadlHigh;        // deadline (high 32bit)
  uint32_t evtDeadlLow;         // deadline (low 32bit)
  uint32_t actTag;              // tag of action
  uint32_t paramHigh;           // event parameter (high 32bit)
  uint32_t paramLow;            // event parameter (low 32bit)
  uint64_t evtId;

  for (int i = 0; i < cnt; ++i) {  // TODO: avoid loop!!!
    // read flag and check if there was an action
    flag         = *(pECAQ + (ECA_QUEUE_FLAGS_GET >> 2));
    if (flag & (0x0001 << ECA_VALID)) {
      // read data
      evtIdHigh    = *(pECAQ + (ECA_QUEUE_EVENT_ID_HI_GET >> 2));
      evtIdLow     = *(pECAQ + (ECA_QUEUE_EVENT_ID_LO_GET >> 2));
      evtDeadlHigh = *(pECAQ + (ECA_QUEUE_DEADLINE_HI_GET >> 2));
      evtDeadlLow  = *(pECAQ + (ECA_QUEUE_DEADLINE_LO_GET >> 2));
      actTag       = *(pECAQ + (ECA_QUEUE_TAG_GET >> 2));
      paramHigh    = *(pECAQ + (ECA_QUEUE_PARAM_HI_GET >> 2));
      paramLow     = *(pECAQ + (ECA_QUEUE_PARAM_LO_GET >> 2));

      // pop action from channel
      *(pECAQ + (ECA_QUEUE_POP_OWR >> 2)) = 0x1;

      // here: do s.th. according to action
      if (actTag == MY_ACT_TAG) {
        //mprintf("id: 0x%08x:%08x; deadline: 0x%08x:%08x; param: 0x%08x:%08x; flag: 0x%08x\n",
          //      evtIdHigh, evtIdLow, evtDeadlHigh, evtDeadlLow, paramHigh, paramLow, flag);

	toU64(evtIdHigh, evtIdLow, evtId);

	uint64_t d, p;

	toU64(evtDeadlHigh, evtDeadlLow, d);
	toU64(paramHigh, paramLow, p);

	// extend the trigger and toggle deadlines with an extra delay giving the task scheduler
	// enough time to trigger/stop the burst generation within its period:
	// T_scheduler = T_ecaMsiHandler + N_tasks * T_tasks
	// T_scheduler = 20 us + 16 * 9 us = 164 us (measured)
	if (p && p > INTERVAL_200US)
	  d +=p;       // apply an external delay
	else
	  d += INTERVAL_200US; // apply an internal delay

	// find an entry with the given e_id in the config table
	// update control flag
	// - check if the flag equals to zero before update
	// - check the forbidden state (trig and togg must not be set at the same time)
	int trigger_idx = N_CONFIGS;
	int toggle_idx = N_CONFIGS;

	for (int j = 0; j < N_CONFIGS; ++j) { // FIXME: search takes longer! Make it periodic with const short execution time!
	  if ((pTrigConfigs + j)->id == evtId)
	    trigger_idx = j;
	  if ((pToggConfigs + j)->id == evtId)
	    toggle_idx = j;
	}

	if (trigger_idx != N_CONFIGS) {

	  gTrigCtrl.bursts |= (pTrigConfigs + trigger_idx)->bursts;
	  gTrigCtrl.deadline = d;

	  if ((gToggCtrl.bursts & gTrigCtrl.bursts) != 0) {
	    // Conflict: toggle and trigger for the same bursts! TODO: react!
	  }
	}
	else if (toggle_idx != N_CONFIGS) {

	  gToggCtrl.bursts |= (pToggConfigs + toggle_idx)->bursts;
	  gToggCtrl.deadline = d;

	  if ((gTrigCtrl.bursts & gToggCtrl.bursts) != 0) {
	    // Conflict: trigger and toggle for the same bursts! TODO: react
	  }
	}
      }
    }
  }
}

/*******************************************************************************
 *
 * Execute commands received from host
 *
 * @param[i]  cmd  Predefined command code
 *
 ******************************************************************************/
void execHostCmd(int32_t cmd)
{
  int result = STATUS_OK;
  uint64_t e_id;
  uint32_t h32, l32, id;
  int first, last;
  // check, if a command has been issued (no cmd: 0x0)
  if (cmd) {
    mprintf("\ncmd 0x%x: ", cmd);
    switch (cmd) {

      case CMD_SHOW_ALL:    // show pulse parameters
	mprintf("show\n");  // show actual state

	id = *pSharedInput;
	if (0 < id && id <= N_BURSTS) {
	  mprintf("id = 0x%x, flag=0x%x\n", id, pTask[id].flag);
	  mprintf("trig=0x%x:%x, togg=0x%x:%x\n",
	    (uint32_t)(pTask[id].trigger >> 32),  (uint32_t)pTask[id].trigger,
	    (uint32_t)(pTask[id].toggle >> 32),   (uint32_t)pTask[id].toggle);
	  mprintf("cycle=0x%x:%x, period=0x%x:%x, deadln=0x%x:%x\n",
	    (uint32_t)(pTask[id].cycle >> 32),    (uint32_t)pTask[id].cycle,
	    (uint32_t)(pTask[id].period >> 32),   (uint32_t)pTask[id].period,
	    (uint32_t)(pTask[id].deadline >> 32), (uint32_t)pTask[id].deadline);
	}
	else if (id == 0) {
	  for (int i = 1; i <= N_BURSTS; ++i) {
	    if (pTask[i].flag & CTL_VALID) {
	      mprintf("id = 0x%x, flag=0x%x\n", i, pTask[id].flag);
	      mprintf("trig=0x%x:%x, togg=0x%x:%x\n",
		(uint32_t)(pTask[i].trigger >> 32),  (uint32_t)pTask[i].trigger,
		(uint32_t)(pTask[i].toggle >> 32),   (uint32_t)pTask[i].toggle);
	      mprintf("cycle=0x%x:%x, period=0x%x:%x, deadln=0x%x:%x\n",
		(uint32_t)(pTask[i].cycle >> 32),    (uint32_t)pTask[i].cycle,
		(uint32_t)(pTask[i].period >> 32),   (uint32_t)pTask[i].period,
		(uint32_t)(pTask[i].deadline >> 32), (uint32_t)pTask[i].deadline);
	    }
	  }
	}
	break;

      case CMD_GET_PARAM:    // get parameters of the given burst
	mprintf("get parameters\n");

	id = *pSharedInput;
	if (0 < id && id <= N_BURSTS) {
	  if ((pTask[id].flag & CTL_VALID) != 0) {
	    uint32_t b_flag = *(pSharedInput +4);
	    if (b_flag == 1)
	      pTask[id].period += *(pSharedInput +3);
	    else
	      pTask[id].period = *(pSharedInput +3);

	    if (*(pSharedInput +5)) // verbose
	      printSharedInput(0, 5);
	  }
	}
	else {
	  result = STATUS_ERR;
	  mprintf("failed: %d\n", id);
	  break;
	}
	break;

      case CMD_GET_CYCLE:    // get the number of cycles (cycles * period of a pulse block) of the given burst
	mprintf("get cycle\n");

	id = *pSharedInput;
	if (0 < id && id <= N_BURSTS) {
	  if ((pTask[id].flag & CTL_VALID) != 0) {
	    toU64(*(pSharedInput +1), *(pSharedInput +2), pTask[id].cycle);

	    if (*(pSharedInput + 3)) // verbose
	      printSharedInput(0, 3);

	    pTask[id].deadline = 0;
	  }
	}
	else {
	  result = STATUS_ERR;
	  mprintf("failed: %d\n", id);
	  break;
	}
	break;

      case CMD_RD_MSI_ECPU: // read the ECA MSI settings for eCPU
	mprintf("read MSI cfg\n");

	atomic_on();
	*(pEcaCtl + (ECA_CHANNEL_SELECT_RW >> 2)) = gEcaChECPU;              // select channel for eCPU
	*(pEcaCtl + (ECA_CHANNEL_NUM_SELECT_RW >> 2)) = 0;         // set the subchannel index to 0
	uint32_t dest   = *(pEcaCtl + (ECA_CHANNEL_MSI_GET_TARGET_GET >> 2));  // get MSI destination address
	uint32_t enable = *(pEcaCtl + (ECA_CHANNEL_MSI_GET_ENABLE_GET >> 2));  // get the MSI enable flag
	atomic_off();

	mprintf("MSI dest addr   = 0x%08x\n", dest);
	mprintf("MSI enable flag = 0x%x\n", enable);

	break;

      case CMD_RD_ECPU_CHAN: // read the content of the ECA eCPU channel
	mprintf("read eCPU chan counter\n");

	atomic_on();
	*(pEcaCtl + (ECA_CHANNEL_SELECT_RW >> 2)) = gEcaChECPU;    // select ECA channel for eCPU
	*(pEcaCtl + (ECA_CHANNEL_NUM_SELECT_RW >> 2)) = 0;         // set the subchannel index to 0
	uint32_t valid    = *(pEcaCtl + (ECA_CHANNEL_VALID_COUNT_GET >> 2));
	uint32_t overflow = *(pEcaCtl + (ECA_CHANNEL_OVERFLOW_COUNT_GET >> 2));
	uint32_t failed   = *(pEcaCtl + (ECA_CHANNEL_FAILED_COUNT_GET >> 2));
	uint32_t full     = *(pEcaCtl + (ECA_CHANNEL_MOSTFULL_ACK_GET >> 2));
	atomic_off();
	mprintf("failed: 0x%x, valid: 0x%x, overflow: 0x%x, full: 0x%x\n",
		  failed, valid, overflow, full);
	break;

      case CMD_RD_ECPU_QUEUE: // read the content of ECA queue connected to eCPU channel
	mprintf("read eCPU queue\n");

	atomic_on();
	*(pEcaCtl + (ECA_CHANNEL_SELECT_RW >> 2)) = gEcaChECPU;    // select ECA channel for eCPU
	*(pEcaCtl + (ECA_CHANNEL_NUM_SELECT_RW >> 2)) = 0;         // set the subchannel index to 0
	uint32_t flag      = *(pECAQ + (ECA_QUEUE_FLAGS_GET >> 2));
	uint32_t evtHigh   = *(pECAQ + (ECA_QUEUE_EVENT_ID_HI_GET >> 2));
	uint32_t evtLow    = *(pECAQ + (ECA_QUEUE_EVENT_ID_LO_GET >> 2));
	uint32_t tag       = *(pECAQ + (ECA_QUEUE_TAG_GET >> 2));
	uint32_t paramHigh = *(pECAQ + (ECA_QUEUE_PARAM_HI_GET >> 2));
	uint32_t paramLow  = *(pECAQ + (ECA_QUEUE_PARAM_LO_GET >> 2));
	atomic_off();
	mprintf("event: 0x%08x:%08x, param: 0x%08x:%08x, tag: 0x%08x, flag: 0x%08x\n",
		  evtHigh, evtLow, paramHigh, paramLow, tag, flag);
	break;

      case CMD_LS_BURST: // list burst (if id==0, then IDs of available bursts are written into memory, otherwise burst info)
	mprintf("ls burst\n");

	id = *pSharedInput;
	uint32_t verbose = *(pSharedInput + 1);

	if (id == 0) {
	  *pSharedInput = gBurstsCreated;
	  *(pSharedInput + 1) = gBurstsCycled;

	  if (verbose)
	    mprintf(" created: 0x%x, cycled: 0x%x\n", gBurstsCreated, gBurstsCycled);

	  gBurstsCycled = 0; // clear after read
	}
	else if (id <= N_BURSTS) {
	  *(pSharedInput +1) = (uint32_t)pTask[id].io_type;  // IO type and index (type << 16| index)
	  *(pSharedInput +2) = (uint32_t)pTask[id].io_index;
	  *(pSharedInput +3) = (uint32_t)(pTask[id].trigger >> 32); // trigger event id
	  *(pSharedInput +4) = (uint32_t)pTask[id].trigger;
	  *(pSharedInput +5) = (uint32_t)(pTask[id].toggle >> 32); // get toggle event id
	  *(pSharedInput +6) = (uint32_t)pTask[id].toggle;
	  *(pSharedInput +7) = (uint32_t)(pTask[id].cycle >> 32); // get cycle count
	  *(pSharedInput +8) = (uint32_t)pTask[id].cycle;
	  *(pSharedInput +9) = (uint32_t)pTask[id].flag;

	  if (verbose)
	    printSharedInput(0, N_BURST_INFO);
	}
	else {
	  result = STATUS_ERR;
	  mprintf("failed: %d\n", id);
	  break;
	}
	break;

      case CMD_MK_BURST: // declare burst with the id number
	mprintf("new burst\n");

	id = *pSharedInput;
	verbose = *(pSharedInput + 6);

	if (0 < id && id <= N_BURSTS) {
	  l32 = *(pSharedInput +1); // IO type and index (type << 16| index)
	  pTask[id].io_type = (uint8_t)(l32 >> 16);
	  pTask[id].io_index = (uint8_t)l32;
	  h32 = *(pSharedInput +2); // get trigger event id
	  l32 = *(pSharedInput +3);
	  toU64(h32, l32, e_id);
	  pTask[id].trigger = e_id;

	  h32 = *(pSharedInput +4); // get toggle event id
	  l32 = *(pSharedInput +5);
	  toU64(h32, l32, e_id);
	  pTask[id].toggle = e_id;

	  pTask[id].period = 0;
	  pTask[id].cycle = 0;
	  pTask[id].deadline = 0;
	  pTask[id].state = 0;
	  pTask[id].flag = CTL_VALID;
	  gBurstsCreated |= 0x1 << (id - 1);

	  // update trigger/toggle configuration tables
	  if (pTask[id].trigger)
	    updateConfigs(pTrigConfigs, pTask[id].trigger, id, 1);
	  if (pTask[id].toggle)
	    updateConfigs(pToggConfigs, pTask[id].toggle, id, 1);

	  if (verbose)
	    printTaskContext(id);
	}
	else {
	  result = STATUS_ERR;
	  mprintf("failed: %d\n", id);
	  break;
	}
	break;

      case CMD_RM_BURST: // remove burst
	mprintf("remove burst\n");

	id = *pSharedInput;
	verbose = *(pSharedInput + 1);

	if (0 < id && id <= N_BURSTS) {
	  pTask[id].flag = CTL_DIS;
	  gBurstsCreated &= ~(0x1 << (id -1));

	  // update trigger/toggle configuration tables
	  if (pTask[id].trigger)
	    updateConfigs(pTrigConfigs, pTask[id].trigger, id, 0);
	  if (pTask[id].toggle)
	    updateConfigs(pToggConfigs, pTask[id].toggle, id, 0);

	  pTask[id].io_type = 0;
	  pTask[id].io_index = 0;
	  pTask[id].trigger = 0;
	  pTask[id].toggle = 0;

	  if (verbose)
	    printTaskContext(id);
	}
	else {
	  result = STATUS_ERR;
	  mprintf("failed: %d\n", id);
	  break;
	}
	break;

      case CMD_DE_BURST: // dis/enable burst with the id number (=0 all)
	mprintf("dis/enable burst\n");

	id = *pSharedInput;                   // burst id
	uint32_t disen = *(pSharedInput + 1); // dis/enable selection

	verbose = *(pSharedInput +2);         // verbose
	first = -1;
	last = -1;

	if (id == 0) {
	  first = 1;
	  last = N_BURSTS;
	}
	else if (id <= N_BURSTS) {
	  first = last = id;
	}
	else {
	  result = STATUS_ERR;
	  mprintf("failed: %d\n", id);
	  break;
	}

	if ((pTask[id].flag & CTL_VALID) == CTL_DIS) { // break here, if burst is undeclared
	  result = STATUS_ERR;
	  mprintf("unknown: %d\n", id);
	  break;
	}

	for (int i = first; i <= last; ++i) {
	  if (disen)
	    pTask[id].flag |= CTL_EN;
	  else
	    pTask[id].flag &= ~CTL_EN;

	  if (verbose)
	    printTaskContext(id);
	}
	break;

      case CMD_LS_FW_ID: // list the firmware id
	mprintf("fw id\n");
	*pSharedInput = BG_FW_ID;
	break;

      /* commands used in firmware development */
      case 0x44: // print elapsed time to handle MSIs
	mprintf("MSI handle\n");
	printMsiHandleMeasurement();
	break;

      case 0x55: // print the trigger/toggle control and trigger/toggle configuration tables
	mprintf("trg/tgg\n");
	printTrgTggCtlCfg();
	break;

      case 0x66: // print elapsed time between tasks (requires the burst id in the shared input)
	mprintf("task ticks\n\tlasttick, failed\n");
	id = *pSharedInput;
	if (id) {
	  mprintf("\t0x%016Lx, 0x%016Lx\n", pTask[id].lasttick, pTask[id].failed);
	} else {
	  for (int i = 1; i <= 10; ++i)
	    mprintf("\t0x%016Lx, 0x%016Lx\n", pTask[i].lasttick, pTask[i].failed);
	}
	break;

      case 0x77: // dis/enable to measure the task scheduler period
	mprintf("measure time to run all io tasks\n");

	mprintf("\tcurr=0x%Lx, max=0x%Lx\n", intervalCur, intervalMax);
	enableSchedulerMeasure ^= 1;

	if (enableSchedulerMeasure)
	  mprintf("\tenabled\n");
	else {
	  tickFirstTask = intervalCur = intervalMax = 0; // prepare next measurement
	  mprintf("\tdisabled\n");
	}

	break;

      default:
	mprintf("unknown\n");
	result = STATUS_ERR;
    }

    *pSharedCmd = cmd;
    cmd = (result << 16) | (cmd & 0x0000FFFF); // both instruction result and instruction code are sent by MSI
    respondToHost((uint32_t)cmd);
  }
}

/*******************************************************************************
 *
 * Handle a pending host MSI
 *
 ******************************************************************************/
int hostMsiHandler(int id)
{
  if (has_msg(pMsgBufHead, HOST_MSI)) {

    struct msi m = remove_msg(pMsgBufHead, HOST_MSI);
    execHostCmd(m.msg);
  }

  return STATUS_OK;
}

/*******************************************************************************
*
* Initialize dedicated buffers in shared memory
*
*******************************************************************************/
void initSharedBuffers()
{
  pSharedCmd = (uint32_t *)(pShared + (SHARED_CMD >> 2));       // get pointer to shared command buffer
  pSharedInput = (uint32_t *)(pShared + (SHARED_INPUT >> 2));   // get pointer to shared input buffer

  mprintf("\n");
  mprintf("Command buffer (ext)      @ 0x%08x (0x%08x)\n",
      (uint32_t)pSharedCmd, (uint32_t)(pCpuRamExternal + ((SHARED_CMD + SHARED_OFFS) >> 2)));
  mprintf("Data buffer    (ext)      @ 0x%08x (0x%08x)\n",
      (uint32_t)pSharedInput, (uint32_t)(pCpuRamExternal + ((SHARED_INPUT + SHARED_OFFS) >> 2)));
  mprintf("\n");

  *pShared = BG_FW_ID; // label the starting point of the shared memory with the firmware id
  *pSharedCmd = 0x0;  // initalize command value: 0x0 means 'no command'
}

/*******************************************************************************
 *
 * Set up MSI handlers
 *
 ******************************************************************************/
void setupMsiHandlers(void)
{
  gMbSlot = getMboxSlot(MSI_OFFS_HOST); // host MSIs are forwarded to destination address of (pMyMsi + MSI_OFFS_HOST)

  if (gMbSlot == -1)  {
    mprintf("Could not find free slot in mailbox. Exit!\n");
    return;
  }
  else  {
    if (pShared)
    {
      *(pShared + (SHARED_MB_SLOT >> 2)) = gMbSlot; // write the subscribed mailbox slot into the shared memory
    }
    else
    {
      mprintf("Logic error: shared memory must be initialized prior to the mailbox slot subscription");
      return;
    }

    uint32_t *pMyMbSlot = pCpuMsiBox + ((gMbSlot * 8) >> 2);
    mprintf("Mailbox slot for burst generator: %d, avialable for host at 0x%x (ext 0x%x)\n",
	gMbSlot, (uint32_t)(pShared + (SHARED_MB_SLOT >> 2)),
	(uint32_t)(pCpuRamExternal + ((SHARED_MB_SLOT + SHARED_OFFS) >> 2)));
    mprintf("Address of the mailbox slot (ext): 0x%x (0x%x)\n", (uint32_t)pMyMbSlot, (uint32_t)pMyMbSlot & 0x7FFFFFFF);
  }

  configureEcaMsi(1, gEcaChECPU); // ECA MSIs are sent to destination address of pMyMsi

  initIrqTable();     // set up MSI handler

  // get a mailbox slot subscribed by host
  uint32_t host_slot = *(pShared + (SHARED_MB_SLOT_H >> 2));
  if (host_slot == MB_SLOT_CFG_FREE || host_slot == 0)       // valid slot ranges are 1-127
    mprintf("Invalid mailbox slot for host = 0x%x\n", host_slot);
  else {
    pHostMbSlot = pCpuMsiBox + (host_slot << 1);
    mprintf("Mailbox slot for host            : 0x%x, available at 0x%x (ext 0x%x)\n", host_slot,
	(uint32_t)(pShared + (SHARED_MB_SLOT_H >> 2)),
	(uint32_t)(pCpuRamExternal + ((SHARED_MB_SLOT_H + SHARED_OFFS) >> 2)));
    mprintf("Address of the mailbox slot (ext): 0x%x (0x%x)\n", (uint32_t)pHostMbSlot, (uint32_t)pHostMbSlot & 0x7FFFFFFF);
  }
}

/*******************************************************************************
 *
 * Set up tasks: 0..N_BURSTS-1 for IO tasks, N_BURSTS..N_TASKS-1 for host comm
 *
 ******************************************************************************/
void setupTasks(void)
{
  memset((void *)pTrigConfigs, 0, N_CONFIGS * sizeof(Config_t));
  memset((void *)pToggConfigs, 0, N_CONFIGS * sizeof(Config_t));

  for (int taskIdx = 0; taskIdx < N_TASKS; ++taskIdx)
  {
    pTask[taskIdx].state = 0;
    pTask[taskIdx].flag = CTL_DIS;
    pTask[taskIdx].trigger = 0;
    pTask[taskIdx].toggle = 0;
    pTask[taskIdx].cycle = 0;
    pTask[taskIdx].period = 0;
    pTask[taskIdx].deadline = 0;
    pTask[taskIdx].interval = ALWAYS;
    pTask[taskIdx].lasttick = 0;
    pTask[taskIdx].failed = 0;
  }

  for (int taskIdx = 0; taskIdx < N_BURSTS; ++taskIdx)
    pTask[taskIdx].func = triggerIoActions;

  pTask[N_TASKS -1].interval = INTERVAL_1000MS;
  pTask[N_TASKS -1].func = hostMsiHandler;
}

/*******************************************************************************
 *
 * Build a timing message
 *
 * @param[out] msg The location of message buffer
 * @param[in]  id  The event id
 *
 ******************************************************************************/
void buildTimingMsg(uint32_t *msg, uint32_t id)
{
  *msg = id; // FID+GID*EVTNO+flags
  *(msg +1) = 0x0; // SID+BPID+resrv
  *(msg +2) = 0x0; // param_up
  *(msg +3) = 0x0; // param_lo
  *(msg +4) = 0x0; // resrv
  *(msg +5) = 0x0; // TEF
  *(msg +6) = 0x0;
  *(msg +7) = 0x0;

  /*mprintf("\nconstructed timing msg:\n");
  mprintf("event: %x-%x\n",msg[0], msg[1]);
  mprintf("param: %x-%x\n",msg[2], msg[3]);
  mprintf("resrv: %x\n",msg[4]);
  mprintf("TEF  : %x\n",msg[5]);*/
}

/*******************************************************************************
 *
 * Inject the given timing message to the ECA event input
 *
 * @param[in] msg The location of message buffer
 *
 ******************************************************************************/
void injectTimingMsg(uint32_t *msg)
{
  atomic_on();

  for (int i = 0; i < LEN_TIM_MSG; i++)
    *pEca = msg[i];

  atomic_off();
}

/*******************************************************************************
 *
 * Set up internal timing message for the IO actions
 *
 * @param[in]  msg  The location of message buffer
 *
 ******************************************************************************/
void setupTimingMsg(uint32_t *msg)
{
  buildTimingMsg(msg, EVT_ID_IO_H32 << 1); // build a dummy timing message

  // estimate the time duration of message injection
  uint64_t deadline = getSysTime(); // start measurement

  *(msg +6) = hiU32(deadline); // deadline can be late, don't care it
  *(msg +7) = loU32(deadline);

  injectTimingMsg(msg);        // inject a dummy message

  pTask[0].lasttick = pTask[0].deadline; // post-injection operations
  pTask[0].deadline += pTask[0].period;
  pTask[0].cycle = 1;

  if (pTask[0].cycle > 0)
  {
    if (--pTask[0].cycle == 0)
    {
      pTask[0].deadline = 0;
      gBurstsCycled |= (0x0 << (1 - 1));
    }
  }

  gInjection = getSysTime() -deadline; // stop measurement and calculate the injection duration
  gInjection <<= 1;
  mprintf("Injection (ns)              : 0x%x%08x\n", (uint32_t) (gInjection >> 32), (uint32_t) gInjection );

  buildTimingMsg(msg, EVT_ID_IO_H32); // build the default timing message for IO actions
}

/*******************************************************************************
 *
 * Initialization
 * - discover WB devices
 * - init UART
 * - detect ECA control unit
 * - detect ECA queues
 *
 ******************************************************************************/
void init()
{
  discoverPeriphery();    // mini-sdb: get info on important Wishbone infrastructure, such as (this) CPU, flash, ...

  uart_init_hw();         // init UART, required for printf... . To view print message, you may use 'eb-console' from the host

  mprintf("\n Wishbone device detection (%s)\n", __FILE__);

  if (pEca)
    mprintf("ECA event input                @ 0x%08x\n", (uint32_t) pEca);
  else {
    mprintf("Could not find the ECA event input. Exit!\n");
    return;
  }

  mprintf("Mailbox                        @ 0x%08x\n", (uint32_t)pCpuMsiBox);
  mprintf("MSI destination path of LM32   : 0x%08x\n", (uint32_t)pMyMsi);

  cpuId = getCpuIdx();    // get ID of THIS CPU

  pEcaCtl = find_device_adr(ECA_SDB_VENDOR_ID, ECA_SDB_DEVICE_ID);

  if (pEcaCtl)
    mprintf("ECA channel control            @ 0x%08x\n", (uint32_t) pEcaCtl);
  else {
    mprintf("Could not find the ECA channel control. Exit!\n");
    return;
  }

  if (findEcaQueue() == STATUS_OK)
    mprintf("ECA queue to eCPU action ch    @ 0x%08x\n", (uint32_t) pECAQ);
  else {
    mprintf("Could not find an ECA queue connected to eCPU action ch. Exit!\n");
    return;
  }

  timer_init(1);          // needed by usleep_init()
  usleep_init();          // needed by scu_mil.c

  isr_table_clr();        // set MSI IRQ handler
  irq_set_mask(0x01);     // ...
  irq_disable();          // ...
}

void main(void) {

  uint64_t tick;
  int taskIdx;          // task index

  init();               // discover mailbox, own MSI path, ECA event input, ECA queue for LM32 channel
  initSharedMem();      // init shared memory
  initSharedBuffers();  // init dedicated buffers in shared memory for command & data exchange with host

  setupTimingMsg(bufTimMsg);  // build default timing msg for IO action, estimate the duration of message injection to the ECA event input
  setupMsiHandlers();         // set up MSI handlers
  setupTasks();               // set up tasks for the IO actions and host communication, initialize the trg/tgg config table

  initSchedulerMeasure();     // init to measure the periods of the task scheduler

  while(1) {

    // loop through all tasks except a dummy task with index 0. first, run all continuous tasks. then, if the number of ticks
    // since the last time the task was run is greater than or equal to the task interval, execute the task
    for (taskIdx = 1; taskIdx < N_TASKS; taskIdx++) {

      tick = getSysTime();

      if (pTask[taskIdx].interval == ALWAYS) {
        // run contiuous tasks
        (*pTask[taskIdx].func)(taskIdx);

      } else if ((tick - pTask[taskIdx].lasttick) >= pTask[taskIdx].interval) {
        // run task
        (*pTask[taskIdx].func)(taskIdx);
        pTask[taskIdx].lasttick = tick; // save last tick the task was ran
      }

      ecaMsiHandler(0);

      doSchedulerMeasure(taskIdx, tick); // measure a time interval to execute all io action tasks
    }
  }
}
