/*
	Interbackplane frontend plugin
*/

`timescale 1 ps / 1 ps
`include "../../blackbox_defines.vh"
`include "../../blackbox_config.vh"
`include "../frontend_helpers.vh"




module frontend_interbackplane #(
		`STD_FRONTEND_PARAMS,
			// Custom parameters
		parameter		nr_cardlets						= 12
	)(
		`STD_FRONTEND_PORTS 
	);

// Check parameters

//generate
//	if (nr_status_bits < 128)
//		$error("Number of status bits insufficient!");	
//endgenerate


localparam base_pin			= 16;	// pin number for first I/O

integer 	i;
genvar		gi;

// ********** Define actual number of plugins **********
	
// *** BEGIN generated code ***
localparam nr_cardlet_plugins 		= ${len(data["configurations"][configuration]["cardlet_plugins"])};
// *** END generated code ***
localparam int_cardlet_sel_bits 	= $clog2(nr_cardlet_plugins);

// *** Cardlet signals ***
wire	[5:0]	cardlet_in	[nr_cardlets-1 : 0];
wire	[5:0]	cardlet_out	[nr_cardlets-1 : 0];
wire	[5:0]	cardlet_dir	[nr_cardlets-1 : 0];
reg		[nr_cardlets-1 : 0]	cardlet_mode;
reg		[1:0]	cardlet_str	[nr_cardlets-1 : 0];
reg		[7:0]	cardlet_type[nr_cardlets-1 : 0];
wire	[7:0]	cardlet_led1[nr_cardlets-1 : 0];
wire	[7:0]	cardlet_led2[nr_cardlets-1 : 0];
wire	[nr_cardlets-1 : 0]	cardlet_error;

// *** Common cardlet signals ***
reg	[1:0]	cardlets_oe;
reg	[7:0]	cardlets_ledb;
wire [7:0]	cardlets_ledb_in;
reg [7:0]	cardlets_ledb_dir;

// *** Multiplexer signals ***
wire	[5:0]	cardlet_out_array	[nr_cardlets-1 : 0][nr_cardlet_plugins-1 : 0];
wire	[5:0]	cardlet_dir_array	[nr_cardlets-1 : 0][nr_cardlet_plugins-1 : 0];
wire	[7:0]	cardlet_led1_array	[nr_cardlets-1 : 0][nr_cardlet_plugins-1 : 0];
wire	[7:0]	cardlet_led2_array	[nr_cardlets-1 : 0][nr_cardlet_plugins-1 : 0];
wire	[7:0]	internal_in_array	[nr_cardlets-1 : 0][nr_cardlet_plugins-1 : 0];
wire	[nr_cardlets-1 : 0]	cardlet_error_array [nr_cardlet_plugins-1 : 0];

	//Cardlet plugin selector
reg [int_cardlet_sel_bits-1: 0]	int_cardlet_plugin_select[nr_cardlets-1 : 0];
reg [nr_cardlets-1 : 0]			cardlet_plugin_default_selected;

//             /-------------------------------------------------------\ 
//             |*******************************************************| 
//             |*                 SIGNAL ASSIGNMENTS                  *| 
//             |*******************************************************| 
//             \-------------------------------------------------------/ 

//  *** Generate cardlet assignments based on json file ***
// *** BEGIN generated code ***
% for i, cardlet in enumerate(data["pinouts"]["cardlets"]):
//-------------------- Slot ${i} ----------------------
assign diob_out[${cardlet["mode"]}-base_pin]	= cardlet_mode[${i}];
assign diob_dir[${cardlet["mode"]}-base_pin]	= 1'b1;

% for j, pin in enumerate(cardlet["str"]):
assign diob_out[${pin}-base_pin]	= cardlet_str[${i}][${j}];
assign diob_dir[${pin}-base_pin]	= 1'b1;

%endfor
% for j, pin in enumerate(cardlet["io"]):
assign diob_out[${pin}-base_pin]	= cardlet_out[${i}][${j}];
assign diob_dir[${pin}-base_pin]	= cardlet_dir[${i}][${j}];
assign cardlet_in[${i}][${j}]		= diob_in[${pin}-base_pin];

%endfor
%endfor
//----------------------------------------------------
// *** END generated code ***

//  *** Generate common signal assignments based on json file ***
// *** BEGIN generated code ***
% for j, pin in enumerate(data["pinouts"]["oe"]):
assign diob_out[${pin}-base_pin]	= cardlets_oe[${j}];
assign diob_dir[${pin}-base_pin]	= 1'b1;
%endfor

% for j, pin in enumerate(data["pinouts"]["ledb"]):
assign diob_out[${pin}-base_pin]	= cardlets_ledb[${j}];
assign diob_dir[${pin}-base_pin]	= cardlets_ledb_dir[${j}];
assign cardlets_ledb_in[${j}]		= diob_in[${pin}-base_pin];
%endfor

// *** END generated code ***

//             /-------------------------------------------------------\ 
//             |*******************************************************| 
//             |*                   LEDB SEQUENCER                    *| 
//             |*******************************************************| 
//             \-------------------------------------------------------/ 


reg[2:0]	ledb_state;
reg[$clog2(nr_cardlets)-1 : 0]	ledb_cardlet_nr;	//Current cardlet communicated
reg[6:0]	ledb_prescaler;		//For limiting loop speed to about 1 MHz

localparam LEDB_STATE_START			= 0;
localparam LEDB_STATE_ID_PREPARE	= 1;
localparam LEDB_STATE_ID_READ		= 2;
localparam LEDB_STATE_STR1_1		= 3;
localparam LEDB_STATE_STR1_2		= 4;
localparam LEDB_STATE_STR2_1		= 5;
localparam LEDB_STATE_STR2_2		= 6;
localparam LEDB_STATE_LOOP			= 7;



always @(posedge clock, posedge reset)
begin
	if (reset)
	begin
		for (i = 0; i < nr_cardlets; i = i+1)
		begin
			cardlet_type[i] <= 'hFF;
			cardlet_str[i]	<= 'b11;		// For LED initialization
			cardlet_mode[i]	<= 'b1;
		end	
		cardlets_oe			<= 'b00;		// Assert output enables
		cardlets_ledb		<= 0;			// For switching off all LEDs (TODO: think about keeping them on for half a second or so)	
		cardlets_ledb_dir	<= 'hFF;
		ledb_prescaler		<= 'h7F;
		ledb_cardlet_nr		<= nr_cardlets-1;
		ledb_state			<= LEDB_STATE_START;
	end
	else
	begin
		ledb_prescaler <= ledb_prescaler - 1;
		if (ledb_prescaler == 0)
			case (ledb_state)
				LEDB_STATE_START:		// *** Finish LED reset ***
				begin
					for (i = 0; i < nr_cardlets; i = i+1)
						cardlet_str[i]	<= 'b00;		// Finish LED initialization
					ledb_state			<= LEDB_STATE_LOOP;	
				end
				
				LEDB_STATE_ID_PREPARE: 	// *** Setup signals for ID readout ***
				begin
					cardlets_ledb_dir	<= 'h00;
					cardlet_mode[ledb_cardlet_nr]	<= 1'b0;		
					ledb_state			<= LEDB_STATE_ID_READ;	
				end
				
				LEDB_STATE_ID_READ:		// *** Reado out cardlet ID ***
				begin
					cardlet_type[ledb_cardlet_nr]	<= cardlets_ledb_in;
					cardlet_mode[ledb_cardlet_nr]	<= 1'b1;	
					ledb_state			<= LEDB_STATE_STR1_1;
				end
				
				LEDB_STATE_STR1_1:		// *** Set LEDs with strobe 1 - phase 1
				begin
					cardlets_ledb_dir	<= 'hFF;
					cardlets_ledb		<= ~cardlet_led1[ledb_cardlet_nr];
					cardlet_str[ledb_cardlet_nr]	<= 'b01;
					ledb_state			<= LEDB_STATE_STR1_2;
				end
				
				LEDB_STATE_STR1_2:		// *** Set LEDs with strobe 1 - phase 2
				begin
					cardlet_str[ledb_cardlet_nr]	<= 'b00;
					ledb_state			<= LEDB_STATE_STR2_1;
				end

				LEDB_STATE_STR2_1:		// *** Set LEDs with strobe 2 - phase 1
				begin
					cardlets_ledb_dir	<= 'hFF;
					cardlets_ledb		<= ~cardlet_led2[ledb_cardlet_nr];
					cardlet_str[ledb_cardlet_nr]	<= 'b10;
					ledb_state			<= LEDB_STATE_STR2_2;
				end
				
				LEDB_STATE_STR2_2:		// *** Set LEDs with strobe 2 - phase 2
				begin
					cardlet_str[ledb_cardlet_nr]	<= 'b00;
					ledb_state			<= LEDB_STATE_LOOP;
				end
				
				LEDB_STATE_LOOP:		// *** Bus precharge + close the loop
				begin
					if (ledb_cardlet_nr == (nr_cardlets-1))
						ledb_cardlet_nr	<= 0;
					else
						ledb_cardlet_nr	<= ledb_cardlet_nr + 1;
					cardlets_ledb		<= 'hFF;	// Bus precharge
					ledb_state			<= LEDB_STATE_ID_PREPARE;
				end
				
				default:
				begin
					ledb_state			<= LEDB_STATE_START;
				end
						
			endcase
	end
end

//             /-------------------------------------------------------\ 
//             |*******************************************************| 
//             |*              PLUGIN SELECT REMAPPING                *| 
//             |*******************************************************| 
//             \-------------------------------------------------------/ 

// ********** Remap (external) plugin select signals to internal (sqeezed) selects which (probably) need less bits ********** 

generate
	for (gi = 0; gi < nr_cardlets; gi = gi + 1) 
	begin : gen_plugin_select	
		always @(*)
		begin
			case (cardlet_type[gi])
				// *** BEGIN generated code ***
			% for i, mp in enumerate(data["configurations"][configuration]["cardlet_plugins"]):
				% for name, device in data["cardlet_plugins"][mp]["devices"].items():
					${device["id"]}${":" if loop.last else ","}		// ${name}
				% endfor
				begin	
					int_cardlet_plugin_select[gi] <= ${i};	// ${mp}
					cardlet_plugin_default_selected[gi] <= 0;
				end	
			% endfor	
				default: 
				begin
					int_cardlet_plugin_select[gi] <= 0;	// default: ${data["configurations"][configuration]["cardlet_plugins"][0]}
					cardlet_plugin_default_selected[gi] <= 1;
				end	
				// *** END generated code ***
			endcase
		end	//always
	end	//for
endgenerate

//             /-------------------------------------------------------\ 
//             |*******************************************************| 
//             |*                SIGNAL DEMULTIPLEXING                *| 
//             |*******************************************************| 
//             \-------------------------------------------------------/ 

generate
	for (gi = 0; gi < nr_cardlets; gi = gi + 1) 
	begin : gen_signal_mux	
		assign cardlet_out[gi]  = cardlet_out_array		[gi][int_cardlet_plugin_select[gi]];
		assign cardlet_dir[gi]  = cardlet_dir_array		[gi][int_cardlet_plugin_select[gi]];
		assign cardlet_led1[gi] = cardlet_led1_array	[gi][int_cardlet_plugin_select[gi]];
		assign cardlet_led2[gi] = cardlet_led2_array	[gi][int_cardlet_plugin_select[gi]];
		assign `slice(internal_in, 8, gi) = internal_in_array[gi][int_cardlet_plugin_select[gi]];
		assign cardlet_error[gi] = cardlet_error_array	[int_cardlet_plugin_select[gi]][gi];
	end	//for
endgenerate


//             /-------------------------------------------------------\ 
//             |*******************************************************| 
//             |*                      PLUGINS                        *| 
//             |*******************************************************| 
//             \-------------------------------------------------------/ 

generate
	for (gi = 0; gi < nr_cardlets; gi = gi + 1) 
		begin : gen_cardlets
		// *** BEGIN generated code ***
		% for i, plugin in enumerate(data["configurations"][configuration]["cardlet_plugins"]):
		% if data["cardlet_plugins"][plugin]["parameters"]:
		${data["cardlet_plugins"][plugin]["unit"]} #(
			% for param_name, param_value in data["cardlet_plugins"][plugin]["parameters"].items():
			.${param_name}	(${param_value})${'' if loop.last else ','}
			% endfor	
		) cardlet_inst_${plugin} (
		% else: 
		${data["cardlet_plugins"][plugin]["unit"]} cardlet_inst_${plugin} (
		% endif
			.clock       	(clock),
			.reset       	(reset),

			.plugin_enable	(int_cardlet_plugin_select[gi] == ${i} ? 1'b1 : 1'b0),
			.plugin_error	(cardlet_error_array[${i}][gi]),
		
			.diob_in		(cardlet_in[gi]),
			.diob_out		(cardlet_out_array[gi][${i}]),
			.diob_dir		(cardlet_dir_array[gi][${i}]),
			.diob_led1		(cardlet_led1_array[gi][${i}]),
			.diob_led2		(cardlet_led2_array[gi][${i}]),
		
			.internal_out	(`slice(internal_out, 8, gi)),
			.internal_in	(internal_in_array[gi][${i}]),
			.output_enable	(`slice(output_enable, 8, gi)),
			.input_enable	(`slice(input_enable, 8, gi)),
			.output_act		(`slice(output_act, 8, gi)),
			.input_act		(`slice(input_act, 8, gi))

		);			

		% endfor	
		// *** END generated code ***	
	end
endgenerate	


//             /-------------------------------------------------------\ 
//             |*******************************************************| 
//             |*                  STATUS OUTPUTS                     *| 
//             |*******************************************************| 
//             \-------------------------------------------------------/ 

	//Assert plugin error if any cardlet asserted error or default was selected (lacking ID)
assign plugin_error 					= (|cardlet_error) | (|cardlet_plugin_default_selected);

generate
	for (gi = 0; gi < nr_cardlets; gi = gi + 1) 
	begin : gen_plugin_status		
		assign `slice(plugin_status, 8, gi) = cardlet_type[gi];		//12 LSBs - cardlet types (96 bits = 6 registers)
	end	//for
endgenerate

assign `slice(plugin_status, 16, 6) = cardlet_plugin_default_selected;	// 7th register: default selected flags
assign `slice(plugin_status, 16, 7) = cardlet_error;					// 8th register: cardlet errors flag
 
endmodule