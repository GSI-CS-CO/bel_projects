-- WARNING: Do NOT edit the input and output ports in this file in a text
-- editor if you plan to continue editing the block that represents it in
-- the Block Editor! File corruption is VERY likely to occur.

-- Copyright (C) 1991-2004 Altera Corporation
-- Any  megafunction  design,  and related netlist (encrypted  or  decrypted),
-- support information,  device programming or simulation file,  and any other
-- associated  documentation or information  provided by  Altera  or a partner
-- under  Altera's   Megafunction   Partnership   Program  may  be  used  only
-- to program  PLD  devices (but not masked  PLD  devices) from  Altera.   Any
-- other  use  of such  megafunction  design,  netlist,  support  information,
-- device programming or simulation file,  or any other  related documentation
-- or information  is prohibited  for  any  other purpose,  including, but not
-- limited to  modification,  reverse engineering,  de-compiling, or use  with
-- any other  silicon devices,  unless such use is  explicitly  licensed under
-- a separate agreement with  Altera  or a megafunction partner.  Title to the
-- intellectual property,  including patents,  copyrights,  trademarks,  trade
-- secrets,  or maskworks,  embodied in any such megafunction design, netlist,
-- support  information,  device programming or simulation file,  or any other
-- related documentation or information provided by  Altera  or a megafunction
-- partner, remains with Altera, the megafunction partner, or their respective
-- licensors. No other licenses, including any licenses needed under any third
-- party's intellectual property, are provided herein.


-- Generated by Quartus II Version 4.1 (Build Build 208 09/10/2004)
-- Created on Mon Apr 25 11:51:16 2005

-- ###########################################################################
--
-- (c) IFI Riekert & Sprenger
--
-- Datei:	EPCS_SPI.VHD
--
-- Funktion:
--  
-- Datum:	1.0 25.04.2005
--			1.1 25.07.2005	cont added
--
-- 
-- in Zukunft: 
--
-- Copyright 2005 IFI Riekert & Sprenger
-- ###########################################################################

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;
USE ieee.std_logic_arith.all;


--  Entity Declaration

ENTITY EPCS_SPI IS
	-- {{ALTERA_IO_BEGIN}} DO NOT REMOVE THIS LINE!
	PORT
	(
		clk : IN STD_LOGIC;
		clrn : IN STD_LOGIC;
		ena : IN STD_LOGIC;
		cmd : IN STD_LOGIC_VECTOR(7 downto 0);
		SA : IN STD_LOGIC_VECTOR(23 downto 0);
		SD : IN STD_LOGIC_VECTOR(7 downto 0);
		req : IN STD_LOGIC;
		cont : IN STD_LOGIC;
		LOADER_WRnRD : OUT STD_LOGIC;
		SQ : OUT STD_LOGIC_VECTOR(7 downto 0);
		store : OUT STD_LOGIC;
		inkr : OUT STD_LOGIC;
		fertig : OUT STD_LOGIC;
		LOADER_DB : INOUT STD_LOGIC_VECTOR(3 downto 0)
	);
	-- {{ALTERA_IO_END}} DO NOT REMOVE THIS LINE!
	
END EPCS_SPI;


--  Architecture Body

ARCHITECTURE EPCS_SPI_architecture OF EPCS_SPI IS

signal	SCK		: STD_LOGIC;
signal  CSn		: STD_LOGIC;
signal  SI		: STD_LOGIC;
signal  DATA	: STD_LOGIC;
signal  ena_spi	: STD_LOGIC;
signal  cs		: std_logic;
signal  start	: std_logic;
signal  shiftout: std_logic;
signal  shiftin : std_logic;
signal  shiftin2 : std_logic;
signal  rdink		: std_logic;
signal  stor	: std_logic;

signal	sreg	: std_logic_vector(7 downto 0);
signal	sinreg	: std_logic_vector(7 downto 0);
signal  bitcnt	: std_logic_vector(7 downto 0);
signal  bytedone	: std_logic;

type sctrl_t is (idle, tostart, 
cmd_load, wait_cmd, 
adr_load0, wait_load0,
adr_load1, wait_load1,
adr_load2, wait_load2,
data_load, wait_data,
toend);
signal sctrl : sctrl_t;
	
BEGIN

LOADER_WRnRD	<= not ena_spi;	-- 17.08.2005
LOADER_DB(0)	<= SCK;
LOADER_DB(1)	<= SI;
LOADER_DB(2)	<= CSn;
LOADER_DB(3)	<= 'Z' when (clrn = '1') else '0';
DATA			<= LOADER_DB(3);

ena_spi			<= '0' when (sctrl = idle)and(cont = '0') else '1';

fertig			<= '1' when (sctrl = idle) else '0';

-- Ablauf ###############################################################
pctrl: process(clk,clrn)
begin
	if (clrn = '0') then
		sctrl <= idle;
	elsif rising_edge(clk) then
	if (ena = '1') then
		CASE sctrl IS
		WHEN idle =>		if (req = '1') then
								sctrl <= tostart;
							end if;
							
		WHEN tostart =>		sctrl <= cmd_load;
		
		WHEN cmd_load =>	sctrl	<= wait_cmd;
		
		WHEN wait_cmd =>	if (bytedone = '1') then
								if (cmd = X"03")or(cmd = X"02")or(cmd = X"D8")or(cmd = X"AB") then
									sctrl	<= adr_load0;
								elsif (cmd = X"05")or(cmd = X"01") then
									sctrl	<= data_load; 
								else
									sctrl	<= toend;
								end if;
							end if;
		
		WHEN adr_load0 =>	sctrl	<= wait_load0;
		
		WHEN wait_load0 =>	if (bytedone = '1') then
								sctrl <= adr_load1;
							end if;
							
		WHEN adr_load1 =>	sctrl	<= wait_load1;
		
		WHEN wait_load1 =>	if (bytedone = '1') then
								sctrl <= adr_load2;
							end if;
							
		WHEN adr_load2 =>	sctrl	<= wait_load2;
		
		WHEN wait_load2 =>	if (bytedone = '1') then
								if (cmd = X"D8") then
									sctrl <= toend;		-- Erase sector hat Adresse aber keine Daten
								else
									sctrl <= data_load;
								end if;
							end if;
							
		WHEN data_load =>	sctrl	<= wait_data;
		
		WHEN wait_data =>	if (bytedone = '1') then
								if (cmd = X"05")or(cmd = X"89")or(cmd = X"01") then
									sctrl <= toend;
								elsif (req = '1') then
									sctrl <= data_load;
								else
									sctrl <= toend;
								end if;
							end if;
			
		WHEN toend =>		sctrl <= idle;
		
		WHEN OTHERS =>		sctrl <= toend;
		END CASE;
		end if;
	end if;
end process pctrl;

-- Bittiming ############################################################
SCK		<= bitcnt(1);
CSn		<= not cs;
inkr	<= rdink;
store	<= stor;

ptime: process (clk,clrn)
begin
	if (clrn = '0') then
		bitcnt		<= (others => '0');
		bytedone	<= '0';
		cs			<= '0';
		shiftout	<= '0';
		shiftin		<= '0';
		shiftin2	<= '0';
		rdink			<= '0';
		stor		<= '0';
	elsif rising_edge(clk) then
		if (ena = '1') then
			if (start = '1') then
				bitcnt	<= X"1F";
			elsif (bitcnt > 0) then
				bitcnt	<= bitcnt - 1;
			end if;
			
			if (bitcnt = "01") then
				bytedone <= '1';
			else
				bytedone <= '0';
			end if;
			
			if (bitcnt(1 downto 0) = "10") then
				shiftout <= '1';
			else
				shiftout <= '0';
			end if;
			
			if (bitcnt(1 downto 0) = "11")and(sctrl = wait_data) then
				shiftin <= '1';
			else
				shiftin <= '0';
			end if;
			shiftin2	<= shiftin;
			
			if (sctrl = tostart) then
				cs	<= '1';
			elsif (sctrl = idle)or(sctrl = toend) then
				cs	<= '0';
			end if;
		end if;
		
		if (sctrl = wait_data)and(bitcnt = X"08")and(cmd = X"02") then
			rdink	<= '1';
		else
			rdink	<= '0';
		end if;
		
--		if (sctrl = wait_data)and(bytedone = '1') then
		if (sctrl = wait_data)and(bitcnt = "01")and((cmd = X"03")or(cmd = X"05")or(cmd = X"AB")) then
			stor	<= '1';
		else
			stor	<= '0';
		end if;
	end if;
end process ptime;

-- Schieberegister OUT ######################################################
SI	<= sreg(7);

pshift: process(clk,clrn)
begin
	if (clrn = '0') then
		sreg	<= (others => '0');
		start	<= '0';
	elsif rising_edge(clk) then
		if (ena = '1') then
			if (sctrl = cmd_load) then
				sreg	<= cmd;
				start	<= '1';
			elsif (sctrl = adr_load0) then
				sreg	<= SA(23 downto 16);
				start	<= '1';
			elsif (sctrl = adr_load1) then
				sreg	<= SA(15 downto 8);
				start	<= '1';
			elsif (sctrl = adr_load2) then
				sreg	<= SA(7 downto 0);
				start	<= '1';
			elsif (sctrl = data_load) then
				sreg	<= SD;
				start	<= '1';
			elsif (shiftout = '1') then
				sreg	<= sreg(6 downto 0) & '0';
				start	<= '0';
			else
				start	<= '0';
			end if;
		end if;
	end if;
end process pshift;

-- Schieberegister IN ######################################################
SQ	<= sinreg;

pishift: process(clk,clrn)
begin
	if (clrn = '0') then
		sinreg	<= (others => '0');
	elsif rising_edge(clk) then
		if (ena = '1') then
			if (shiftin = '1') then
				sinreg	<= sinreg(6 downto 0) & DATA;
			end if;
		end if;
	end if;
end process pishift;

END EPCS_SPI_architecture;
