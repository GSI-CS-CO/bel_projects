-- WARNING: Do NOT edit the input and output ports in this file in a text
-- editor if you plan to continue editing the block that represents it in
-- the Block Editor! File corruption is VERY likely to occur.

-- Copyright (C) 1991-2004 Altera Corporation
-- Any  megafunction  design,  and related netlist (encrypted  or  decrypted),
-- support information,  device programming or simulation file,  and any other
-- associated  documentation or information  provided by  Altera  or a partner
-- under  Altera's   Megafunction   Partnership   Program  may  be  used  only
-- to program  PLD  devices (but not masked  PLD  devices) from  Altera.   Any
-- other  use  of such  megafunction  design,  netlist,  support  information,
-- device programming or simulation file,  or any other  related documentation
-- or information  is prohibited  for  any  other purpose,  including, but not
-- limited to  modification,  reverse engineering,  de-compiling, or use  with
-- any other  silicon devices,  unless such use is  explicitly  licensed under
-- a separate agreement with  Altera  or a megafunction partner.  Title to the
-- intellectual property,  including patents,  copyrights,  trademarks,  trade
-- secrets,  or maskworks,  embodied in any such megafunction design, netlist,
-- support  information,  device programming or simulation file,  or any other
-- related documentation or information provided by  Altera  or a megafunction
-- partner, remains with Altera, the megafunction partner, or their respective
-- licensors. No other licenses, including any licenses needed under any third
-- party's intellectual property, are provided herein.


-- Generated by Quartus II Version 4.1 (Build Build 208 09/10/2004)
-- Created on Tue Apr 12 17:50:45 2005

-- ###########################################################################
--
-- (c) IFI Riekert & Sprenger
--
-- Datei:	modul2spi.VHD
--
-- Funktion:Umsetzung Modulbuszugriffe auf SPI
--  
-- Datum:	0.0 12.04.2005
--			1.0 25.05.2005
--			1.1 25.07.2005 cont added
--			1.2 11.08.2005 wrpause added
--			1.3 18.08.2005 Bit swap
--			1.4 19.02.2008 -W.P. Generic "Loader_Clk_in_Hz" eingfügt damit die SPI-Clk immer richtig erzeugt wird.
-- 
-- in Zukunft: 
--
-- Copyright 2005 IFI Riekert & Sprenger
-- ###########################################################################

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;
USE ieee.std_logic_arith.all;
USE IEEE.MATH_REAL.ALL;


--  Entity Declaration

ENTITY modul2spi IS
	-- {{ALTERA_IO_BEGIN}} DO NOT REMOVE THIS LINE!
	GENERIC(Loader_CLK_in_Hz: INTEGER);
	PORT
	(
		clk : IN STD_LOGIC;
		clrn : IN STD_LOGIC;
		D : IN STD_LOGIC_VECTOR(15 downto 0);
		we : IN STD_LOGIC;
		rd : IN STD_LOGIC;
		Adr : IN STD_LOGIC;						-- 0: Kontroll/Status
												-- 1: Daten read/write
		Q : OUT STD_LOGIC_VECTOR(15 downto 0);
		
		cmd : OUT STD_LOGIC_VECTOR(7 downto 0);
		SA : OUT STD_LOGIC_VECTOR(23 downto 0);
		SD : OUT STD_LOGIC_VECTOR(7 downto 0);
		SQ : IN STD_LOGIC_VECTOR(7 downto 0);
		req : OUT STD_LOGIC;
		inkr : IN STD_LOGIC;
		store : IN STD_LOGIC;
		fertig : IN STD_LOGIC;
		ena : OUT STD_LOGIC;
		
		CTRL_LOAD : IN STD_LOGIC;				-- USER wurde geladen
		CTRL_RES : IN STD_LOGIC;				-- Failsave wurde geladen
		cont : OUT STD_LOGIC;
		RELOAD : OUT STD_LOGIC;					-- Neu laden low-puls
		INIT_DONE : OUT STD_LOGIC;
		LOAD_OK : OUT STD_LOGIC;				-- default, also USER soll geladen werden
		LOAD_ERROR : OUT STD_LOGIC				-- failsave soll geladen werden
		
	);
	-- {{ALTERA_IO_END}} DO NOT REMOVE THIS LINE!
	
END modul2spi;

-- adr0 write	Kontroll
-- adr0 read	Status
-- adr1 write	Schreibdaten
-- adr1 read	Lesedaten

-- adr0 Kontroll		Status
-- D0	Reload Failsave	Failsave geladen
-- D1	Reload User		User geladen
-- D2	selLWadr		selLWadr wartet noch
-- D3	selHWadr		selHWadr wartet noch
-- D4	
-- D5	
-- D6	clear FIFO		FIFO Wleer Anzeige
-- D7	selFIFO			FIFO nicht Wvoll

-- D8	prog FIFO		Programmierung noch nicht fertig
-- D9
-- D10
-- D11					FIFO Rleer
-- D12					FIFO nicht Rvoll
-- D13	readFIFO		read pending (low Lesedaten gültig)
-- D14	Lösche Flash	Löschen nicht nicht fertig
--		Adresse muss dabei auf X"654321" stehen
-- D15	Reload User


--  Architecture Body

ARCHITECTURE amodul2spi OF modul2spi IS

CONSTANT	C_SPI_Clk_in_MHz	: INTEGER := 10;
CONSTANT	C_SPI_Clk_Cnt		: INTEGER := (Loader_CLK_in_Hz / C_SPI_Clk_in_MHz / 1000000)-2;
CONSTANT	C_SPI_Clk_Cnt_Width	: INTEGER := integer(ceil(log2(real(C_SPI_Clk_Cnt))));	-- Die Mindestbreite des Repeat-Timers.

signal vcnt		: std_logic_vector(C_SPI_Clk_Cnt_Width downto 0);	-- Vorteiler um aus den 300MHz herunter zu kommen
signal enas		: std_logic;					-- enable für den SPI
signal rload	: std_logic;	-- Reload
signal lduser	: std_logic;
signal ldfail	: std_logic;
signal rcnt		: std_logic_vector(9 downto 0);
signal conts	: std_logic;

signal adrs		: std_logic_vector(23 downto 0);	-- Adresse merken

type   mem16_type is array (127 downto 0) of std_logic_vector(15 downto 0);
-- SchreibFIFO #######################################################
signal Wram : mem16_type := (others => X"0000");	--
signal Wrqs		: std_logic_vector(15 downto 0);	-- FIFO read
signal Wradr	: std_logic_vector(7 downto 0);		-- BYTE-Adresse
signal Wvoll	: std_logic;						
signal Wleer	: std_logic;
signal Wcontents: std_logic_vector(8 downto 0);		-- Inhalt in Byte
signal Wwadr	: std_logic_vector(6 downto 0);		-- WORD-Adresse

-- LeseFIFO ###########################################################
COMPONENT rdram IS
PORT (
		data		: IN STD_LOGIC_VECTOR (7 DOWNTO 0);
		wren		: IN STD_LOGIC  := '1';
		wraddress	: IN STD_LOGIC_VECTOR (7 DOWNTO 0);
		rdaddress	: IN STD_LOGIC_VECTOR (6 DOWNTO 0);
		clock		: IN STD_LOGIC ;
		q			: OUT STD_LOGIC_VECTOR (15 DOWNTO 0)
);
END COMPONENT;

signal Rrqs		: std_logic_vector(15 downto 0);	-- FIFO read
signal Rradr	: std_logic_vector(6 downto 0);		-- BYTE-Adresse
signal Rvoll	: std_logic;						
signal Rleer	: std_logic;
signal Rcontents: std_logic_vector(8 downto 0);		-- Inhalt in Byte
signal Rwadr	: std_logic_vector(7 downto 0);		-- WORD-Adresse

signal reqs		: std_logic;
signal status	: std_logic_vector(15 downto 0);
signal selLWadr	: std_logic;
signal selHWadr	: std_logic;
signal rrd_FIFO : std_logic;
signal rdv		: std_logic;
signal resfifo	: std_logic;
signal storerf	: std_logic;

signal rd_FIFO	: std_logic;
signal store_D	: std_logic;
signal stored	: std_logic;
signal ink_wadr	: std_logic;
signal writeIP	: std_logic;
signal sds		: std_logic_vector(15 downto 0);
signal cmds		: std_logic_vector(7 downto 0);
constant cmd_we		: std_logic_vector(7 downto 0) := X"06";
constant cmd_erase	: std_logic_vector(7 downto 0) := X"C7";
constant cmd_write	: std_logic_vector(7 downto 0) := X"02";
constant cmd_read	: std_logic_vector(7 downto 0) := X"03";
constant cmd_rdstat	: std_logic_vector(7 downto 0) := X"05";

signal wdswap	: std_logic_vector(7 downto 0);	-- Bit swappen beim Schreiben
signal rdswap	: std_logic_vector(7 downto 0);	-- Bit swappen beim Lesen

type auftrag_t is (idle,
to_erase, wait_to_erase, erase, wait_erase,
to_read, wait_read,
to_write, wait_to_write, write, wait_write, wrpause1, wrpause2,
to_rdstat, wait_rdstat,
done);
signal auftrag : auftrag_t;

	
BEGIN

ASSERT (False)
	REPORT "Loader_CLK_in_Hz = " & integer'image(Loader_CLK_in_Hz) & ",   SPI_CLK_in_MHz = " & integer'image(C_SPI_CLK_in_MHz) & ",   C_SPI_Clk_Cnt = " & integer'image(C_SPI_Clk_Cnt) & ",   C_SPI_Clk_Cnt_Width = " & integer'image(C_SPI_Clk_Cnt_Width)
SEVERITY NOTE;


INIT_DONE	<= '0';

rd_FIFO	<= '1' when (inkr = '1')and(enas = '1') else '0';

-- Lesen ######################################################################
--Q	<= (status(15 downto 2) & CTRL_LOAD & CTRL_RES) when (Adr = '0') else Rrqs;
--Q	<= (status(15 downto 8) & not Wvoll & Wleer & status(5 downto 2) & CTRL_LOAD & CTRL_RES) when (Adr = '0') else Rrqs;
Q	<= (status(15 downto 13) & not Rvoll & Rleer & status(10 downto 8) & not Wvoll & Wleer & status(5 downto 2) & CTRL_LOAD & CTRL_RES) 
	when (Adr = '0') else (Rrqs(7 downto 0) & Rrqs(15 downto 8)); -- byteswap

cont	<= conts;
conts	<= '0' when (auftrag = idle) else '1';

-- interface ##################################################################
pauftrag: process(clk,clrn)
begin
	if (clrn = '0') then
		auftrag	<= idle;
	elsif rising_edge(clk) then
		CASE auftrag IS
		WHEN idle =>			if (status(14) = '1')and(adrs = X"654321") then	-- Erase all
									auftrag <= to_erase;
								elsif (status(13) = '1') then	-- read 256 Byte
									auftrag	<= to_read;
								elsif (status(8) = '1') then	-- write all from FIFO
									auftrag	<= to_write;
								end if;

		-- ERASE#############################################
		WHEN to_erase =>		if (fertig = '0') then
									auftrag <= wait_to_erase;
								end if;
		
		WHEN wait_to_erase =>	if (fertig = '1') then
									auftrag <= erase;
								end if;
		WHEN erase =>			if (fertig = '0') then
									auftrag <= wait_erase;
								end if;
		
		WHEN wait_erase =>		if (fertig = '1') then
									auftrag <= to_rdstat;
								end if;
								
		-- WRITE FIFO Inhalt #####################################
		WHEN to_write =>		if (fertig = '0') then
									auftrag <= wait_to_write;
								end if;
		
		WHEN wait_to_write =>	if (fertig = '1') then
									auftrag <= write;
								end if;
		WHEN write =>			if (fertig = '0') then
									auftrag <= wait_write;
								end if;
		
		WHEN wait_write =>		if (fertig = '1') then
									auftrag <= wrpause1;
								end if;
								
		WHEN wrpause1 =>		if (vcnt(vcnt'high) = '1') then
									auftrag <= wrpause2;
								end if;
								
		WHEN wrpause2 =>		if (vcnt(vcnt'high) = '1') then
									auftrag <= to_rdstat;
								end if;
								
		-- READ ###########################################
		WHEN to_read =>			if (fertig = '0') then
									auftrag <= wait_read;
								end if;
		
		WHEN wait_read =>		if (fertig = '1') then
									auftrag <= done;
								end if;
								
		-- ENDE Write abwarten ###########################################
		WHEN to_rdstat =>		if (fertig = '0') then
									auftrag <= wait_rdstat;
								end if;
		
		WHEN wait_rdstat =>		if (fertig = '1') then
									if (writeIP = '1') then		-- wenn Schreiben noch läuft
										auftrag <= to_rdstat;
									else
										auftrag <= done;
									end if;
								end if;
								
		WHEN done =>			auftrag <= idle;
		WHEN OTHERS =>			auftrag <= idle;
	END CASE;

	end if;
end process;

-- ############################
req	<= reqs;
cmd	<= cmds;


pif: process(clk,clrn)
begin
	if (clrn = '0') then
		reqs	<= '0';
		status	<= (others => '0');
		rdv		<= '0';
		rrd_FIFO<= '0';
		cmds	<= (others => '0');
		writeIP	<= '0';
	elsif rising_edge(clk) then
		if (auftrag = to_erase) then
			cmds	<= cmd_we;
		elsif (auftrag = erase) then
			cmds	<= cmd_erase;
		elsif (auftrag = to_write) then
			cmds	<= cmd_we;
		elsif (auftrag = write) then
			cmds	<= cmd_write;
		elsif (auftrag = to_read) then
			cmds	<= cmd_read;
		elsif (auftrag = to_rdstat) then
			cmds	<= cmd_rdstat;
		end if;
		
		if (auftrag = to_erase) then
			reqs	<= '1';
		elsif (auftrag = erase) then
			reqs	<= '1';
		elsif (auftrag = to_write) then
			reqs	<= '1';
		elsif (auftrag = write) then
			reqs	<= '1';
		elsif (auftrag = to_read) then
			reqs	<= '1';
		elsif (auftrag = to_rdstat) then
			reqs	<= '1';
		elsif (auftrag = wait_write)and(Wleer = '1') then
			reqs	<= '0';
		elsif (auftrag = wait_read)and(Rvoll = '1') then
			reqs	<= '0';
		elsif (fertig = '1') then
			reqs	<= '0';
		end if;
		
		if (store = '1') then
			writeIP	<= SQ(0);
		end if;
			
		if (rd = '1')and(Adr = '1') then
			rdv		<= '1';
		else
			rdv		<= '0';
		end if;
		if (rd = '0')and(rdv = '1') then
			rrd_fifo	<= '1';
		else
			rrd_fifo	<= '0';
		end if;
		
		if (Adr = '0')and(we = '1') then
			status	<= D;
		else
			if (rcnt(9 downto 7) = "111") then
				status(0) <= '0';
				status(1) <= '0';
				status(15) <= '0';
			end if;
			if (Adr = '1')and(we = '1') then
				status(2) <= '0';
				status(3) <= '0';
			end if;
			if (Wvoll = '1') then
				status(7)	<= '0';
			end if;
			if (auftrag = wait_write)and(fertig = '1') then
				status(8)	<= '0';
			end if;
			if (auftrag = wait_read)and(Rvoll = '1') then
				status(13)	<= '0';
			end if;
--			if (auftrag = wait_erase)and(fertig = '1') then
			if (auftrag = wait_rdstat)and(fertig = '1') then
				status(14)	<= '0';
			end if;
		end if;		
	end if;
end process pif;

-- Reload #####################################################################
RELOAD		<= not rload;
LOAD_OK		<= lduser;
LOAD_ERROR	<= ldfail;


preload: process(clk,clrn)
begin
	if (clrn = '0') then
		rload	<= '0';
		lduser	<= '0';
		ldfail	<= '0';
		rcnt	<= (others => '0');
	elsif rising_edge(clk) then
		if (status(1) = '1')or(status(15) = '1') then
			lduser	<= '1';
		else
			lduser	<= '0';
		end if;
		ldfail	<= status(0);
		
		if (rcnt(9) = '1') then
			rload	<= '0';
		elsif (status(0) = '1')or(status(1) = '1')or(status(15) = '1') then
			rload	<= '1';
		end if;
		
		if (rload = '1')or(rcnt(9) = '1') then
			if (enas = '1') then
				rcnt	<= rcnt + 1;
			end if;
		else
			rcnt	<= (others => '0');
		end if;
	end if;
end process preload;

selLWadr	<= status(2);
selHWadr	<= status(3);
resfifo		<= status(6);

-- Adresse merken #############################################################
SA	<= adrs;

padr: process(clk,clrn)
begin
	if (clrn = '0') then
		adrs	<= (others => '0');
	elsif rising_edge(clk) then
		if (Adr = '1')and(we = '1') then
			if (selLWadr = '1') then
				adrs(15 downto 0)	<= D;
			end if;
			if (selHWadr = '1') then
				adrs(23 downto 16)	<= D(7 downto 0);
			end if;
		end if;
	end if;
end process padr;

-- Vorteiler ##################################################################
ena	<= enas;

pvt: process(clk,clrn)
begin
	if ( clrn = '0') then
		vcnt	<= (others => '0');
		enas	<= '0';
	elsif rising_edge(clk) then
		enas	<= vcnt(vcnt'high);
		if (vcnt(vcnt'high) = '1') then
			vcnt	<= conv_std_logic_vector(C_SPI_Clk_Cnt, vcnt'length);-- vorläufig
		else
			vcnt	<= vcnt - 1;
		end if;
	end if;
end process pvt;

-- FIFO ######################################################################################
Wvoll	<= Wcontents(8);
Wleer	<= '1' when(Wcontents = ('0' & X"00")) else '0';

-- Lesen #####################################################################################
plesen: process(clk,clrn)
begin
	if (clrn = '0') then
		Wradr		<= (others => '0');
		Wcontents	<= (others => '0');
	elsif rising_edge(clk) then
		
		if (resfifo = '1') then		-- Am Anfang ReadFIFO löschen
			Wradr		<= (others => '0');
			Wcontents	<= (others => '0');
		elsif (ink_wadr = '1') then
			if (rd_FIFO = '1') then
				Wradr	<= Wradr + 1;						-- Lesen & Schreiben gleichzeitig
				Wcontents	<= Wcontents + 1;				-- 
			else
				Wcontents	<= Wcontents + 2;				-- nur Schreiben wordweise
			end if;
		elsif (rd_FIFO = '1')and(Wleer = '0') then
			Wradr		<= Wradr + 1;						-- nur Lesen byteweise
			Wcontents	<= Wcontents - 1;
		end if;
		
	end if;
end process plesen;

-- Wram lesen ###################################################################################
SD		<= wdswap(0) & wdswap(1) & wdswap(2) & wdswap(3) & wdswap(4) & wdswap(5) &wdswap(6) & wdswap(7);
wdswap	<= sds(7 downto 0) when (Wradr(0) = '1') else sds(15 downto 8);	-- wegen timing -- byteswap (Wradr(0) = '1')

preadr : process(clk)
begin
	if rising_edge(clk) then
		Wrqs <= Wram(conv_integer(unsigned(Wradr(7 downto 1))));
		sds	<= Wrqs;
	end if;
end process preadr;     

-- Schreiben #####################################################################################
store_D		<= '1' when (status(7) = '1')and(Adr = '1')and(we = '1') else '0';

pwrite: process(clk,clrn)
begin
	if (clrn = '0') then
		Wwadr	<= (others => '0');
		stored	<= '0';
		ink_wadr	<= '0';
	elsif rising_edge(clk) then
		stored	<= store_D;
		if (store_D = '0')and(stored = '1') then
			ink_wadr	<= '1';		-- erst am Ende die Schreibadresse inkrementieren
		else
			ink_wadr	<= '0';
		end if;
	
		if (resfifo = '1') then
			Wwadr	<= (others => '0');
		elsif (ink_wadr = '1') then
			Wwadr	<= Wwadr + 1;
		end if;
	end if;
end process pwrite;

-- FIFO beschreiben #############################################################################
pload : process (clk)
begin
	if rising_edge(clk) then									
		if (store_D = '1') then
			Wram(conv_integer(unsigned(Wwadr))) <= D;
		end if;		
	end if;                  
end process pload;

-- Lesen FIFO #####################################################################################
Rvoll	<= Rcontents(8);
Rleer	<= '1' when(Rcontents = ('0' & X"00")) else '0';

-- Lesen #####################################################################################
prlesen: process(clk,clrn)
begin
	if (clrn = '0') then
		Rradr		<= (others => '0');
		Rcontents	<= (others => '0');
	elsif rising_edge(clk) then
		
		if (resfifo = '1') then
			Rradr		<= (others => '0');
			Rcontents	<= (others => '0');
		elsif (Rvoll = '0')and(store = '1')and(enas = '1') then
			if (rrd_FIFO = '1') then
				Rradr		<= Rradr + 1;					-- Lesen & Schreiben gleichzeitig
				Rcontents	<= Rcontents - 1;				-- 
			else
				Rcontents	<= Rcontents + 1;				-- nur Schreiben 
			end if;
		elsif (rrd_FIFO = '1')and(Rleer = '0') then
			Rradr		<= Rradr + 1;						-- nur Lesen byteweise
			Rcontents	<= Rcontents - 2;
		end if;
		
	end if;
end process prlesen;

-- Read Daten ins FIFO schreiben ##################################################################
prwrite: process(clk,clrn)
begin
	if (clrn = '0') then
		Rwadr	<= (others => '0');
	elsif rising_edge(clk) then
	
		if (resfifo = '1')or(auftrag = to_read) then	-- mit Auftragsbeginn löschen
			Rwadr	<= (others => '0');
		elsif (Rvoll = '0')and(store = '1')and(enas = '1') then
			Rwadr	<= Rwadr + 1;
		end if;
	end if;
end process prwrite;

storerf	<= '1' when (store = '1')and(enas = '1') else '0';

rdswap	<= SQ(0) & SQ(1) & SQ(2) & SQ(3) & SQ(4) & SQ(5) & SQ(6) & SQ(7);	-- 18.08.2005
-- Read FIFO ######################################################################################
READram : rdram PORT MAP (
		data	 	 => rdswap,
		wren		 => storerf,
		wraddress	 => Rwadr,
		rdaddress	 => Rradr,
		clock		 => clk,
		q			 => Rrqs
);

END amodul2spi;
